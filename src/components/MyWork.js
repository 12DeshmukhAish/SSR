import React, { useState, useEffect, useRef } from "react";
import {
  Search,
  ChevronDown,
  ChevronUp,
  Trash2,
  FileText,
  faArrowRight,
  Copy,
  Edit,
} from "lucide-react";
import { useLocation, useNavigate } from 'react-router-dom';
import DuplicateModal from "./DuplicateModal";
import { MdDelete, MdAdd } from "react-icons/md";

import { LuLoaderCircle } from "react-icons/lu"; 
import {
  FaFlagCheckered,
  FaCheck,
  FaTrash,
  FaPlus,
  FaWhatsapp,
  FaFilePdf,
} from "react-icons/fa";
import { motion } from "framer-motion";
import toast, { Toaster } from "react-hot-toast";
import { API_BASE_URL } from "../config";
import ContactModal from "./Contact";
import PDFDownloadModal from "./PdfModal";
const MyWork = () => {
  const [dateRange, setDateRange] = useState("1M");
  const [selectedWorkorderId, setSelectedWorkorderId] = useState(null);
  const navigate = useNavigate();
const [selectedWorkorderForPDF, setSelectedWorkorderForPDF] = useState(null);
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const [records, setRecords] = useState([]);
  const [itemOptions, setItemOptions] = useState([]); 
  const [isContactModalOpen, setIsContactModalOpen] = useState(false);
  const [expandedRows, setExpandedRows] = useState({});
  const [subRecords, setSubRecords] = useState({});
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [isLoading, setIsLoading] = useState(false);
const [ssrOptions, setSSROptions] = useState([]);
// Add this with your other useState declarations
const [workOrdersWithPDF, setWorkOrdersWithPDF] = useState({});
const [workOrderInfo, setWorkOrderInfo] = useState({
  workOrderId: '',
  nameOfWork: '',
  ssr: '',
  ssrName: '',
  area: '',
  status: '',
  autogenerated: '',
  state: '',
  department: '',
  chapterId: '',
  preparedBySignature: '',
  checkedBySignature: '',
  createdDate: '',
  createdBy: '',
  deletedFlag: 0,
  multifloor: 0,
  fkSsrId: 0,
  reviseId: '',
  reviseno: '',
  revisionStage: ''
});
const jwtToken = localStorage.getItem('authToken') || localStorage.getItem('jwt'); 

  const location = useLocation();
  // Add missing loadFromLocalStorage function
  const loadFromLocalStorage = (key, defaultValue = null) => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error(`Error loading ${key} from localStorage:`, error);
      return defaultValue;
    }
  };

  // Add saveToLocalStorage function for completeness
  const saveToLocalStorage = (key, value) => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Error saving ${key} to localStorage:`, error);
    }
  };

  const handleVisibilityChange = () => {
    if (!document.hidden) {
      // Page became visible, check for updates
      const updated = localStorage.getItem("estimateUpdated");
      if (updated === "true") {
        localStorage.removeItem("estimateUpdated");
        fetchData();
      }
    }
  };

  useEffect(() => {
    // Check authentication status on component mount
    if (!checkAuthAndRedirect()) {
      return; // Don't continue if not authenticated
    }

    // Log current auth status for debugging
    const { token, uid } = getUserData();
    console.log("Auth Status:", {
      hasToken: !!token,
      hasUid: !!uid,
      token: token ? `${token.substring(0, 10)}...` : "None",
      uid: uid,
    });
    // Ensure token consistency across all storage keys
    ensureTokenConsistency(); // ADD THIS LINE

    // Add visibility change listener
    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Cleanup
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, []);
useEffect(() => {

  const urlParams = new URLSearchParams(location.search);
  const searchParam = urlParams.get('search');
  
  if (searchParam) {
    setSearchTerm(searchParam);
    // Clear the URL parameter after setting search term to keep URL clean
    window.history.replaceState({}, '', '/mywork');
  }
}, []);
useEffect(() => {
  const urlParams = new URLSearchParams(location.search);
  const searchParam = urlParams.get('search');
  
  if (searchParam) {
    // Set the search term to filter the table
    setSearchTerm(searchParam);
    
    // Optional: Clear the URL parameter after setting search
    const newUrl = window.location.pathname;
    window.history.replaceState({}, document.title, newUrl);
  }
}, [location.search]);
  useEffect(() => {
    const { token, uid } = getUserData();

    if (token && uid) {
      fetchData();
    } else if (!checkAuthAndRedirect()) {
      return;
    }

    const updated = localStorage.getItem("estimateUpdated");
    if (updated === "true") {
      localStorage.removeItem("estimateUpdated");
      fetchData();
    }
  }, []);

  const getUserData = () => {
    try {
      // Try to get the complete user object first
      const storedUser = localStorage.getItem("user");
      if (storedUser) {
        const userData = JSON.parse(storedUser);
        const token = userData.jwt || userData.token || userData.authToken;
        const uid = userData.id?.toString() || userData.uid?.toString();

        // IMPORTANT: Store authToken for SubEstimate compatibility
        if (token && !localStorage.getItem("authToken")) {
          localStorage.setItem("authToken", token);
        }

        return { token, uid };
      }

      // Fallback to individual items - ENHANCED
      const token =
        localStorage.getItem("jwt") ||
        localStorage.getItem("authToken") ||
        localStorage.getItem("userToken") ||
        localStorage.getItem("token");

      const uid =
        localStorage.getItem("Id") ||
        localStorage.getItem("id") ||
        localStorage.getItem("uid");

      // IMPORTANT: Ensure authToken is always available for SubEstimate
      if (token && !localStorage.getItem("authToken")) {
        localStorage.setItem("authToken", token);
      }

      return {
        token: token,
        uid: uid?.toString(),
      };
    } catch (error) {
      console.error("Error getting user data:", error);

      // Last resort fallback
      const fallbackToken =
        localStorage.getItem("authToken") ||
        localStorage.getItem("jwt") ||
        localStorage.getItem("userToken");
      const fallbackUid =
        localStorage.getItem("Id") || localStorage.getItem("id");

      return {
        token: fallbackToken,
        uid: fallbackUid,
      };
    }
  };

  // Add this function to check if user is properly authenticated
  const checkAuthAndRedirect = () => {
    const { token, uid } = getUserData();

    if (!token || !uid) {
      toast.error("Authentication required. Please login again.");
      // Clear any incomplete auth data
      localStorage.clear();
      // Redirect to login
      navigate("/signin");
      return false;
    }

    return true;
  };

  const { token, uid } = getUserData();

  useEffect(() => {
    applyDateRange();
  }, [dateRange]);
useEffect(() => {
  const fetchSSROptions = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/ssr`, {
        method: 'GET',
        headers: {
          'Accept': '*/*',
          'Authorization': `Bearer ${token}` // Changed from jwtToken to token
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      console.log('SSR Options fetched:', data);
      setSSROptions(data); // Store the complete SSR data
    } catch (err) {
      console.error('Error fetching SSR options:', err);
      setSSROptions([]); // Set empty array on error
    }
  };

  if (token) { // Changed from jwtToken to token
    fetchSSROptions();
  }
}, [token]); // Changed dependency from jwtToken to token

// Helper function to get SSR name by ID
const getSSRNameById = (ssrId) => {
  console.log('getSSRNameById called with:', ssrId);
  console.log('ssrOptions:', ssrOptions);
  
  if (!ssrOptions || !Array.isArray(ssrOptions) || !ssrId) {
    console.log('Early return - missing data');
    return '';
  }
  
  const ssrOption = ssrOptions.find(option => {
    console.log('Comparing:', option.ssrId, 'with', parseInt(ssrId));
    return option.ssrId === parseInt(ssrId);
  });
  
  console.log('Found SSR option:', ssrOption);
  return ssrOption ? ssrOption.ssrName : '';
};

// Load work order information from localStorage on component mount
useEffect(() => {
  const workOrderId = localStorage.getItem('workorderId');
  const reviseId = localStorage.getItem('reviseId');
       
  // First load the basic information from localStorage
  // Update the initial state to include fkSsrId
  const initialWorkOrderInfo = {
    workOrderId: workOrderId || '',
    nameOfWork: localStorage.getItem('nameOfWork') || '',
    ssr: localStorage.getItem('ssr') || '',
    ssrName: localStorage.getItem('ssrName') || '',
    area: localStorage.getItem('area') || '',
    status: localStorage.getItem('status') || '',
    revisionStage: localStorage.getItem('revisionStage') || '',
    reviseId: reviseId || '',
    reviseno: localStorage.getItem('reviseno') || '',
    autogenerated: localStorage.getItem('autogenerated') || '',
    
    // Additional complete information
    state: localStorage.getItem('state') || '',
    department: localStorage.getItem('department') || '',
    chapterId: localStorage.getItem('chapterId') || '',
    preparedBySignature: localStorage.getItem('preparedBySignature') || '',
    checkedBySignature: localStorage.getItem('checkedBySignature') || '',
    createdDate: localStorage.getItem('createdDate') || '',
    createdBy: localStorage.getItem('createdBy') || '',
    multifloor: localStorage.getItem('multifloor') || '0',
    fkSsrId: localStorage.getItem('fkSsrId') || '0'
  };
                   
  // Update state with localStorage values first
  setWorkOrderInfo(initialWorkOrderInfo);
    
  const fetchWorkOrderDetails = async () => {
    if (!workOrderId) {
      toast.error('No work order ID found');
      return;
    }
    setIsLoading(true);
    try {
      const response = await fetch(`${API_BASE_URL}/api/workorders/${workOrderId}`, {
        headers: {
          "Authorization": `Bearer ${token}`, // Changed from jwtToken to token
          "Accept": "*/*"
        }
      });
           
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
           
      const data = await response.json();
      console.log('Work order data fetched:', data);
      const ssrName = getSSRNameById(data.ssr);
      console.log('SSR Name resolved:', ssrName);    
      
      // Set fkSsrId based on multifloor value
      const fkSsrIdValue = data.multifloor === 1 ? (data.fkSsrId || 1) : 0;
           
      // Update state with complete fresh data from API
      setWorkOrderInfo(prevInfo => ({
        ...prevInfo,
        // Basic work order information
        nameOfWork: data.nameOfWork || prevInfo.nameOfWork,
        ssr: data.ssr || prevInfo.ssr,
        ssrName: ssrName,
        area: data.area || prevInfo.area,
        status: data.status || prevInfo.status,
        autogenerated: data.workOrderID || prevInfo.autogenerated,
        
        // Additional complete information from API
        state: data.state || prevInfo.state,
        department: data.department || prevInfo.department,
        chapterId: data.chapterId || prevInfo.chapterId,
        preparedBySignature: data.preparedBySignature || prevInfo.preparedBySignature,
        checkedBySignature: data.checkedBySignature || prevInfo.checkedBySignature,
        createdDate: data.createdDate || prevInfo.createdDate,
        createdBy: data.createdBy || prevInfo.createdBy,
        deletedFlag: data.deletedFlag || prevInfo.deletedFlag,
        multifloor: data.multifloor || prevInfo.multifloor,
        fkSsrId: fkSsrIdValue,
        
        // Keep existing revision info from localStorage
        reviseId: prevInfo.reviseId,
        reviseno: prevInfo.reviseno,
        revisionStage: prevInfo.revisionStage
      }));
           
      // Update localStorage with complete fresh data
      localStorage.setItem('nameOfWork', data.nameOfWork || '');
      localStorage.setItem('ssr', data.ssr || '');
      localStorage.setItem('ssrName', ssrName);
      localStorage.setItem('area', data.area || '');
      localStorage.setItem('status', data.status || '');
      localStorage.setItem('autogenerated', data.workOrderID || '');
      
      // Store additional complete information in localStorage
      localStorage.setItem('state', data.state || '');
      localStorage.setItem('department', data.department || '');
      localStorage.setItem('chapterId', data.chapterId?.toString() || '');
      localStorage.setItem('preparedBySignature', data.preparedBySignature || '');
      localStorage.setItem('checkedBySignature', data.checkedBySignature || '');
      localStorage.setItem('createdDate', data.createdDate || '');
      localStorage.setItem('createdBy', data.createdBy?.toString() || '');
      localStorage.setItem('multifloor', data.multifloor?.toString() || '0');
      localStorage.setItem('fkSsrId', fkSsrIdValue.toString());
      
    } catch (error) {
      console.error("Error fetching work order details:", error);
      toast.error(`Failed to fetch work order details: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  // Fetch work order details regardless of SSR options
  // SSR name will be resolved when SSR options are available
  if (workOrderId && token) {
    fetchWorkOrderDetails();
  }
}, [token]); // Removed ssrOptions dependency to avoid dependency loop

// Separate useEffect to update SSR name when ssrOptions are loaded
useEffect(() => {
  if (ssrOptions.length > 0 && workOrderInfo.ssr && !workOrderInfo.ssrName) {
    const ssrName = getSSRNameById(workOrderInfo.ssr);
    if (ssrName) {
      setWorkOrderInfo(prevInfo => ({
        ...prevInfo,
        ssrName: ssrName
      }));
      localStorage.setItem('ssrName', ssrName);
    }
  }
}, [ssrOptions, workOrderInfo.ssr, workOrderInfo.ssrName]);
// Add this useEffect after your existing useEffects
useEffect(() => {
  const loadPDFStatus = async () => {
    const currentPageRecords = paginatedRecords();
    const promises = currentPageRecords.map(record => 
      checkForCompletedRevisions(record.id)
    );
    
    await Promise.all(promises);
  };

  if (!isLoading && records.length > 0) {
    loadPDFStatus();
  }
}, [records, currentPage, rowsPerPage, isLoading]);
  const fetchData = async () => {
    if (!token || !uid) {
      toast.error("Authentication required");
      return;
    }

    setIsLoading(true);

    try {
      const response = await fetch(
        `${API_BASE_URL}/api/workorders/ByUser/${uid}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        if (response.status === 401) {
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return;
        }
        const errorText = await response.text();
        throw new Error(`Server error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();

      if (!Array.isArray(data)) {
        throw new Error("Expected array but received: " + JSON.stringify(data));
      }

      // Filter and sort by createdDate (newest first)
      const sorted = data
        .filter((item) => item.deletedFlag === 0)
        .sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));

      // Add an absoluteIndex property to each record (descending order)
      const indexedRecords = sorted.map((record, index) => ({
        ...record,
        absoluteIndex: sorted.length - index,
      }));

      // Pre-load status for all work orders
      const recordsWithStatus = await Promise.all(
        indexedRecords.map(async (record) => {
          const status = await getWorkOrderStatusQuick(record.id);
          return {
            ...record,
            workOrderStatus: status,
          };
        })
      );

      setRecords(recordsWithStatus);
    } catch (err) {
      console.error("fetchData failed:", err.message);
      toast.error("Failed to load work orders");
    } finally {
      setIsLoading(false);
    }
  };
  const getWorkOrderStatusQuick = async (workorderId) => {
    if (!token) return "started";

    try {
      const response = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${workorderId}`,
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );

      if (!response.ok) return "started";

      const revisions = await response.json();
      const filtered = (revisions || []).filter(
        (r) =>
          r.deletedFlag !== undefined &&
          String(r.deletedFlag).toLowerCase() !== "yes" &&
          !isNaN(parseFloat(r.reviseNumber))
      );

      // Quick status logic
      if (filtered.length === 0) return "started";

      const allCompleted = filtered.every((revision) => revision.pdfLocation);
      if (allCompleted) return "completed";

      const anyInProgress = filtered.some(
        (revision) =>
          !revision.pdfLocation &&
          (revision.revisionStage === "in-progress" ||
            revision.revisionStage === "started")
      );
      if (anyInProgress) return "in-progress";

      return "started";
    } catch (err) {
      return "started";
    }
  };

  // Handle Add New button click
  const handleAddNew = () => {
    // Clear specific edit mode data but preserve template data
    localStorage.removeItem("editMode");
    localStorage.removeItem("recordId");
    localStorage.removeItem("reviseId");
    localStorage.removeItem("duplicateRevision");
    localStorage.removeItem("revisionToCopyId");

    // Get template data from localStorage (all fields except name of work and chapter)
    const templateData = {
      // Customer/Client Information
      customerName: localStorage.getItem("template_customerName") || "",
      customerAddress: localStorage.getItem("template_customerAddress") || "",
      customerPhone: localStorage.getItem("template_customerPhone") || "",
      customerEmail: localStorage.getItem("template_customerEmail") || "",

      // Project Information
      projectLocation: localStorage.getItem("template_projectLocation") || "",
      projectType: localStorage.getItem("template_projectType") || "",
      estimateDate:
        localStorage.getItem("template_estimateDate") ||
        new Date().toISOString().split("T")[0],
      validUntil: localStorage.getItem("template_validUntil") || "",

      // Financial Information
      laborRate: localStorage.getItem("template_laborRate") || "",
      materialMarkup: localStorage.getItem("template_materialMarkup") || "",
      taxRate: localStorage.getItem("template_taxRate") || "",

      // Terms and Conditions
      paymentTerms: localStorage.getItem("template_paymentTerms") || "",
      warrantyInfo: localStorage.getItem("template_warrantyInfo") || "",
      additionalNotes: localStorage.getItem("template_additionalNotes") || "",

      // Company Information
      companyName: localStorage.getItem("template_companyName") || "",
      companyAddress: localStorage.getItem("template_companyAddress") || "",
      companyPhone: localStorage.getItem("template_companyPhone") || "",
      companyEmail: localStorage.getItem("template_companyEmail") || "",
      companyLicense: localStorage.getItem("template_companyLicense") || "",

      // Exclude these fields - they should be empty for new estimates
      workName: "", // This should be empty
      chapter: "", // This should be empty

      // Set template mode flag
      isTemplate: true,
    };

    // Store the template data for the new estimate
    localStorage.setItem("newEstimateTemplate", JSON.stringify(templateData));

    navigate("/estimate");
  };

  // Handle WhatsApp button click
  const handleWhatsApp = () => {
    setIsContactModalOpen(true);
  };

  // Handle modal close
  const handleCloseModal = () => {
    setIsContactModalOpen(false);
  };

  const fetchSubRecords = async (workorderId) => {
    if (!token) {
      toast.error("Authentication required");
      return;
    }

    try {
      const response = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${workorderId}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        if (response.status === 401) {
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return;
        }
        throw new Error(`Server error: ${response.status}`);
      }

      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Expected array in subRecords");
      }

      const filtered = data.filter(
        (rec) => rec.deletedFlag.toLowerCase() === "no"
      );
      setSubRecords((prev) => ({ ...prev, [workorderId]: filtered }));
    } catch (err) {
      console.error(err);
      toast.error("Failed to load revisions");
    }
  };

  const applyDateRange = () => {
    const today = new Date();
    let start = new Date();
    if (dateRange === "1M") start.setMonth(today.getMonth() - 1);
    else if (dateRange === "3M") start.setMonth(today.getMonth() - 3);
    else if (dateRange === "1Y") start.setFullYear(today.getFullYear() - 1);
    setStartDate(start.toISOString().split("T")[0]);
    setEndDate(today.toISOString().split("T")[0]);
  };

  const toggleRow = async (id) => {
    if (!token) {
      toast.error("Authentication required");
      return;
    }

    setExpandedRows((prev) => {
      // Toggle the current row only
      const expanded = { ...prev, [id]: !prev[id] };
      return expanded;
    });

    // If expanding (true), always fetch the latest revisions from API
    if (!expandedRows[id]) {
      setSubRecords((prev) => ({ ...prev, [id]: undefined })); // Clear old data while loading
      try {
        const response = await fetch(
          `${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${id}`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );
        if (!response.ok) {
          if (response.status === 401) {
            toast.error("Session expired. Please login again.");
            localStorage.clear();
            navigate("/signin");
            return;
          }
          throw new Error(`Error fetching revisions for workorder ${id}`);
        }
        const data = await response.json();
        // Only include revisions where deletedFlag === 'no'
        const filtered = (data || []).filter(
          (rec) => String(rec.deletedFlag).toLowerCase() === "no"
        );
        setSubRecords((prev) => ({ ...prev, [id]: filtered }));
      } catch (err) {
        setSubRecords((prev) => ({ ...prev, [id]: [] }));
        toast.error("Failed to load revisions");
      }
    }
  };

const handleDelete = async (id, event) => {
  // Prevent row click when clicking delete button
  event.stopPropagation();

  if (!token) {
    toast.error("Authentication required. Please login again.");
    return;
  }

  // Show confirmation dialog
  const confirmed = window.confirm(
    "Are you sure you want to delete this work order? This action cannot be undone."
  );
  if (!confirmed) return;

  const loadingToast = toast.loading(
    <div className="flex items-center">
      <LuLoaderCircle className="w-4 h-4 text-orange-500 animate-spin mr-2" />
      Deleting work order...
    </div>
  );

  try {
    // First, fetch the complete workorder object
    const getResponse = await fetch(`${API_BASE_URL}/api/workorders/${id}`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
    });

    if (!getResponse.ok) {
      if (getResponse.status === 401) {
        toast.dismiss(loadingToast);
        toast.error("Session expired. Please login again.");
        localStorage.clear();
        navigate("/signin");
        return;
      }
      if (getResponse.status === 404) {
        toast.dismiss(loadingToast);
        toast.error("Work order not found.");
        return;
      }
      throw new Error(`Failed to fetch workorder: ${getResponse.status}`);
    }

    const workorderData = await getResponse.json();

    // Update the workorder with deletedFlag: 1
    const updateResponse = await fetch(`${API_BASE_URL}/api/workorders/${id}`, {
      method: "PUT",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        ...workorderData,
        deletedFlag: 1
      }),
    });

    if (!updateResponse.ok) {
      if (updateResponse.status === 401) {
        toast.dismiss(loadingToast);
        toast.error("Session expired. Please login again.");
        localStorage.clear();
        navigate("/signin");
        return;
      }
      if (updateResponse.status === 404) {
        toast.dismiss(loadingToast);
        toast.error("Work order not found.");
        return;
      }
      if (updateResponse.status === 403) {
        toast.dismiss(loadingToast);
        toast.error("You do not have permission to delete this work order.");
        return;
      }
      throw new Error(`Server error: ${updateResponse.status}`);
    }

    toast.dismiss(loadingToast);
    toast.success("Work order deleted successfully!");

    // Refresh records after successful deletion
    await fetchData();
  } catch (err) {
    toast.dismiss(loadingToast);
    console.error("Delete error:", err);
    toast.error("Failed to delete work order. Please try again.");
  }
};
  // Add this function before your component's return statement
const checkForCompletedRevisions = async (recordId) => {
  if (workOrdersWithPDF[recordId] !== undefined) {
    return workOrdersWithPDF[recordId]; // Return cached result
  }

  try {
    const response = await fetch(`${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${recordId}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`
      }
    });

    if (response.ok) {
      const revisions = await response.json();
      const hasCompletedRevisions = Array.isArray(revisions) && 
        revisions.some(rev => 
          rev && 
          rev.deletedFlag && 
          rev.deletedFlag.toLowerCase() === "no" &&
          rev.pdfLocation
        );

      // Cache the result
      setWorkOrdersWithPDF(prev => ({
        ...prev,
        [recordId]: hasCompletedRevisions
      }));

      return hasCompletedRevisions;
    }
  } catch (error) {
    console.error("Error checking for completed revisions:", error);
  }

  return false;
};
  const handleDuplicate = async (
    workorderId,
    revisionToCopy,
    workorderRecord
  ) =>  {
  try {
    // Show loading toast
    const loadingToast = toast.loading("Duplicating workorder...", {
      // icon: <LuLoaderCircle className="w-4 h-4 text-orange-500 animate-spin" />
    });

    // Check authentication first
    if (!token) {
      toast.dismiss(loadingToast);
      toast.error("Authentication required. Please login again.");
      return;
    }

    // Fetch states from API instead of hardcoded array
    let states = [];
    try {
      const statesResponse = await fetch(`${API_BASE_URL}/api/master/state`, {
        method: 'GET',
        headers: {
          'Accept': '*/*',
          'Authorization': `Bearer ${token}`
        }
      });

      if (!statesResponse.ok) {
        throw new Error(`Failed to fetch states: ${statesResponse.status}`);
      }

      const statesData = await statesResponse.json();
      
      // Transform states data to match the expected format
      states = [
        { value: "", label: "Select State", tin: "" },
        ...statesData.map(item => ({
          value: item.state,
          label: item.state,
          tin: item.stateTin.toString(),
          id: item.id
        }))
      ];
    } catch (error) {
      console.error('Error fetching states:', error);
      toast.dismiss(loadingToast);
      toast.error('Failed to fetch states. Please try again.');
      return;
    }

    // Generate new work order ID using fetched states
    const newWorkOrderID = generateCustomWorkOrderID(
      workorderRecord.state,
      states
    );

 // 1. Create new workorder with duplicated data
    const originalName = workorderRecord.nameOfWork || "Untitled Work";
    const newWorkorderPayload = {
      workOrderID: newWorkOrderID,
      nameOfWork: ` ${originalName}`,
      state: workorderRecord.state || "",
      department: workorderRecord.department || "",
      ssr: workorderRecord.ssr || "",
      area: workorderRecord.area || "",
      preparedBySignature: workorderRecord.preparedBySignature || "",
      checkedBySignature: workorderRecord.checkedBySignature || "",
      chapterId: workorderRecord.chapterId || null,
      status: "started",
      createdBy: parseInt(uid) || 1,
      updatedBy: parseInt(uid) || 1,
      deletedFlag: 0,
      multifloor: workorderRecord.multifloor || 0,
      createdDate: new Date().toISOString(),
      updatedDate: new Date().toISOString(),
    };

    console.log("New workorder payload:", newWorkorderPayload);

    const newWorkorderResponse = await fetch(
      `${API_BASE_URL}/api/workorders`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(newWorkorderPayload),
      }
    );

    if (!newWorkorderResponse.ok) {
      const errorText = await newWorkorderResponse.text();
      console.error("Workorder creation error:", errorText);

      if (newWorkorderResponse.status === 401) {
        toast.dismiss(loadingToast);
        toast.error("Session expired. Please login again.");
        localStorage.clear();
        navigate("/signin");
        return;
      }
      throw new Error(
        `Failed to create new workorder: ${newWorkorderResponse.status} - ${errorText}`
      );
    }

    const newWorkorderData = await newWorkorderResponse.json();
    const newWorkorderId = newWorkorderData.id;
    console.log("New workorder created:", newWorkorderData);

      // 2. Create initial revision for the new workorder with revision number "1.0"
      const revisionPayload = {
        workorderId: parseInt(newWorkorderId),
        reviseNumber: "1.0", // Changed from "1" to "1.0"
        createdBy: parseInt(uid) || 1,
        updatedBy: parseInt(uid) || 1,
        currentFlag: true,
        deletedFlag: "no",
        pdfLocation: "",
        revisionStage: "in-progress",
        revisionStatus: "pending",
        createdDate: new Date().toISOString(),
        updatedDate: new Date().toISOString(),
      };

      const revisionResponse = await fetch(
        `${API_BASE_URL}/api/workorder-revisions`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(revisionPayload),
        }
      );

      if (!revisionResponse.ok) {
        const errorText = await revisionResponse.text();
        console.error("Revision creation error:", errorText);

        if (revisionResponse.status === 401) {
          toast.dismiss(loadingToast);
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return;
        }
        throw new Error(
          `Failed to create revision: ${revisionResponse.status} - ${errorText}`
        );
      }

      const newRevisionData = await revisionResponse.json();
      const newRevisionId = newRevisionData.id;
      console.log("New revision created:", newRevisionData);

      // 3. Clear localStorage to avoid conflicts
      const keysToRemove = [
        "recordId",
        "workorderId",
        "reviseId",
        "editMode",
        "reviseno",
        "revisionNumber",
        "currentRevisionNumber",
        "duplicateRevision",
        "edit_nameOfWork",
        "edit_state",
        "edit_department",
        "edit_ssr",
        "edit_area",
        "edit_preparedBy",
        "edit_checkedBy",
        "edit_chapter",
        "nameOfWork",
        "state",
        "department",
        "ssr",
        "area",
        "preparedBy",
        "checkedBy",
        "chapter",
        "autogenerated",
        "status",
        "revisionStage",
        "revisionStatus",
        "isEditMode",
        "editingRevision",
        "currentRevisionId",
        "originalRevisionData",
        "subworkData",
        "revisionItems",
        "revisionMeasurements",
        "revisionDataBySubwork",
        "totalSubworks",
        "totalItems",
        "totalMeasurements",
        "isDuplicatingRevision",
        "sourceSubworkData",
        "sourceRevisionItems",
        "sourceRevisionMeasurements",
        "sourceDataBySubwork",
        "needsDuplication",
        "chapterName",
        "chapterDetails",
        "estimateData",
        "estimateItems",
        "estimateMeasurements",
      ];

      keysToRemove.forEach((key) => {
        localStorage.removeItem(key);
      });

      // 4. Set localStorage data for the new workorder and revision
      localStorage.setItem("editMode", "true");
      localStorage.setItem("isEditMode", "true");
      localStorage.setItem("workorderId", newWorkorderId.toString());
      localStorage.setItem("recordId", newWorkorderId.toString());
      localStorage.setItem("reviseId", newRevisionId.toString());
      localStorage.setItem("reviseno", "1.0"); // Changed from "1" to "1.0"
      localStorage.setItem("revisionNumber", "1.0"); // Changed from "1" to "1.0"
      localStorage.setItem("currentRevisionNumber", "1.0"); // Changed from "1" to "1.0"
      localStorage.setItem("currentRevisionId", newRevisionId.toString());
      localStorage.setItem("duplicateRevision", "true");
      localStorage.setItem("isDuplicatingRevision", "true");

      // 5. Store workorder data (both with and without edit_ prefix)
      localStorage.setItem(
        "edit_nameOfWork",
        newWorkorderData.nameOfWork || ""
      );
      localStorage.setItem("edit_state", newWorkorderData.state || "");
      localStorage.setItem(
        "edit_department",
        newWorkorderData.department || ""
      );
      localStorage.setItem("edit_ssr", newWorkorderData.ssr || "");
      localStorage.setItem("edit_area", newWorkorderData.area || "");
      localStorage.setItem(
        "edit_preparedBy",
        newWorkorderData.preparedBySignature || ""
      );
      localStorage.setItem(
        "edit_checkedBy",
        newWorkorderData.checkedBySignature || ""
      );
      localStorage.setItem(
        "edit_chapter",
        newWorkorderData.chapterId?.toString() || ""
      );

      localStorage.setItem("nameOfWork", newWorkorderData.nameOfWork || "");
      localStorage.setItem("state", newWorkorderData.state || "");
      localStorage.setItem("department", newWorkorderData.department || "");
      localStorage.setItem("ssr", newWorkorderData.ssr || "");
      localStorage.setItem("area", newWorkorderData.area || "");
      localStorage.setItem(
        "preparedBy",
        newWorkorderData.preparedBySignature || ""
      );
      localStorage.setItem(
        "checkedBy",
        newWorkorderData.checkedBySignature || ""
      );
      localStorage.setItem(
        "chapter",
        newWorkorderData.chapterId?.toString() || ""
      );
      localStorage.setItem(
        "autogenerated",
        newWorkorderData.workOrderID || newWorkOrderID
      );
      localStorage.setItem("status", newWorkorderData.status || "draft");

      // 6. Store revision data
      localStorage.setItem("revisionStage", "in-progress");
      localStorage.setItem("revisionStatus", "pending");

      // 7. Store user data
      const userData = getUserData();
      const currentToken = token;

      if (!localStorage.getItem("userId"))
        localStorage.setItem("userId", userData?.uid || "");
      if (!localStorage.getItem("userToken"))
        localStorage.setItem("userToken", currentToken);
      if (!localStorage.getItem("jwt"))
        localStorage.setItem("jwt", currentToken);
      if (!localStorage.getItem("Id"))
        localStorage.setItem("Id", userData?.uid || "");
      if (!localStorage.getItem("authToken"))
        localStorage.setItem("authToken", currentToken);
      if (!localStorage.getItem("token"))
        localStorage.setItem("token", currentToken);

      // 8. Fetch and store chapter information if available
      if (workorderRecord.chapterId) {
        try {
          const chapterResponse = await fetch(
            `${API_BASE_URL}/api/chapters/${workorderRecord.chapterId}`,
            {
              method: "GET",
              headers: {
                Authorization: `Bearer ${currentToken}`,
                "Content-Type": "application/json",
              },
            }
          );

          if (chapterResponse.ok) {
            const chapterData = await chapterResponse.json();
            localStorage.setItem("chapterName", chapterData.chapterName || "");
            localStorage.setItem("chapterDetails", JSON.stringify(chapterData));
          }
        } catch (error) {
          console.error("Error fetching chapter data:", error);
        }
      }

      // 9. DUPLICATE THE REVISION DATA - IMPROVED VERSION
      if (revisionToCopy) {
        console.log(
          "Starting data duplication from revision:",
          revisionToCopy.id
        );

        // Store source revision reference
        localStorage.setItem("sourceRevisionId", revisionToCopy.id.toString());
        localStorage.setItem(
          "originalRevisionData",
          JSON.stringify({
            id: revisionToCopy.id,
            reviseNumber: revisionToCopy.reviseNumber,
            revisionStage: revisionToCopy.revisionStage || "started",
            revisionStatus: revisionToCopy.revisionStatus || "pending",
          })
        );

        try {
          // Fetch source subwork data using the original workorder ID
          const subworkResponse = await fetch(
            `${API_BASE_URL}/api/subwork/${revisionToCopy.id}/${workorderId}`,
            {
              method: "GET",
              headers: {
                Authorization: `Bearer ${currentToken}`,
                "Content-Type": "application/json",
              },
            }
          );

          if (!subworkResponse.ok) {
            if (subworkResponse.status === 401) {
              toast.dismiss(loadingToast);
              toast.error("Session expired. Please login again.");
              localStorage.clear();
              navigate("/signin");
              return;
            }
            throw new Error(
              `Failed to fetch source subwork data: ${subworkResponse.status}`
            );
          }

          const sourceSubworkData = await subworkResponse.json();
          console.log("Source subwork data:", sourceSubworkData);

          if (sourceSubworkData.length === 0) {
            console.log("No subwork data found in source revision");
            toast.dismiss(loadingToast);
            toast.success(
              `New workorder created successfully! No data to duplicate from source revision.`
            );
            navigate("/estimate");
            return;
          }

          // Initialize arrays to store all source data
          const allSourceItems = [];
          const allSourceMeasurements = [];

          // Update toast to show fetching progress
          toast.dismiss(loadingToast);
          const fetchingToast = toast.loading(
            "Fetching source revision data..."
          );

          // For each subwork in source revision, fetch its items and measurements
          for (const subwork of sourceSubworkData) {
            try {
              // Fetch items for this subwork from source revision
              const itemsResponse = await fetch(
                `${API_BASE_URL}/api/txn-items/BySubwork/${subwork.id}`,
                {
                  method: "GET",
                  headers: {
                    Authorization: `Bearer ${currentToken}`,
                    "Content-Type": "application/json",
                  },
                }
              );

              if (itemsResponse.ok) {
                const itemsData = await itemsResponse.json();
                console.log(
                  `Source items for subwork ${subwork.id}:`,
                  itemsData
                );

                // Add subwork reference to each item and prepare for duplication
                const itemsWithSubwork = itemsData.map((item) => ({
                  ...item,
                  originalId: item.id,
                  id: null,
                  subworkId: null,
                  originalSubworkId: subwork.id,
                  subworkName: subwork.subworkName,
                  revisionId: newRevisionId,
                  createdDate: new Date().toISOString(),
                  updatedDate: new Date().toISOString(),
                  createdBy: parseInt(uid),
                  updatedBy: parseInt(uid),
                }));

                allSourceItems.push(...itemsWithSubwork);

                // For each item, fetch its measurements using the correct API endpoint
                for (const item of itemsData) {
                  try {
                    // FIXED: Use the correct API endpoint and field names
                    const measurementsResponse = await fetch(
                      `${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`,
                      {
                        method: "GET",
                        headers: {
                          Authorization: `Bearer ${currentToken}`,
                          "Content-Type": "application/json",
                        },
                      }
                    );

                    if (measurementsResponse.ok) {
                      const measurementsData =
                        await measurementsResponse.json();
                      console.log(
                        `Source measurements for item ${item.id}:`,
                        measurementsData
                      );

                      // FIXED: Map the measurement fields correctly according to API schema
                      const measurementsWithRef = measurementsData.map(
                        (measurement) => ({
                          ...measurement,
                          originalId: measurement.id,
                          id: null,
                          itemId: null,
                          originalItemId: item.id,
                          itemNo: item.itemNo,
                          subworkId: null,
                          originalSubworkId: subwork.id,
                          subworkName: subwork.subworkName,
                          // Map API fields to your internal structure
                          sNo: measurement.srNo || measurement.sNo,
                          description: measurement.description,
                          nos: measurement.number || measurement.nos,
                          length: measurement.length,
                          breadth: measurement.width || measurement.breadth,
                          height: measurement.height,
                          quantity: measurement.quantity,
                          unit: measurement.unit,
                          multiplyNumber: measurement.multiplyNumber,
                          floorLiftRise: measurement.floorLiftRise,
                          refTxnItemId: measurement.refTxnItemId,
                          refTxnItemPercentage:
                            measurement.refTxnItemPercentage,
                          createdDate: new Date().toISOString(),
                          updatedDate: new Date().toISOString(),
                          createdBy: parseInt(uid),
                          updatedBy: parseInt(uid),
                        })
                      );

                      allSourceMeasurements.push(...measurementsWithRef);
                    } else if (measurementsResponse.status === 401) {
                      toast.dismiss(fetchingToast);
                      toast.error("Session expired. Please login again.");
                      localStorage.clear();
                      navigate("/signin");
                      return;
                    } else {
                      console.warn(
                        `Failed to fetch measurements for item ${item.id}:`,
                        measurementsResponse.status
                      );
                    }
                  } catch (error) {
                    console.error(
                      `Error fetching measurements for item ${item.id}:`,
                      error
                    );
                  }
                }
              } else if (itemsResponse.status === 401) {
                toast.dismiss(fetchingToast);
                toast.error("Session expired. Please login again.");
                localStorage.clear();
                navigate("/signin");
                return;
              } else {
                console.warn(
                  `Failed to fetch items for subwork ${subwork.id}:`,
                  itemsResponse.status
                );
              }
            } catch (error) {
              console.error(
                `Error fetching items for subwork ${subwork.id}:`,
                error
              );
            }
          }

          // NOW DUPLICATE ALL DATA TO NEW REVISION
          console.log("Starting duplication process...");
          toast.dismiss(fetchingToast);
          const duplicatingToast = toast.loading("Duplicating subwork data...");

          // Track created records for mapping relationships
          const subworkMapping = {};
          const itemMapping = {};

          const duplicatedSubworks = [];
          const duplicatedItems = [];
          const duplicatedMeasurements = [];

          // Step 1: Create duplicate subworks
          for (const sourceSubwork of sourceSubworkData) {
            try {
              const newSubworkPayload = {
                id: 0,
                reviseId: newRevisionId,
                workorderId: parseInt(newWorkorderId), // Use new workorder ID
                subworkName: sourceSubwork.subworkName,
                createdDate: new Date().toISOString(),
                createdBy: parseInt(uid),
                updatedDate: new Date().toISOString(),
                updatedBy: parseInt(uid),
              };

              const createSubworkResponse = await fetch(
                `${API_BASE_URL}/api/subwork`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${currentToken}`,
                  },
                  body: JSON.stringify(newSubworkPayload),
                }
              );

              if (!createSubworkResponse.ok) {
                if (createSubworkResponse.status === 401) {
                  toast.dismiss(duplicatingToast);
                  toast.error("Session expired. Please login again.");
                  localStorage.clear();
                  navigate("/signin");
                  return;
                }
                throw new Error(
                  `Failed to create subwork: ${createSubworkResponse.status}`
                );
              }

              const newSubworkData = await createSubworkResponse.json();
              subworkMapping[sourceSubwork.id] = newSubworkData.id;
              duplicatedSubworks.push(newSubworkData);
              console.log(
                `Created subwork: ${sourceSubwork.subworkName} (ID: ${newSubworkData.id})`
              );
            } catch (error) {
              console.error(
                `Error creating subwork ${sourceSubwork.subworkName}:`,
                error
              );
              toast.dismiss(duplicatingToast);
              toast.error(
                `Failed to duplicate subwork: ${sourceSubwork.subworkName}`
              );
              return;
            }
          }

          // Step 2: Create duplicate items
          toast.dismiss(duplicatingToast);
          const itemsToast = toast.loading("Duplicating items data...");

          for (const sourceItem of allSourceItems) {
            try {
              const newSubworkId = subworkMapping[sourceItem.originalSubworkId];
              if (!newSubworkId) {
                console.warn(
                  `No mapping found for subwork ID ${sourceItem.originalSubworkId}`
                );
                continue;
              }

              // Use the correct field names based on your API structure
              const newItemPayload = {
                id: 0,
                srNo: sourceItem.srNo || 0,
                itemNo: sourceItem.itemNo || "",
                category: sourceItem.category || "",
                descriptionOfItem:
                  sourceItem.description || sourceItem.descriptionOfItem || "",
                floorLiftRise: sourceItem.floorLiftRise || "",
                fkSubworkId: newSubworkId,
                fkWorkorderId: parseInt(newWorkorderId),
                completedRate: sourceItem.completedRate || sourceItem.rate || 0,
                labourRate: sourceItem.labourRate || 0,
                scadaFlag: sourceItem.scadaFlag || false,
                smallUnit: sourceItem.smallUnit || sourceItem.unit || "",
                fullUnit: sourceItem.fullUnit || sourceItem.unit || "",
                additionalSpecification:
                  sourceItem.additionalSpecification || "",
              };

              console.log("Creating item with payload:", newItemPayload);

              const createItemResponse = await fetch(
                `${API_BASE_URL}/api/txn-items`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${currentToken}`,
                  },
                  body: JSON.stringify(newItemPayload),
                }
              );

              if (!createItemResponse.ok) {
                if (createItemResponse.status === 401) {
                  toast.dismiss(itemsToast);
                  toast.error("Session expired. Please login again.");
                  localStorage.clear();
                  navigate("/signin");
                  return;
                }

                const errorText = await createItemResponse.text();
                console.error(`Failed to create item ${sourceItem.itemNo}:`, {
                  status: createItemResponse.status,
                  error: errorText,
                  payload: newItemPayload,
                });

                throw new Error(
                  `Failed to create item: ${createItemResponse.status} - ${errorText}`
                );
              }

              const newItemData = await createItemResponse.json();
              itemMapping[sourceItem.originalId] = newItemData.id;
              duplicatedItems.push(newItemData);
              console.log(
                `Created item: ${sourceItem.itemNo} (ID: ${newItemData.id})`
              );
            } catch (error) {
              console.error(`Error creating item ${sourceItem.itemNo}:`, error);
              toast.dismiss(itemsToast);
              toast.error(
                `Failed to duplicate item: ${sourceItem.itemNo} - ${error.message}`
              );
              return;
            }
          }

          // Step 3: Create duplicate measurements
          toast.dismiss(itemsToast);
          const measurementsToast = toast.loading(
            "Duplicating measurements data..."
          );

          for (const sourceMeasurement of allSourceMeasurements) {
            try {
              const newItemId = itemMapping[sourceMeasurement.originalItemId];
              if (!newItemId) {
                console.warn(
                  `No mapping found for item ID ${sourceMeasurement.originalItemId}`
                );
                continue;
              }

              // FIXED: Use the correct field names from the API schema
              const newMeasurementPayload = {
                srNo: sourceMeasurement.sNo || sourceMeasurement.srNo || 0,
                description: sourceMeasurement.description || "",
                quantity: sourceMeasurement.quantity || 0,
                number: sourceMeasurement.nos || sourceMeasurement.number || 0,
                length: sourceMeasurement.length || 0,
                width:
                  sourceMeasurement.breadth || sourceMeasurement.width || 0,
                height: sourceMeasurement.height || 0,
                unit: sourceMeasurement.unit || "",
                fkTxnItemId: newItemId,
                multiplyNumber: sourceMeasurement.multiplyNumber || 0,
                floorLiftRise: sourceMeasurement.floorLiftRise || "",
                refTxnItemId: sourceMeasurement.refTxnItemId || 0,
                refTxnItemPercentage:
                  sourceMeasurement.refTxnItemPercentage || 0,
              };

              console.log(
                "Creating measurement with payload:",
                newMeasurementPayload
              );

              const createMeasurementResponse = await fetch(
                `${API_BASE_URL}/api/txn-items-mts`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${currentToken}`,
                  },
                  body: JSON.stringify(newMeasurementPayload),
                }
              );

              if (!createMeasurementResponse.ok) {
                if (createMeasurementResponse.status === 401) {
                  toast.dismiss(measurementsToast);
                  toast.error("Session expired. Please login again.");
                  localStorage.clear();
                  navigate("/signin");
                  return;
                }

                const errorText = await createMeasurementResponse.text();
                console.error(`Failed to create measurement:`, {
                  status: createMeasurementResponse.status,
                  error: errorText,
                  payload: newMeasurementPayload,
                });

                console.warn(
                  `Failed to create measurement: ${createMeasurementResponse.status} - ${errorText}`
                );
                continue;
              }

              const newMeasurementData = await createMeasurementResponse.json();
              duplicatedMeasurements.push(newMeasurementData);
              console.log(
                `Created measurement: S.No ${sourceMeasurement.sNo} (ID: ${newMeasurementData.id})`
              );
            } catch (error) {
              console.error(
                `Error creating measurement ${sourceMeasurement.sNo}:`,
                error
              );
              continue;
            }
          }  toast.dismiss(measurementsToast);
          // const leadToast = toast.loading("Duplicating lead charges data...");

          let successfulLeadCharges = 0;
          let failedLeadCharges = 0;
          let allSourceLeadCharges = [];

          try {
            // Fetch lead charges from source revision
            const leadChargesResponse = await fetch(
              `${API_BASE_URL}/api/txn-leads/${workorderId}/${revisionToCopy.id}`,
              {
                method: "GET",
                headers: {
                  Authorization: `Bearer ${currentToken}`,
                  "Content-Type": "application/json",
                },
              }
            );

            if (leadChargesResponse.ok) {
              allSourceLeadCharges = await leadChargesResponse.json();
              console.log(`Found ${allSourceLeadCharges.length} lead charges to duplicate`);

              // Create duplicate lead charges for new revision
              for (const sourceLeadCharge of allSourceLeadCharges) {
                try {
                  const newLeadChargePayload = {
                    srNo: sourceLeadCharge.srNo || 0,
                    materialName: sourceLeadCharge.materialName || "",
                    location: sourceLeadCharge.location || "",
                    leadInKm: parseFloat(sourceLeadCharge.leadInKm) || 0,
                    leadCharges: parseFloat(sourceLeadCharge.leadCharges) || 0,
                    ssrRate: parseFloat(sourceLeadCharge.ssrRate) || 0,
                    currentRate: parseFloat(sourceLeadCharge.currentRate) || 0,
                    diffInRate: parseFloat(sourceLeadCharge.diffInRate) || 0,
                    unit: sourceLeadCharge.unit || "Per Cu.M.",
                    remark: sourceLeadCharge.remark || null,
                    fkWorkorderId: parseInt(newWorkorderId),
                    fkReviseId: newRevisionId // Use new revision ID
                  };

                  // Validate required fields
                  if (!newLeadChargePayload.materialName || !newLeadChargePayload.location) {
                    console.warn(`Skipping lead charge with missing required fields: ${JSON.stringify(newLeadChargePayload)}`);
                    failedLeadCharges++;
                    continue;
                  }

                  console.log("Creating lead charge with payload:", newLeadChargePayload);

                  const createLeadChargeResponse = await fetch(
                    `${API_BASE_URL}/api/txn-leads`,
                    {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${currentToken}`,
                      },
                      body: JSON.stringify(newLeadChargePayload),
                    }
                  );

                  if (!createLeadChargeResponse.ok) {
                    if (createLeadChargeResponse.status === 401) {
                      // toast.dismiss(leadToast);
                      toast.error("Session expired. Please login again.");
                      localStorage.clear();
                      navigate("/signin");
                      return;
                    }

                    const errorText = await createLeadChargeResponse.text();
                    console.error(`Failed to create lead charge for ${sourceLeadCharge.materialName}:`, {
                      status: createLeadChargeResponse.status,
                      error: errorText,
                      payload: newLeadChargePayload,
                    });

                    failedLeadCharges++;
                    continue;
                  }

                  const newLeadChargeData = await createLeadChargeResponse.json();
                  console.log(` Created lead charge: ${sourceLeadCharge.materialName} (ID: ${newLeadChargeData.id})`);
                  successfulLeadCharges++;

                } catch (error) {
                  console.error(`Error creating lead charge ${sourceLeadCharge.materialName}:`, error);
                  failedLeadCharges++;
                  continue;
                }
              }
            } else if (leadChargesResponse.status === 401) {
              // toast.dismiss(leadToast);
              toast.error("Session expired. Please login again.");
              localStorage.clear();
              navigate("/signin");
              return;
            } else if (leadChargesResponse.status === 404) {
              console.log("No lead charges found for source revision - this is normal");
            } else {
              console.warn(`Failed to fetch lead charges: ${leadChargesResponse.status}`);
            }

          } catch (error) {
            console.error("Error fetching/duplicating lead charges:", error);
            failedLeadCharges++;
          }
// Step 4: Duplicate transaction item properties (materials)
toast.dismiss(measurementsToast);
const propertiesSuccessToast = toast.loading("Duplicating material properties...");

let successfulProperties = 0;
let failedProperties = 0;

for (const sourceItem of allSourceItems) {
  try {
    const newItemId = itemMapping[sourceItem.originalId];
    if (!newItemId) {
      console.warn(`No mapping found for item ID ${sourceItem.originalId}`);
      continue;
    }

    // Fetch existing properties for the source item
    const propertiesResponse = await fetch(
      `${API_BASE_URL}/api/txn-item-properties/serchByTxnItemId/${sourceItem.originalId}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${currentToken}`,
          "Content-Type": "application/json",
        },
      }
    );

    if (propertiesResponse.ok) {
      const sourceProperties = await propertiesResponse.json();
      
      if (Array.isArray(sourceProperties) && sourceProperties.length > 0) {
        // Create duplicate properties for the new item
        for (const sourceProperty of sourceProperties) {
          try {
            const newPropertyPayload = {
              txnItemId: newItemId,
              material: sourceProperty.material,
              materialConstant: parseFloat(sourceProperty.materialConstant) || 0,
              materialUnit: sourceProperty.materialUnit || "Unit"
            };

            const createPropertyResponse = await fetch(
              `${API_BASE_URL}/api/txn-item-properties`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${currentToken}`,
                },
                body: JSON.stringify(newPropertyPayload),
              }
            );

            if (createPropertyResponse.ok) {
              successfulProperties++;
              console.log(` Created property: ${sourceProperty.material} for item ${sourceItem.itemNo}`);
            } else {
              failedProperties++;
              console.warn(`Failed to create property for ${sourceProperty.material}:`, createPropertyResponse.status);
            }
          } catch (error) {
            failedProperties++;
            console.error(`Error creating property ${sourceProperty.material}:`, error);
          }
        }
      }
    } else if (propertiesResponse.status === 404) {
      // No properties found for this item - this is normal
      console.log(`No properties found for item ${sourceItem.itemNo}`);
    } else if (propertiesResponse.status === 401) {
      toast.dismiss(propertiesSuccessToast);
      toast.error("Session expired. Please login again.");
      localStorage.clear();
      navigate("/signin");
      return;
    }
  } catch (error) {
    failedProperties++;
    console.error(`Error duplicating properties for item ${sourceItem.itemNo}:`, error);
  }
}

toast.dismiss(propertiesSuccessToast);

// Log properties duplication summary
if (successfulProperties > 0) {
  console.log(` Successfully duplicated ${successfulProperties} material properties`);
  if (failedProperties > 0) {
    toast.warning(`Duplicated ${successfulProperties} material properties. ${failedProperties} failed.`);
  } else {
    console.log(` All material properties duplicated successfully`);
  }
}
          // Store the duplicated data in localStorage for the estimate page
          localStorage.setItem(
            "subworkData",
            JSON.stringify(duplicatedSubworks)
          );
          localStorage.setItem(
            "revisionItems",
            JSON.stringify(duplicatedItems)
          );
          localStorage.setItem(
            "revisionMeasurements",
            JSON.stringify(duplicatedMeasurements)
          );
          localStorage.setItem(
            "estimateData",
            JSON.stringify(duplicatedSubworks)
          );
          localStorage.setItem(
            "estimateItems",
            JSON.stringify(duplicatedItems)
          );
          localStorage.setItem(
            "estimateMeasurements",
            JSON.stringify(duplicatedMeasurements)
          );

          // Store organized data by subwork
          const dataBySubwork = {};
          duplicatedSubworks.forEach((subwork) => {
            const subworkItems = duplicatedItems.filter(
              (item) => item.fkSubworkId === subwork.id
            );
            const subworkMeasurements = duplicatedMeasurements.filter(
              (measurement) =>
                subworkItems.some((item) => item.id === measurement.fkTxnItemId)
            );

            dataBySubwork[subwork.id] = {
              subwork: subwork,
              items: subworkItems,
              measurements: subworkMeasurements,
            };
          });

          localStorage.setItem(
            "revisionDataBySubwork",
            JSON.stringify(dataBySubwork)
          );

          // Store summary counts including lead charges
          localStorage.setItem(
            "totalSubworks",
            duplicatedSubworks.length.toString()
          );
          localStorage.setItem("totalItems", duplicatedItems.length.toString());
          localStorage.setItem(
            "totalMeasurements",
            duplicatedMeasurements.length.toString()
          );
          localStorage.setItem(
            "totalLeadCharges",
            successfulLeadCharges.toString()
          );

          // Store duplication summary including lead charges
          const duplicationSummary = {
            sourceRevisionId: revisionToCopy.id,
            sourceRevisionNumber: revisionToCopy.reviseNumber,
            newRevisionId: newRevisionId,
            newRevisionNumber: "1.0",
            newWorkorderId: newWorkorderId,
            duplicatedSubworks: duplicatedSubworks.length,
            duplicatedItems: duplicatedItems.length,
             duplicatedProperties: successfulProperties,
               failedProperties: failedProperties,
            duplicatedMeasurements: duplicatedMeasurements.length,
            duplicatedLeadCharges: successfulLeadCharges,
            failedLeadCharges: failedLeadCharges,
            totalSourceLeadCharges: allSourceLeadCharges.length,
            duplicationDate: new Date().toISOString(),
          };

          localStorage.setItem(
            "duplicationSummary",
            JSON.stringify(duplicationSummary)
          );

          // toast.dismiss(leadToast);
          
          // Updated success message to include lead charges
          if (failedLeadCharges > 0) {
            toast.error(
              `Workorder duplicated with ${duplicatedSubworks.length} subworks, ${duplicatedItems.length} items, ${duplicatedMeasurements.length} measurements, and ${successfulLeadCharges} lead charges. ${failedLeadCharges} lead charges failed to duplicate.`
            );
          } else {
            toast.success(
              `Workorder duplicated successfully! Created revision 1.0 with ${duplicatedSubworks.length} subworks, ${duplicatedItems.length} items, ${duplicatedMeasurements.length} measurements, and ${successfulLeadCharges} lead charges.`
            );
          }

          console.log(
            `Successfully duplicated: ${duplicatedSubworks.length} subworks, ${duplicatedItems.length} items, ${duplicatedMeasurements.length} measurements, ${successfulLeadCharges} lead charges`
          );
        } catch (error) {
          console.error("Error duplicating revision data:", error);
          toast.dismiss(loadingToast);
          toast.error("Failed to duplicate revision data: " + error.message);
          return;
        }
      } else {
        // No revision to copy from
        toast.dismiss(loadingToast);
        toast.success("New workorder created successfully with revision 1.0!");
      }

      // 11. Navigate to estimate page
      navigate("/estimate");
    } catch (err) {
      console.error("Failed to duplicate workorder:", err);
      toast.error("Failed to duplicate workorder: " + err.message);

      // Clean up on error
      // const keysToRemove = [
      //   'recordId', 'workorderId', 'reviseId', 'editMode', 'reviseno',
      //   'revisionNumber', 'currentRevisionNumber', 'duplicateRevision',
      //   'isDuplicatingRevision', 'sourceRevisionId', 'originalRevisionData',
      //   'duplicationSummary'
      // ];

      // keysToRemove.forEach(key => {
      //   localStorage.removeItem(key);
      // });
    }
  };
  const generateCustomWorkOrderID = (selectedState, states) => {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const hours = String(now.getHours()).padStart(2, "0");
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const seconds = String(now.getSeconds()).padStart(2, "0");

    const selectedStateObj = states.find(
      (state) => state.value === selectedState
    );
    const tin = selectedStateObj ? selectedStateObj.tin : "00";

    const wo = "WO";

    // Get userId from localStorage or use default
    const userId = localStorage.getItem("Id") || "1";

    const finalID = `${tin}${wo}${year}${month}${day}${hours}${minutes}${seconds}${userId}`;
    return finalID;
  };

  // Updated handleDuplicateClick function
  const handleDuplicateClick = (workorderId, event) => {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    setSelectedWorkorderId(workorderId);
  };
  // Also update your setSelectedWorkorderId if needed
  // const handleDuplicateClick = (workorderId, event) => {
  //   setSelectedWorkorderId(workorderId);
  //   handleDuplicate(workorderId, event);
  // };
  // 3. Updated handleDeleteRevision function with proper toast messages
  const handleDeleteRevision = async (mainId, revisionId, event) => {
    // Prevent row click when clicking delete button
    event.stopPropagation();

    if (!token) {
      toast.error("Authentication required. Please login again.");
      return;
    }

    // Show confirmation dialog
    const confirmed = window.confirm(
      "Are you sure you want to delete this revision? This action cannot be undone."
    );
    if (!confirmed) return;

    const loadingToast = toast.loading(
  <div className="flex items-center">
    <LuLoaderCircle className="w-4 h-4 text-orange-500 animate-spin mr-2" />
    Deleting revision...
  </div>
);

    try {
      const response = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/${revisionId}`,
        {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ deletedFlag: "YES" }),
        }
      );

      if (!response.ok) {
        if (response.status === 401) {
          toast.dismiss(loadingToast);
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return;
        }
        if (response.status === 404) {
          toast.dismiss(loadingToast);
          toast.error("Revision not found.");
          return;
        }
        if (response.status === 403) {
          toast.dismiss(loadingToast);
          toast.error("You do not have permission to delete this revision.");
          return;
        }
        throw new Error(`Server error: ${response.status}`);
      }

      toast.dismiss(loadingToast);
      toast.success("Revision deleted successfully!");

      // Refresh sub-records for this workorder
      const updatedResponse = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${mainId}`,
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );

      if (updatedResponse.ok) {
        const updatedData = await updatedResponse.json();
        const filtered = (updatedData || []).filter(
          (rec) => String(rec.deletedFlag).toLowerCase() === "no"
        );
        setSubRecords((prev) => ({ ...prev, [mainId]: filtered }));
      } else {
        toast.warning(
          "Revision deleted but failed to refresh list. Please refresh the page."
        );
      }
    } catch (err) {
      toast.dismiss(loadingToast);
      console.error("Delete revision error:", err);
      toast.error("Failed to delete revision. Please try again.");
    }
  };

  const fetchRevisions = async (workorderId) => {
    if (!token) {
      toast.error("Authentication required");
      return [];
    }

    try {
      const response = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${workorderId}`,
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );
      if (!response.ok) {
        if (response.status === 401) {
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return [];
        }
        throw new Error("Failed to fetch revisions");
      }

      const revisions = await response.json();
      const filtered = (revisions || [])
        .filter(
          (r) =>
            r.deletedFlag !== undefined &&
            String(r.deletedFlag).toLowerCase() !== "yes" &&
            !isNaN(parseFloat(r.reviseNumber))
        )
        .sort(
          (a, b) => parseFloat(a.reviseNumber) - parseFloat(b.reviseNumber)
        );

      return filtered;
    } catch (err) {
      toast.error("Error loading revisions");
      return [];
    }
  };

  const fetchRevisionById = async (revisionId) => {
    if (!token) {
      toast.error("Authentication required");
      return null;
    }

    try {
      const response = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/${revisionId}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        if (response.status === 401) {
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return null;
        }
        throw new Error(`Failed to fetch revision with id ${revisionId}`);
      }

      const data = await response.json();
      return Array.isArray(data) ? data[0] : data;
    } catch (err) {
      toast.error("Error fetching revision");
      return null;
    }
  };
  const downloadPDF = async (pdfLocations) => {
    if (!pdfLocations || !token) {
      toast.error("PDF location or authentication token missing!");
      return;
    }


    const loadingToast = toast.loading(
  <div className="flex items-center">
    <LuLoaderCircle className="w-4 h-4 text-orange-500 animate-spin mr-2" />
    Downloading PDF...
  </div>
);

    try {
      const filename = pdfLocations.split(/(\\|\/)/g).pop();
      const pdfLocation = `${API_BASE_URL}/api/file/download/${filename}`;

      const response = await fetch(pdfLocation, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      if (!response.ok) {
        throw new Error("Failed to fetch the PDF. Status: " + response.status);
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);

      // Try to extract filename from Content-Disposition header
      let downloadFilename = "downloaded.pdf";
      const disposition = response.headers.get("Content-Disposition");
      if (disposition && disposition.includes("filename=")) {
        const filenameRegex = /filename[^;=\n]*((['"]).?\2|[^;\n]*)/;
        const matches = filenameRegex.exec(disposition);
        if (matches != null && matches[1]) {
          downloadFilename = matches[1].replace(/['"]/g, "");
        }
      } else {
        downloadFilename = filename || "downloaded.pdf";
      }

      const a = document.createElement("a");
      a.href = url;
      a.download = downloadFilename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(url);

      toast.dismiss(loadingToast);
      toast.success("PDF downloaded successfully!");
    } catch (error) {
      toast.dismiss(loadingToast);
      console.error("Error downloading PDF:", error);
      toast.error("Could not download PDF! " + error.message);
    }
  };
  function getNextRevisionNumberFromList(revisions) {
    // Filter only valid revision numbers, get max, then +0.1
    const nums = (revisions || [])
      .map((r) => parseFloat(r.reviseNumber))
      .filter((n) => !isNaN(n));
    if (nums.length === 0) return "1.0";
    const max = Math.max(...nums);
    return (Math.round((max + 0.1) * 10) / 10).toFixed(1); // Always increments to next .1
  }

  const handleDuplicateRevision = async (
    workorderId,
    revisionToCopy,
    workorderRecord
  ) => {
    try {
      // Show loading toast
      
      const loadingToast = toast.loading(
  <div className="flex items-center">
    <LuLoaderCircle className="w-4 h-4 text-orange-500 animate-spin mr-2" />
   Creating duplicate revision with all content...
  </div>
);


      // Check authentication first
      if (!token) {
        toast.dismiss(loadingToast);
        toast.error("Authentication required. Please login again.");
        return;
      }

      // 1. Fetch all current revisions for the workorder
      const allRevisions = await fetchRevisions(workorderId);

      // 2. Get next available number
      const nextRevNumber = getNextRevisionNumberFromList(allRevisions);

      // 3. Create the new revision via API first
      const revisionPayload = {
        workorderId: parseInt(workorderId),
        reviseNumber: nextRevNumber,
        createdDate: new Date().toISOString(),
        createdBy: parseInt(uid),
        updatedBy: parseInt(uid),
        updatedDate: new Date().toISOString(),
        currentFlag: true,
        deletedFlag: "no",
        pdfLocation: "",
        revisionStage: "in-progress",
        revisionStatus: "pending",
      };

      const response = await fetch(`${API_BASE_URL}/api/workorder-revisions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(revisionPayload),
      });

      if (!response.ok) {
        if (response.status === 401) {
          toast.dismiss(loadingToast);
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return;
        }
        throw new Error(`Failed to create revision: ${response.status}`);
      }

      const newRevData = await response.json();

      // 4. Clear only specific localStorage keys to avoid conflicts
      const keysToRemove = [
        "recordId",
        "workorderId",
        "reviseId",
        "editMode",
        "reviseno",
        "revisionNumber",
        "currentRevisionNumber",
        "duplicateRevision",
        "edit_nameOfWork",
        "edit_state",
        "edit_department",
        "edit_ssr",
        "edit_area",
        "edit_preparedBy",
        "edit_checkedBy",
        "edit_chapter",
        "nameOfWork",
        "state",
        "department",
        "ssr",
        "area",
        "preparedBy",
        "checkedBy",
        "chapter",
        "autogenerated",
        "status",
        "revisionStage",
        "revisionStatus",
        "isEditMode",
        "editingRevision",
        "currentRevisionId",
        "originalRevisionData",
        "subworkData",
        "revisionItems",
        "revisionMeasurements",
        "revisionDataBySubwork",
        "totalSubworks",
        "totalItems",
        "totalMeasurements",
        "isDuplicatingRevision",
      ];

      keysToRemove.forEach((key) => {
        localStorage.removeItem(key);
      });

      // 5. Set basic localStorage data for the new revision
      localStorage.setItem("editMode", "true");
      localStorage.setItem("workorderId", workorderId.toString());
      localStorage.setItem("recordId", workorderId.toString());
      localStorage.setItem("reviseId", newRevData.id.toString());
      localStorage.setItem("reviseno", nextRevNumber);
      localStorage.setItem("revisionNumber", nextRevNumber);
      localStorage.setItem("currentRevisionNumber", nextRevNumber);
      localStorage.setItem("duplicateRevision", "true");
      localStorage.setItem("isDuplicatingRevision", "true");
      localStorage.setItem("sourceRevisionId", revisionToCopy.id.toString());

      // 6. Store workorder data (both with and without edit_ prefix)
      if (workorderRecord) {
        // With edit_ prefix (for form fields)
        localStorage.setItem(
          "edit_nameOfWork",
          workorderRecord.nameOfWork || ""
        );
        localStorage.setItem("edit_state", workorderRecord.state || "");
        localStorage.setItem(
          "edit_department",
          workorderRecord.department || ""
        );
        localStorage.setItem("edit_ssr", workorderRecord.ssr || "");
        localStorage.setItem("edit_area", workorderRecord.area || "");
        localStorage.setItem(
          "edit_preparedBy",
          workorderRecord.preparedBySignature || ""
        );
        localStorage.setItem(
          "edit_checkedBy",
          workorderRecord.checkedBySignature || ""
        );
        localStorage.setItem(
          "edit_chapter",
          workorderRecord.chapterId?.toString() || ""
        );

        // Without edit_ prefix (for display/logic)
        localStorage.setItem("nameOfWork", workorderRecord.nameOfWork || "");
        localStorage.setItem("state", workorderRecord.state || "");
        localStorage.setItem("department", workorderRecord.department || "");
        localStorage.setItem("ssr", workorderRecord.ssr || "");
        localStorage.setItem("area", workorderRecord.area || "");
        localStorage.setItem(
          "preparedBy",
          workorderRecord.preparedBySignature || ""
        );
        localStorage.setItem(
          "checkedBy",
          workorderRecord.checkedBySignature || ""
        );
        localStorage.setItem(
          "chapter",
          workorderRecord.chapterId?.toString() || ""
        );
        localStorage.setItem(
          "autogenerated",
          workorderRecord.workOrderID || ""
        );
        localStorage.setItem("status", workorderRecord.status || "");
      }

      // 7. Store revision data
      localStorage.setItem("revisionStage", "started");
      localStorage.setItem("revisionStatus", "pending");

      // 8. Store user data - ensure token consistency
      const userData = getUserData();
      const currentToken = token;

      if (!localStorage.getItem("userId"))
        localStorage.setItem("userId", userData?.uid || "");
      if (!localStorage.getItem("userToken"))
        localStorage.setItem("userToken", currentToken);
      if (!localStorage.getItem("jwt"))
        localStorage.setItem("jwt", currentToken);
      if (!localStorage.getItem("Id"))
        localStorage.setItem("Id", userData?.uid || "");
      if (!localStorage.getItem("authToken"))
        localStorage.setItem("authToken", currentToken);
      if (!localStorage.getItem("token"))
        localStorage.setItem("token", currentToken);

      // 9. Store duplicate metadata
      localStorage.setItem(
        "originalRevisionData",
        JSON.stringify({
          id: revisionToCopy.id,
          reviseNumber: revisionToCopy.reviseNumber,
          revisionStage: revisionToCopy.revisionStage || "started",
          revisionStatus: revisionToCopy.revisionStatus || "pending",
        })
      );

      localStorage.setItem(
        "newRevisionData",
        JSON.stringify({
          id: newRevData.id,
          reviseNumber: nextRevNumber,
          revisionStage: "started",
          revisionStatus: "pending",
        })
      );

      // 10. FETCH SOURCE REVISION DATA VIA API
      console.log("Fetching source revision data via API...");

      // Fetch subwork data from source revision
      const subworkResponse = await fetch(
        `${API_BASE_URL}/api/subwork/${revisionToCopy.id}/${workorderId}`,
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${currentToken}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!subworkResponse.ok) {
        if (subworkResponse.status === 401) {
          toast.dismiss(loadingToast);
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return;
        }
        throw new Error(
          `Failed to fetch source subwork data: ${subworkResponse.status}`
        );
      }

      const sourceSubworkData = await subworkResponse.json();
      console.log("Source subwork data:", sourceSubworkData);

      // Initialize arrays to store all source data
      const allSourceItems = [];
      const allSourceMeasurements = [];

      // For each subwork in source revision, fetch its items and measurements
      for (const subwork of sourceSubworkData) {
        try {
          // Fetch items for this subwork from source revision
          const itemsResponse = await fetch(
            `${API_BASE_URL}/api/txn-items/BySubwork/${subwork.id}`,
            {
              method: "GET",
              headers: {
                Authorization: `Bearer ${currentToken}`,
                "Content-Type": "application/json",
              },
            }
          );

          if (itemsResponse.ok) {
            const itemsData = await itemsResponse.json();
            console.log(`Source items for subwork ${subwork.id}:`, itemsData);

            // Add subwork reference to each item and prepare for duplication
            const itemsWithSubwork = itemsData.map((item) => ({
              ...item,
              originalId: item.id, // Keep original ID for reference
              id: null, // Reset ID so new ones will be generated
              subworkId: null, // Will be set to new subwork ID after subwork duplication
              originalSubworkId: subwork.id, // Keep reference to original subwork
              subworkName: subwork.subworkName,
              revisionId: newRevData.id, // Set to new revision ID
              createdDate: new Date().toISOString(),
              updatedDate: new Date().toISOString(),
              createdBy: parseInt(uid),
              updatedBy: parseInt(uid),
            }));

            allSourceItems.push(...itemsWithSubwork);

            // For each item, fetch its measurements using the CORRECT API endpoint
            for (const item of itemsData) {
              try {
                // CHANGED: Using the correct API endpoint for measurements
                const measurementsResponse = await fetch(
                  `${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`,
                  {
                    method: "GET",
                    headers: {
                      Authorization: `Bearer ${currentToken}`,
                      "Content-Type": "application/json",
                    },
                  }
                );

                if (measurementsResponse.ok) {
                  const measurementsData = await measurementsResponse.json();
                  console.log(
                    `Source measurements for item ${item.id}:`,
                    measurementsData
                  );

                  // Add item and subwork reference to each measurement and prepare for duplication
                  const measurementsWithRef = measurementsData.map(
                    (measurement) => ({
                      ...measurement,
                      originalId: measurement.id, // Keep original ID for reference
                      id: null, // Reset ID so new ones will be generated
                      itemId: null, // Will be set to new item ID after item duplication
                      originalItemId: item.id, // Keep reference to original item
                      itemNo: item.itemNo,
                      subworkId: null, // Will be set to new subwork ID
                      originalSubworkId: subwork.id, // Keep reference to original subwork
                      subworkName: subwork.subworkName,
                      createdDate: new Date().toISOString(),
                      updatedDate: new Date().toISOString(),
                      createdBy: parseInt(uid),
                      updatedBy: parseInt(uid),
                    })
                  );

                  allSourceMeasurements.push(...measurementsWithRef);
                } else if (measurementsResponse.status === 401) {
                  toast.dismiss(loadingToast);
                  toast.error("Session expired. Please login again.");
                  localStorage.clear();
                  navigate("/signin");
                  return;
                } else {
                  console.warn(
                    `Failed to fetch measurements for item ${item.id}:`,
                    measurementsResponse.status
                  );
                }
              } catch (error) {
                console.error(
                  `Error fetching measurements for item ${item.id}:`,
                  error
                );
              }
            }
          } else if (itemsResponse.status === 401) {
            toast.dismiss(loadingToast);
            toast.error("Session expired. Please login again.");
            localStorage.clear();
            navigate("/signin");
            return;
          } else {
            console.warn(
              `Failed to fetch items for subwork ${subwork.id}:`,
              itemsResponse.status
            );
          }
        } catch (error) {
          console.error(
            `Error fetching items for subwork ${subwork.id}:`,
            error
          );
        }
      }

      // 11. NOW DUPLICATE ALL DATA - POST TO NEW REVISION
      console.log("Starting duplication process...");
      toast.dismiss(loadingToast);
      const subworkToast = toast.loading("Duplicating subwork data...");

      // Track created records for mapping relationships
      const subworkMapping = {}; // originalSubworkId -> newSubworkId
      const itemMapping = {}; // originalItemId -> newItemId

      // Step 1: Create duplicate subworks
      for (const sourceSubwork of sourceSubworkData) {
        try {
          const newSubworkPayload = {
            id: 0, // API will generate new ID
            reviseId: newRevData.id, // New revision ID
            workorderId: parseInt(workorderId),
            subworkName: sourceSubwork.subworkName,
            createdDate: new Date().toISOString(),
            createdBy: parseInt(uid),
            updatedDate: new Date().toISOString(),
            updatedBy: parseInt(uid),
          };

          const createSubworkResponse = await fetch(
            `${API_BASE_URL}/api/subwork`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${currentToken}`,
              },
              body: JSON.stringify(newSubworkPayload),
            }
          );

          if (!createSubworkResponse.ok) {
            if (createSubworkResponse.status === 401) {
              toast.dismiss(subworkToast);
              toast.error("Session expired. Please login again.");
              localStorage.clear();
              navigate("/signin");
              return;
            }
            throw new Error(
              `Failed to create subwork: ${createSubworkResponse.status}`
            );
          }

          const newSubworkData = await createSubworkResponse.json();
          subworkMapping[sourceSubwork.id] = newSubworkData.id;
          console.log(
            `Created subwork: ${sourceSubwork.subworkName} (ID: ${newSubworkData.id})`
          );
        } catch (error) {
          console.error(
            `Error creating subwork ${sourceSubwork.subworkName}:`,
            error
          );
          toast.dismiss(subworkToast);
          toast.error(
            `Failed to duplicate subwork: ${sourceSubwork.subworkName}`
          );
          return;
        }
      }

      // Step 2: Create duplicate items
      toast.dismiss(subworkToast);
      const itemsToast = toast.loading("Duplicating items data...");

      for (const sourceItem of allSourceItems) {
        try {
          const newSubworkId = subworkMapping[sourceItem.originalSubworkId];
          if (!newSubworkId) {
            console.warn(
              `No mapping found for subwork ID ${sourceItem.originalSubworkId}`
            );
            continue;
          }

          // Match the API's expected field structure
          const newItemPayload = {
            id: 0, // API will generate new ID
            srNo: sourceItem.srNo || 0,
            itemNo: sourceItem.itemNo || "",
            category: sourceItem.category || "",
            descriptionOfItem:
              sourceItem.description || sourceItem.descriptionOfItem || "",
            floorLiftRise: sourceItem.floorLiftRise || "",
            fkSubworkId: newSubworkId,
            fkWorkorderId: parseInt(workorderId),
            completedRate: sourceItem.completedRate || sourceItem.rate || 0,
            labourRate: sourceItem.labourRate || 0,
            scadaFlag: sourceItem.scadaFlag || false,
            smallUnit: sourceItem.smallUnit || sourceItem.unit || "",
            fullUnit: sourceItem.fullUnit || sourceItem.unit || "",
            additionalSpecification: sourceItem.additionalSpecification || "",
          };

          const createItemResponse = await fetch(
            `${API_BASE_URL}/api/txn-items`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${currentToken}`,
              },
              body: JSON.stringify(newItemPayload),
            }
          );

          if (!createItemResponse.ok) {
            if (createItemResponse.status === 401) {
              toast.dismiss(itemsToast);
              toast.error("Session expired. Please login again.");
              localStorage.clear();
              navigate("/signin");
              return;
            }

            const errorText = await createItemResponse.text();
            console.error(`Failed to create item ${sourceItem.itemNo}:`, {
              status: createItemResponse.status,
              error: errorText,
              payload: newItemPayload,
            });

            throw new Error(
              `Failed to create item: ${createItemResponse.status} - ${errorText}`
            );
          }

          const newItemData = await createItemResponse.json();
          itemMapping[sourceItem.originalId] = newItemData.id;
          console.log(
            `Created item: ${sourceItem.itemNo} (ID: ${newItemData.id})`
          );
        } catch (error) {
          console.error(`Error creating item ${sourceItem.itemNo}:`, error);
          toast.dismiss(itemsToast);
          toast.error(
            `Failed to duplicate item: ${sourceItem.itemNo} - ${error.message}`
          );
          return;
        }
      }

      // Step 3: Create duplicate measurements - FIXED WITH CORRECT FIELD MAPPING
      toast.dismiss(itemsToast);
      const measurementsToast = toast.loading(
        "Duplicating measurements data..."
      );

      let successfulMeasurements = 0;
      let failedMeasurements = 0;

      for (const sourceMeasurement of allSourceMeasurements) {
        try {
          const newItemId = itemMapping[sourceMeasurement.originalItemId];
          if (!newItemId) {
            console.warn(
              `No mapping found for item ID ${sourceMeasurement.originalItemId}`
            );
            failedMeasurements++;
            continue;
          }

          // FIXED: Correct field mapping based on API schema
          const newMeasurementPayload = {
            // Using the correct field names from the API schema
            srNo: sourceMeasurement.srNo || 1,
            description: sourceMeasurement.description?.toString() || "",
            quantity: parseFloat(sourceMeasurement.quantity) || 0,
            number:
              parseFloat(sourceMeasurement.number || sourceMeasurement.nos) ||
              0,
            length: parseFloat(sourceMeasurement.length) || 0,
            width:
              parseFloat(
                sourceMeasurement.width || sourceMeasurement.breadth
              ) || 0,
            height: parseFloat(sourceMeasurement.height) || 0,
            unit: sourceMeasurement.unit || "",
            fkTxnItemId: newItemId,
            multiplyNumber: parseFloat(sourceMeasurement.multiplyNumber) || 1,
            floorLiftRise: sourceMeasurement.floorLiftRise || "",
            refTxnItemId: sourceMeasurement.refTxnItemId || 0,
            refTxnItemPercentage:
              parseFloat(sourceMeasurement.refTxnItemPercentage) || 0,
          };

          // Validate the payload before sending
          const validationErrors = [];
          if (!newItemId || isNaN(newItemId))
            validationErrors.push("Invalid fkTxnItemId");
          if (typeof newMeasurementPayload.description !== "string")
            validationErrors.push("Invalid description");

          if (validationErrors.length > 0) {
            console.error("Validation errors:", validationErrors);
            failedMeasurements++;
            continue;
          }

          // Log the payload for debugging
          console.log(
            "Creating measurement with payload:",
            newMeasurementPayload
          );

          const createMeasurementResponse = await fetch(
            `${API_BASE_URL}/api/txn-items-mts`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${currentToken}`,
              },
              body: JSON.stringify(newMeasurementPayload),
            }
          );

          if (!createMeasurementResponse.ok) {
            if (createMeasurementResponse.status === 401) {
              toast.dismiss(measurementsToast);
              toast.error("Session expired. Please login again.");
              localStorage.clear();
              navigate("/signin");
              return;
            }

            // Get detailed error information
            const errorText = await createMeasurementResponse.text();
            console.error(
              `Failed to create measurement S.No ${sourceMeasurement.srNo}:`,
              {
                status: createMeasurementResponse.status,
                error: errorText,
                payload: newMeasurementPayload,
                sourceMeasurement: sourceMeasurement,
              }
            );

            failedMeasurements++;
            continue;
          }

          const newMeasurementData = await createMeasurementResponse.json();
          console.log(
            `Created measurement: S.No ${sourceMeasurement.srNo} (ID: ${newMeasurementData.id})`
          );
          successfulMeasurements++;
        } catch (error) {
          console.error(
            `Error creating measurement S.No ${sourceMeasurement.srNo}:`,
            error
          );
          failedMeasurements++;
          continue;
        }
      }
toast.dismiss(measurementsToast);
const materialsToast = toast.loading("Duplicating materials data...");

let successfulMaterials = 0;
let failedMaterials = 0;
const allSourceMaterials = [];

// First, fetch all materials for source items
for (const sourceItem of allSourceItems) {
  try {
    const materialsResponse = await fetch(
      `${API_BASE_URL}/api/txn-item-properties/serchByTxnItemId/${sourceItem.originalId}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${currentToken}`,
          "Content-Type": "application/json",
        },
      }
    );

    if (materialsResponse.ok) {
      const materialsData = await materialsResponse.json();
      
      if (Array.isArray(materialsData) && materialsData.length > 0) {
        console.log(`Found ${materialsData.length} materials for item ${sourceItem.itemNo}`);
        
        // Add item reference to each material and prepare for duplication
        const materialsWithRef = materialsData.map((material) => ({
          ...material,
          originalId: material.id,
          id: null, // Reset ID so new ones will be generated
          originalItemId: sourceItem.originalId,
          itemNo: sourceItem.itemNo,
          newItemId: itemMapping[sourceItem.originalId], // Map to new item ID
        }));

        allSourceMaterials.push(...materialsWithRef);
      }
    } else if (materialsResponse.status === 401) {
      toast.dismiss(materialsToast);
      toast.error("Session expired. Please login again.");
      localStorage.clear();
      navigate("/signin");
      return;
    } else {
      console.warn(`No materials found for item ${sourceItem.itemNo}`);
    }
  } catch (error) {
    console.error(`Error fetching materials for item ${sourceItem.itemNo}:`, error);
  }
}

console.log(`Total source materials to duplicate: ${allSourceMaterials.length}`);

// Now create duplicate materials
for (const sourceMaterial of allSourceMaterials) {
  try {
    const newItemId = sourceMaterial.newItemId;
    
    if (!newItemId) {
      console.warn(`No mapping found for item ID ${sourceMaterial.originalItemId}`);
      failedMaterials++;
      continue;
    }

    const newMaterialPayload = {
      txnItemId: newItemId,
      material: sourceMaterial.material || "",
      materialConstant: parseFloat(sourceMaterial.materialConstant) || 0,
      materialUnit: sourceMaterial.materialUnit || "Unit"
    };

    // Validate the payload
    if (!newMaterialPayload.material || newMaterialPayload.material.trim() === "") {
      console.warn(`Invalid material name for item ${sourceMaterial.itemNo}`);
      failedMaterials++;
      continue;
    }

    console.log(`Creating material: ${newMaterialPayload.material} for item ${sourceMaterial.itemNo}`);

    const createMaterialResponse = await fetch(
      `${API_BASE_URL}/api/txn-item-properties`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${currentToken}`,
        },
        body: JSON.stringify(newMaterialPayload),
      }
    );

    if (!createMaterialResponse.ok) {
      if (createMaterialResponse.status === 401) {
        toast.dismiss(materialsToast);
        toast.error("Session expired. Please login again.");
        localStorage.clear();
        navigate("/signin");
        return;
      }

      const errorText = await createMaterialResponse.text();
      console.error(`Failed to create material ${sourceMaterial.material}:`, {
        status: createMaterialResponse.status,
        error: errorText,
        payload: newMaterialPayload,
      });

      failedMaterials++;
      continue;
    }

    const newMaterialData = await createMaterialResponse.json();
    console.log(` Created material: ${sourceMaterial.material} (ID: ${newMaterialData.id})`);
    successfulMaterials++;
    
  } catch (error) {
    console.error(`Error creating material ${sourceMaterial.material}:`, error);
    failedMaterials++;
    continue;
  }
}// Step 5: For items that don't have existing materials, create them from consumption materials
toast.dismiss(materialsToast);

let autoCreatedMaterials = 0;
let autoFailedMaterials = 0;

// Get items that don't have materials
const itemsWithoutMaterials = allSourceItems.filter(sourceItem => {
  const hasExistingMaterials = allSourceMaterials.some(material => 
    material.originalItemId === sourceItem.originalId
  );
  return !hasExistingMaterials && itemMapping[sourceItem.originalId];
});

console.log(`Found ${itemsWithoutMaterials.length} items without materials, will auto-create from consumption data`);

for (const itemWithoutMaterials of itemsWithoutMaterials) {
  try {
    const newItemId = itemMapping[itemWithoutMaterials.originalId];
    
    if (!newItemId) {
      console.warn(`No new item ID found for ${itemWithoutMaterials.itemNo}`);
      continue;
    }

    // Create materials using the existing createMaterialsForItem function
    const materialCreationResult = await createMaterialsForItem(newItemId, {
      id: newItemId,
      itemNo: itemWithoutMaterials.itemNo,
      category: itemWithoutMaterials.category,
      descriptionOfItem: itemWithoutMaterials.descriptionOfItem || itemWithoutMaterials.description
    });

    if (materialCreationResult.success) {
      autoCreatedMaterials += materialCreationResult.successfulCreations;
      console.log(` Auto-created ${materialCreationResult.successfulCreations} materials for ${itemWithoutMaterials.itemNo}`);
    } else {
      autoFailedMaterials++;
      console.log(` Could not auto-create materials for ${itemWithoutMaterials.itemNo}: ${materialCreationResult.reason}`);
    }
    
  } catch (error) {
    console.error(`Error auto-creating materials for ${itemWithoutMaterials.itemNo}:`, error);
    autoFailedMaterials++;
  }
}
// Step 6: Duplicate Lead Charges Data
toast.dismiss(materialsToast);
// const leadToast = toast.loading("Duplicating lead charges data...");

let successfulLeadCharges = 0;
let failedLeadCharges = 0;
let allSourceLeadCharges = [];

try {
  // Fetch lead charges from source revision
  const leadChargesResponse = await fetch(
    `${API_BASE_URL}/api/txn-leads/${workorderId}/${revisionToCopy.id}`,
    {
      method: "GET",
      headers: {
        Authorization: `Bearer ${currentToken}`,
        "Content-Type": "application/json",
      },
    }
  );

  if (leadChargesResponse.ok) {
    allSourceLeadCharges = await leadChargesResponse.json();
    console.log(`Found ${allSourceLeadCharges.length} lead charges to duplicate`);

    // Create duplicate lead charges for new revision
    for (const sourceLeadCharge of allSourceLeadCharges) {
      try {
        const newLeadChargePayload = {
          srNo: sourceLeadCharge.srNo || 0,
          materialName: sourceLeadCharge.materialName || "",
          location: sourceLeadCharge.location || "",
          leadInKm: parseFloat(sourceLeadCharge.leadInKm) || 0,
          leadCharges: parseFloat(sourceLeadCharge.leadCharges) || 0,
          ssrRate: parseFloat(sourceLeadCharge.ssrRate) || 0,
          currentRate: parseFloat(sourceLeadCharge.currentRate) || 0,
          diffInRate: parseFloat(sourceLeadCharge.diffInRate) || 0,
          unit: sourceLeadCharge.unit || "Per Cu.M.",
          remark: sourceLeadCharge.remark || null,
          fkWorkorderId: parseInt(workorderId),
          fkReviseId: newRevData.id // Use new revision ID
        };

        // Validate required fields
        if (!newLeadChargePayload.materialName || !newLeadChargePayload.location) {
          console.warn(`Skipping lead charge with missing required fields: ${JSON.stringify(newLeadChargePayload)}`);
          failedLeadCharges++;
          continue;
        }

        console.log("Creating lead charge with payload:", newLeadChargePayload);

        const createLeadChargeResponse = await fetch(
          `${API_BASE_URL}/api/txn-leads`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${currentToken}`,
            },
            body: JSON.stringify(newLeadChargePayload),
          }
        );

        if (!createLeadChargeResponse.ok) {
          if (createLeadChargeResponse.status === 401) {
            // toast.dismiss(leadToast);
            toast.error("Session expired. Please login again.");
            localStorage.clear();
            navigate("/signin");
            return;
          }

          const errorText = await createLeadChargeResponse.text();
          console.error(`Failed to create lead charge for ${sourceLeadCharge.materialName}:`, {
            status: createLeadChargeResponse.status,
            error: errorText,
            payload: newLeadChargePayload,
          });

          failedLeadCharges++;
          continue;
        }

        const newLeadChargeData = await createLeadChargeResponse.json();
        console.log(` Created lead charge: ${sourceLeadCharge.materialName} (ID: ${newLeadChargeData.id})`);
        successfulLeadCharges++;

      } catch (error) {
        console.error(`Error creating lead charge ${sourceLeadCharge.materialName}:`, error);
        failedLeadCharges++;
        continue;
      }
    }
  } else if (leadChargesResponse.status === 401) {
    // toast.dismiss(leadToast);
    toast.error("Session expired. Please login again.");
    localStorage.clear();
    navigate("/signin");
    return;
  } else if (leadChargesResponse.status === 404) {
    console.log("No lead charges found for source revision - this is normal");
  } else {
    console.warn(`Failed to fetch lead charges: ${leadChargesResponse.status}`);
  }

} catch (error) {
  console.error("Error fetching/duplicating lead charges:", error);
  failedLeadCharges++;
}
      // 12. Store duplication summary in localStorage
     const duplicationSummary = {
  sourceRevisionId: revisionToCopy.id,
  sourceRevisionNumber: revisionToCopy.reviseNumber,
  newRevisionId: newRevData.id,
  newRevisionNumber: nextRevNumber,
  duplicatedSubworks: Object.keys(subworkMapping).length,
  duplicatedItems: Object.keys(itemMapping).length,
  duplicatedMeasurements: successfulMeasurements,
  failedMeasurements: failedMeasurements,
  duplicatedMaterials: successfulMaterials,
  failedMaterials: failedMaterials,
  totalSourceMaterials: allSourceMaterials.length,
  autoCreatedMaterials: autoCreatedMaterials,
  autoFailedMaterials: autoFailedMaterials,
  totalMaterials: successfulMaterials + autoCreatedMaterials,
  duplicatedLeadCharges: successfulLeadCharges,
  failedLeadCharges: failedLeadCharges,
  totalSourceLeadCharges: allSourceLeadCharges.length,
  totalSourceMeasurements: allSourceMeasurements.length,
  duplicationDate: new Date().toISOString(),
};

      localStorage.setItem(
        "duplicationSummary",
        JSON.stringify(duplicationSummary)
      );

      // 13. Success notification with detailed information
      toast.dismiss(measurementsToast);

   if (failedMeasurements > 0 || failedMaterials > 0 || failedLeadCharges > 0) {
  const errorParts = [];
  if (failedMeasurements > 0) errorParts.push(`${failedMeasurements} measurements`);
  if (failedMaterials > 0) errorParts.push(`${failedMaterials} materials`);
  if (failedLeadCharges > 0) errorParts.push(`${failedLeadCharges} lead charges`);
  
  toast.error(
    `Revision ${nextRevNumber} created with ${duplicationSummary.duplicatedSubworks} subworks, ${duplicationSummary.duplicatedItems} items, ${successfulMeasurements} measurements, ${successfulMaterials + autoCreatedMaterials} materials, and ${successfulLeadCharges} lead charges. Failed: ${errorParts.join(', ')}.`
  );
} else {
  toast.success(
    `Revision ${nextRevNumber} created successfully with ${duplicationSummary.duplicatedSubworks} subworks, ${duplicationSummary.duplicatedItems} items, ${successfulMeasurements} measurements, ${successfulMaterials + autoCreatedMaterials} materials, and ${successfulLeadCharges} lead charges!`
  );
}

      console.log("Duplication completed:", duplicationSummary);

      // 14. Navigate to subestimate page
      navigate("/subestimate");
    } catch (error) {
      console.error("Error in handleDuplicateRevision:", error);
      toast.error(`Failed to duplicate revision: ${error.message}`);

      // Clean up on error
      const keysToRemove = [
        "recordId",
        "workorderId",
        "reviseId",
        "editMode",
        "reviseno",
        "revisionNumber",
        "currentRevisionNumber",
        "duplicateRevision",
        "isDuplicatingRevision",
        "sourceRevisionId",
        "originalRevisionData",
        "newRevisionData",
        "duplicationSummary",
      ];

      keysToRemove.forEach((key) => {
        localStorage.removeItem(key);
      });
    }
  };
// Updated createMaterialsForItem function that returns proper result structure
const createMaterialsForItem = async (itemId, itemData) => {
  try {
    console.log('Starting material creation for item:', itemId);

    let detailedItemId = null;
    let consumptionMaterials = [];

    // First, try to get from cache
    console.log(`Checking cache for consumption materials for item: ${itemData.itemNo}`);
    const cachedMaterials = getConsumptionMaterialsFromCache(itemData.itemNo);
    
    if (cachedMaterials && cachedMaterials.length > 0) {
      console.log(` Found ${cachedMaterials.length} cached consumption materials for ${itemData.itemNo}`);
      consumptionMaterials = cachedMaterials;
    } else {
      console.log(`No cached materials found for ${itemData.itemNo}, fetching from API...`);
      
      try {
        const detailedItem = itemOptions.find(opt => opt.ssrItemId === itemData.itemNo);
        
        if (detailedItem) {
          console.log("Found detailed master item:", detailedItem);
          detailedItemId = detailedItem.detailedItemId;
          
          // Store page number in localStorage when found
          if (detailedItem.pageNo) {
            storePageNumberForItem(itemData.itemNo, detailedItem.pageNo);
          }
          
          // Fetch consumption materials if we have detailedItemId
          if (detailedItemId) {
            console.log(`Fetching consumption materials from API for detailedItemId: ${detailedItemId}`);
            const materialsResponse = await fetch(
              `${API_BASE_URL}/api/master/consumptionMaterialAndRoad/getDetailedItemId?detailedItemId=${detailedItemId}`, 
              {
                headers: {
                  "Authorization": `Bearer ${jwtToken}`,
                  "Accept": "*/*"
                }
              }
            );
            
            if (materialsResponse.ok) {
              const materialsData = await materialsResponse.json();
              const rawMaterials = Array.isArray(materialsData) ? materialsData : [];
              
              // Filter and validate materials
              const validMaterials = rawMaterials.filter(material => {
                const isValid = material.materialName && 
                               material.fkMaterialId && 
                               material.fkMaterialId > 0 &&
                               material.constant !== null && 
                               material.constant !== undefined;
                
                if (!isValid) {
                  console.warn(`Invalid material data filtered out:`, material);
                }
                return isValid;
              });
              
              if (validMaterials.length > 0) {
                consumptionMaterials = validMaterials;
                
                // *** CACHE THE FETCHED MATERIALS ***
                console.log(` Caching ${validMaterials.length} valid consumption materials for ${itemData.itemNo}`);
                storeConsumptionMaterialsInCache(itemData.itemNo, detailedItemId, validMaterials);
                
                console.log("Cached materials details:");
                validMaterials.forEach((mat, idx) => {
                  console.log(`  ${idx + 1}. ${mat.materialName} (fkMaterialId: ${mat.fkMaterialId}, constant: ${mat.constant})`);
                });
              } else {
                console.warn(`No valid consumption materials found for ${itemData.itemNo}`);
                console.log("Raw materials received:", rawMaterials);
              }
            } else {
              console.warn("Failed to fetch consumption materials:", materialsResponse.status, materialsResponse.statusText);
            }
          } else {
            console.warn(`No detailedItemId found for ${itemData.itemNo}`);
          }
        } else {
          console.warn(`No detailed item found for itemNo: ${itemData.itemNo}`);
          return; // Exit early if no detailed item found
        }
      } catch (detailError) {
        console.warn("Error finding detailed item:", detailError);
        return; // Exit early on error
      }
    }

    // Create transaction item properties from consumption materials
    if (consumptionMaterials.length > 0) {
      console.log(`Creating ${consumptionMaterials.length} transaction item properties from consumption materials...`);
      
      const propertyCreationPromises = consumptionMaterials.map(async (material, index) => {
        // Validate material data before creating property
        if (!material.materialName || material.constant === null || material.constant === undefined) {
          console.warn(`Invalid material data at index ${index}:`, material);
          return { error: true, material: material.materialName || `Material ${index + 1}`, errorDetails: 'Invalid material data' };
        }
        
        const propertyData = {
          txnItemId: itemId,
          material: material.materialName.trim(),
          materialConstant: parseFloat(material.constant) || 0,
          materialUnit: material.materialUnit ? material.materialUnit.trim() : "Unit"
        };
        
        console.log(`Creating property ${index + 1}/${consumptionMaterials.length}:`, propertyData);
        
        try {
          const createResponse = await fetch(`${API_BASE_URL}/api/txn-item-properties`, {
            method: 'POST',
            headers: {
              "Authorization": `Bearer ${jwtToken}`,
              "Accept": "application/json",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(propertyData)
          });
          
          if (createResponse.ok) {
            const createdProperty = await createResponse.json();
            console.log(` Successfully created property ${index + 1}:`, createdProperty);
            return createdProperty;
          } else {
            // Get detailed error information
            let errorDetails = '';
            try {
              const errorResponse = await createResponse.json();
              errorDetails = errorResponse.message || errorResponse.error || createResponse.statusText;
            } catch {
              errorDetails = await createResponse.text() || createResponse.statusText;
            }
            
            console.error(` Failed to create property for material ${material.materialName}:`, {
              status: createResponse.status,
              statusText: createResponse.statusText,
              errorDetails: errorDetails,
              requestData: propertyData
            });
            
            return {
              error: true,
              material: material.materialName,
              errorDetails: errorDetails,
              status: createResponse.status
            };
          }
        } catch (createError) {
          console.error(` Network error creating property for material ${material.materialName}:`, createError);
          return {
            error: true,
            material: material.materialName,
            errorDetails: createError.message,
            networkError: true
          };
        }
      });
      
      // Execute all property creation requests
      console.log("Executing property creation requests...");
      const createdPropertiesResults = await Promise.allSettled(propertyCreationPromises);
      const successfulProperties = [];
      const failedProperties = [];
      
      createdPropertiesResults.forEach((result, index) => {
        if (result.status === 'fulfilled' && result.value !== null) {
          if (result.value.error) {
            failedProperties.push({
              material: result.value.material,
              error: result.value.errorDetails,
              index: index + 1
            });
          } else {
            successfulProperties.push(result.value);
          }
        } else {
          failedProperties.push({
            material: consumptionMaterials[index]?.materialName || `Material ${index + 1}`,
            error: result.reason?.message || 'Unknown error',
            index: index + 1
          });
        }
      });
      
      // *** ENHANCED RESULT LOGGING ***
      console.log('\n=== MATERIAL PROPERTY CREATION RESULTS ===');
      console.log(`Total materials processed: ${consumptionMaterials.length}`);
      console.log(`Successful creations: ${successfulProperties.length}`);
      console.log(`Failed creations: ${failedProperties.length}`);
      
      if (successfulProperties.length > 0) {
        console.log(` Successfully created ${successfulProperties.length} material properties for item ${itemId}`);
        console.log('Created properties:', successfulProperties.map(p => p.material || 'Unknown'));
        
        if (failedProperties.length > 0) {
          console.warn(` Failed to create ${failedProperties.length} properties:`);
          failedProperties.forEach(failed => {
            console.warn(`  - ${failed.material}: ${failed.error}`);
          });
        }
        
        // *** UPDATE CACHE STATISTICS ***
        console.log('\n=== CACHE STATISTICS AFTER CREATION ===');
        const cacheStats = getConsumptionMaterialsCacheStats();
        if (cacheStats) {
          console.log(`Items in cache: ${cacheStats.itemsCached}`);
          console.log(`Material mappings: ${cacheStats.materialMappings}`);
        }
        
      } else {
        console.error(" Failed to create any material properties for item:", itemId);
        if (failedProperties.length > 0) {
          const errorSummary = failedProperties.map(f => `${f.material}: ${f.error}`).join('; ');
          console.error("Creation failures summary:", errorSummary);
        }
      }
      
      // *** RETURN CREATION SUMMARY ***
      return {
        success: successfulProperties.length > 0,
        totalMaterials: consumptionMaterials.length,
        successfulCreations: successfulProperties.length,
        failedCreations: failedProperties.length,
        successfulProperties,
        failedProperties,
        usedCache: cachedMaterials && cachedMaterials.length > 0
      };
      
    } else {
      console.log(" No consumption materials found for item:", itemId);
      return {
        success: false,
        totalMaterials: 0,
        successfulCreations: 0,
        failedCreations: 0,
        successfulProperties: [],
        failedProperties: [],
        usedCache: false,
        reason: 'No consumption materials available'
      };
    }
    
  } catch (error) {
    console.error(" Error in createMaterialsForItem:", error);
    return {
      success: false,
      totalMaterials: 0,
      successfulCreations: 0,
      failedCreations: 0,
      successfulProperties: [],
      failedProperties: [],
      usedCache: false,
      error: error.message
    };
  }
};
const getConsumptionMaterialsFromCache = (itemNo) => {
  try {
    const cacheKey = 'consumptionMaterialsCache';
    const cache = localStorage.getItem(cacheKey);
    
    if (!cache) {
      return null;
    }
    
    const parsedCache = JSON.parse(cache);
    return parsedCache[itemNo]?.consumptionMaterials || null;
  } catch (error) {
    console.error('Error getting consumption materials from cache:', error);
    return null;
  }
};

const storeConsumptionMaterialsInCache = (itemNo, detailedItemId, materials) => {
  try {
    const cacheKey = 'consumptionMaterialsCache';
    const existingCache = JSON.parse(localStorage.getItem(cacheKey) || '{}');
    
    existingCache[itemNo] = {
      consumptionMaterials: materials,
      detailedItemId: detailedItemId,
      cachedAt: new Date().toISOString()
    };
    
    localStorage.setItem(cacheKey, JSON.stringify(existingCache));
  } catch (error) {
    console.error('Error storing consumption materials in cache:', error);
  }
};

const storePageNumberForItem = (itemNo, pageNo) => {
  try {
    const pageCache = JSON.parse(localStorage.getItem('itemPageCache') || '{}');
    pageCache[itemNo] = pageNo;
    localStorage.setItem('itemPageCache', JSON.stringify(pageCache));
  } catch (error) {
    console.error('Error storing page number:', error);
  }
};

const getConsumptionMaterialsCacheStats = () => {
  try {
    const cache = JSON.parse(localStorage.getItem('consumptionMaterialsCache') || '{}');
    const itemsCached = Object.keys(cache).length;
    const materialMappings = Object.values(cache).reduce((total, item) => 
      total + (item.consumptionMaterials?.length || 0), 0);
    
    return { itemsCached, materialMappings };
  } catch (error) {
    return null;
  }
};

  const ensureTokenConsistency = () => {
    const userData = getUserData();
    if (userData.token) {
      // Ensure all token keys have the same value for compatibility
      localStorage.setItem("authToken", userData.token);
      localStorage.setItem("jwt", userData.token);
      localStorage.setItem("userToken", userData.token);
      localStorage.setItem("token", userData.token);
    }
  };
  // Add this function to your MyWork component
  const fetchRevisionDetails = async (revisionId) => {
    if (!token) {
      toast.error("Authentication required");
      return null;
    }

    try {


      // Fetch revision basic data
      const revisionResponse = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/${revisionId}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!revisionResponse.ok) {
        if (revisionResponse.status === 401) {
          toast.error("Session expired. Please login again.");
          localStorage.clear();
          navigate("/signin");
          return null;
        }
        throw new Error(
          `Failed to fetch revision details: ${revisionResponse.status}`
        );
      }

      const revisionData = await revisionResponse.json();
      const revision = Array.isArray(revisionData)
        ? revisionData[0]
        : revisionData;

      // Fetch related data
      const [subestimatesResponse, itemsResponse, measurementsResponse] =
        await Promise.allSettled([
          fetch(`${API_BASE_URL}/api/subestimates/ByRevisionId/${revisionId}`, {
            headers: { Authorization: `Bearer ${token}` },
          }),
          fetch(`${API_BASE_URL}/api/items/ByRevisionId/${revisionId}`, {
            headers: { Authorization: `Bearer ${token}` },
          }),
          fetch(`${API_BASE_URL}/api/measurements/ByRevisionId/${revisionId}`, {
            headers: { Authorization: `Bearer ${token}` },
          }),
        ]);

      // Process subestimates
      let subestimates = [];
      if (
        subestimatesResponse.status === "fulfilled" &&
        subestimatesResponse.value.ok
      ) {
        const subestimatesData = await subestimatesResponse.value.json();
        subestimates = Array.isArray(subestimatesData) ? subestimatesData : [];
      }

      // Process items
      let items = [];
      if (itemsResponse.status === "fulfilled" && itemsResponse.value.ok) {
        const itemsData = await itemsResponse.value.json();
        items = Array.isArray(itemsData) ? itemsData : [];
      }

      // Process measurements
      let measurements = [];
      if (
        measurementsResponse.status === "fulfilled" &&
        measurementsResponse.value.ok
      ) {
        const measurementsData = await measurementsResponse.value.json();
        measurements = Array.isArray(measurementsData) ? measurementsData : [];
      }

      // Return complete revision data
      return {
        ...revision,
        subestimates,
        items,
        measurements,
        totalAmount: revision.totalAmount || 0,
        contingency: revision.contingency || 0,
        labourComponent: revision.labourComponent || 0,
      };
    } catch (err) {
      console.error("Error fetching revision details:", err);
      toast.error("Failed to fetch revision details");
      return null;
    }
  };
  // Keep your existing handleDuplicate function
  // const handleDuplicate = (id, event) => {
  //   // Prevent row click when clicking duplicate button
  //   event.stopPropagation();
  //   setSelectedWorkorderId(id);
  // };
  const handleEditRevision = async (
    workorderId,
    revisionId,
    record,
    revision,
    event
  ) => {
    // Prevent row click when clicking edit button
    event.stopPropagation();

    // Show confirmation dialog
    const confirmed = window.confirm(
      "Are you sure you want to edit this revision?"
    );
    if (!confirmed) return;

    // Check authentication first - following your reference pattern
    if (!token) {
      toast.error("Authentication required. Please login again.");
      return;
    }

    try {
      // Show loading toast
      
const loadingToast = toast.loading(
  <div className="flex items-center">

    Loading revision data...
  </div>
);

      // Clear only specific localStorage keys to avoid conflicts (NOT localStorage.clear())
      const keysToRemove = [
        "recordId",
        "workorderId",
        "reviseId",
        "editMode",
        "reviseno",
        "revisionNumber",
        "currentRevisionNumber",
        "duplicateRevision",
        "edit_nameOfWork",
        "edit_state",
        "edit_department",
        "edit_ssr",
        "edit_area",
        "edit_preparedBy",
        "edit_checkedBy",
        "edit_chapter",
        "nameOfWork",
        "state",
        "department",
        "ssr",
        "area",
        "preparedBy",
        "checkedBy",
        "chapter",
        "autogenerated",
        "status",
        "revisionStage",
        "revisionStatus",
        "isEditMode",
        "editingRevision",
        "currentRevisionId",
        "originalRevisionData",
        "subworkData",
        "revisionItems",
        "revisionMeasurements",
        "revisionDataBySubwork",
        "totalSubworks",
        "totalItems",
        "totalMeasurements",
      ];

      // Remove only the specific keys, preserving authentication and other important data
      keysToRemove.forEach((key) => {
        localStorage.removeItem(key);
      });

      // Store basic revision data first
      localStorage.setItem("recordId", workorderId.toString());
      localStorage.setItem("workorderId", workorderId.toString());
      localStorage.setItem("reviseId", revisionId.toString());
      localStorage.setItem("editMode", "true");
      localStorage.setItem("reviseno", revision.reviseNumber);
      localStorage.setItem("revisionNumber", revision.reviseNumber);
      localStorage.setItem("currentRevisionNumber", revision.reviseNumber);
      localStorage.removeItem("duplicateRevision");

      // Store workorder data (both with and without edit_ prefix)
      if (record) {
        // With edit_ prefix (for form fields)
        localStorage.setItem("edit_nameOfWork", record.nameOfWork || "");
        localStorage.setItem("edit_state", record.state || "");
        localStorage.setItem("edit_department", record.department || "");
        localStorage.setItem("edit_ssr", record.ssr || "");
        localStorage.setItem("edit_area", record.area || "");
        localStorage.setItem(
          "edit_preparedBy",
          record.preparedBySignature || ""
        );
        localStorage.setItem("edit_checkedBy", record.checkedBySignature || "");
        localStorage.setItem(
          "edit_chapter",
          record.chapterId?.toString() || ""
        );

        // Without edit_ prefix (for display/logic)
        localStorage.setItem("nameOfWork", record.nameOfWork || "");
        localStorage.setItem("state", record.state || "");
        localStorage.setItem("department", record.department || "");
        localStorage.setItem("ssr", record.ssr || "");
        localStorage.setItem("area", record.area || "");
        localStorage.setItem("preparedBy", record.preparedBySignature || "");
        localStorage.setItem("checkedBy", record.checkedBySignature || "");
        localStorage.setItem("chapter", record.chapterId?.toString() || "");
        localStorage.setItem("autogenerated", record.workOrderID || "");
        localStorage.setItem("status", record.status || "");
      }

      // Store revision data
      localStorage.setItem(
        "revisionStage",
        revision.revisionStage || "started"
      );
      localStorage.setItem(
        "revisionStatus",
        revision.revisionStatus || "pending"
      );

      // Store user data - get fresh userData and store token consistently
      const userData = getUserData();
      const currentToken = token; // Use the token variable directly like your reference function

      // Store all token variations for compatibility (only if they don't already exist)
      if (!localStorage.getItem("userId"))
        localStorage.setItem("userId", userData?.uid || "");
      if (!localStorage.getItem("userToken"))
        localStorage.setItem("userToken", currentToken);
      if (!localStorage.getItem("jwt"))
        localStorage.setItem("jwt", currentToken);
      if (!localStorage.getItem("Id"))
        localStorage.setItem("Id", userData?.uid || "");
      if (!localStorage.getItem("authToken"))
        localStorage.setItem("authToken", currentToken);
      if (!localStorage.getItem("token"))
        localStorage.setItem("token", currentToken);

      // Store edit mode flags
      localStorage.setItem("isEditMode", "true");
      localStorage.setItem("editingRevision", "true");
      localStorage.setItem("currentRevisionId", revisionId.toString());

      // Store additional metadata
      localStorage.setItem(
        "originalRevisionData",
        JSON.stringify({
          id: revisionId,
          reviseNumber: revision.reviseNumber,
          revisionStage: revision.revisionStage,
          revisionStatus: revision.revisionStatus,
          createdDate: revision.createdDate,
          pdfLocation: revision.pdfLocation || "",
        })
      );

      // Debug token
      console.log(
        "Using token for API calls:",
        currentToken ? "Token exists" : "No token found"
      );

      // Fetch subwork data using the same pattern as your reference function
      const subworkResponse = await fetch(
        `${API_BASE_URL}/api/subwork/${revisionId}/${workorderId}`,
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${currentToken}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!subworkResponse.ok) {
        if (subworkResponse.status === 401) {
          toast.error("Session expired. Please login again.");
          // Don't clear all localStorage here either
          const authKeysToRemove = [
            "userId",
            "userToken",
            "jwt",
            "Id",
            "authToken",
            "token",
          ];
          authKeysToRemove.forEach((key) => localStorage.removeItem(key));
          navigate("/signin");
          return;
        }
        throw new Error(
          `Failed to fetch subwork data: ${subworkResponse.status}`
        );
      }

      const subworkData = await subworkResponse.json();
      console.log("Subwork data:", subworkData);

      // Store subwork data in localStorage
      localStorage.setItem("subworkData", JSON.stringify(subworkData));

      // Initialize arrays to store all items and measurements
      const allItems = [];
      const allMeasurements = [];

      // For each subwork, fetch its items and measurements
      for (const subwork of subworkData) {
        try {
          // Fetch items for this subwork
          const itemsResponse = await fetch(
            `${API_BASE_URL}/api/txn-items/BySubwork/${subwork.id}`,
            {
              method: "GET",
              headers: {
                Authorization: `Bearer ${currentToken}`,
                "Content-Type": "application/json",
              },
            }
          );

          if (itemsResponse.ok) {
            const itemsData = await itemsResponse.json();
            console.log(`Items for subwork ${subwork.id}:`, itemsData);

            // Add subwork reference to each item
            const itemsWithSubwork = itemsData.map((item) => ({
              ...item,
              subworkId: subwork.id,
              subworkName: subwork.subworkName,
            }));

            allItems.push(...itemsWithSubwork);

            // For each item, fetch its measurements
            for (const item of itemsData) {
              try {
                const measurementsResponse = await fetch(
                  `${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`,
                  {
                    method: "GET",
                    headers: {
                      Authorization: `Bearer ${currentToken}`,
                      "Content-Type": "application/json",
                    },
                  }
                );

                if (measurementsResponse.ok) {
                  const measurementsData = await measurementsResponse.json();
                  console.log(
                    `Measurements for item ${item.id}:`,
                    measurementsData
                  );

                  // Add item and subwork reference to each measurement
                  const measurementsWithRef = measurementsData.map(
                    (measurement) => ({
                      ...measurement,
                      itemId: item.id,
                      itemNo: item.itemNo,
                      subworkId: subwork.id,
                      subworkName: subwork.subworkName,
                    })
                  );

                  allMeasurements.push(...measurementsWithRef);
                } else if (measurementsResponse.status === 401) {
                  toast.error("Session expired. Please login again.");
                  const authKeysToRemove = [
                    "userId",
                    "userToken",
                    "jwt",
                    "Id",
                    "authToken",
                    "token",
                  ];
                  authKeysToRemove.forEach((key) =>
                    localStorage.removeItem(key)
                  );
                  navigate("/signin");
                  return;
                } else {
                  console.warn(
                    `Failed to fetch measurements for item ${item.id}:`,
                    measurementsResponse.status
                  );
                }
              } catch (error) {
                console.error(
                  `Error fetching measurements for item ${item.id}:`,
                  error
                );
              }
            }
          } else if (itemsResponse.status === 401) {
            toast.error("Session expired. Please login again.");
            const authKeysToRemove = [
              "userId",
              "userToken",
              "jwt",
              "Id",
              "authToken",
              "token",
            ];
            authKeysToRemove.forEach((key) => localStorage.removeItem(key));
            navigate("/signin");
            return;
          } else {
            console.warn(
              `Failed to fetch items for subwork ${subwork.id}:`,
              itemsResponse.status
            );
          }
        } catch (error) {
          console.error(
            `Error fetching items for subwork ${subwork.id}:`,
            error
          );
        }
      }

      // Store all fetched data in localStorage
      localStorage.setItem("revisionItems", JSON.stringify(allItems));
      localStorage.setItem(
        "revisionMeasurements",
        JSON.stringify(allMeasurements)
      );

      // Store organized data by subwork for easier access
      const dataBySubwork = {};
      subworkData.forEach((subwork) => {
        const subworkItems = allItems.filter(
          (item) => item.subworkId === subwork.id
        );
        const subworkMeasurements = allMeasurements.filter(
          (measurement) => measurement.subworkId === subwork.id
        );

        dataBySubwork[subwork.id] = {
          subwork: subwork,
          items: subworkItems,
          measurements: subworkMeasurements,
        };
      });

      localStorage.setItem(
        "revisionDataBySubwork",
        JSON.stringify(dataBySubwork)
      );

      // Store summary counts
      localStorage.setItem("totalSubworks", subworkData.length.toString());
      localStorage.setItem("totalItems", allItems.length.toString());
      localStorage.setItem(
        "totalMeasurements",
        allMeasurements.length.toString()
      );

      // Dismiss loading toast and show success
      toast.dismiss(loadingToast);
      toast.success(
        `Loaded revision data: ${subworkData.length} subworks, ${allItems.length} items, ${allMeasurements.length} measurements`
      );

      // Navigate to subestimate page for revision editing
      navigate("/subestimate");
    } catch (error) {
      console.error("Error loading revision data:", error);

      // Handle specific error cases
      if (
        error.message.includes("401") ||
        error.message.includes("Unauthorized")
      ) {
        toast.error("Session expired. Please login again.");
        const authKeysToRemove = [
          "userId",
          "userToken",
          "jwt",
          "Id",
          "authToken",
          "token",
        ];
        authKeysToRemove.forEach((key) => localStorage.removeItem(key));
        navigate("/signin");
      } else {
        toast.error("Failed to load revision data. Please try again.");
      }
    }
  };
  {
    /* Editable Name of Work Component */
  }
  const EditableNameOfWork = ({ record, onUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(record.nameOfWork);
  const [isSaving, setIsSaving] = useState(false);
  const [isHovered, setIsHovered] = useState(false);
  const inputRef = useRef(null);

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  const handleDoubleClick = () => {
    setIsEditing(true);
    setEditValue(record.nameOfWork);
  };

  const handleSave = async () => {
    if (editValue.trim() === "" || editValue === record.nameOfWork) {
      setIsEditing(false);
      setEditValue(record.nameOfWork);
      return;
    }

    setIsSaving(true);
    try {
      const success = await onUpdate(record.id, editValue.trim());
      if (success) {
        setIsEditing(false);
      } else {
        setEditValue(record.nameOfWork);
      }
    } catch (error) {
      console.error("Error updating name of work:", error);
      setEditValue(record.nameOfWork);
    } finally {
      setIsSaving(false);
    }
  };
    
  const handleCancel = () => {
    setIsEditing(false);
    setEditValue(record.nameOfWork);
  };


    const handleKeyDown = (e) => {
    if (e.key === "Enter") {
      handleSave();
    } else if (e.key === "Escape") {
      handleCancel();
    }
  };

     if (isEditing) {
    return (
      <div className="flex items-center gap-2 w-full">
        <input
          ref={inputRef}
          type="text"
          value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onKeyDown={handleKeyDown}
          onBlur={handleSave}
          className="flex-1 px-3 py-2 border-2 border-blue-400 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white shadow-sm"
          disabled={isSaving}
          placeholder="Enter work name..."
        />
        <div className="flex gap-1">
          {isSaving ? (
            <div className="flex items-center text-blue-500 text-xs">
              <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-blue-500 mr-1"></div>
              Saving...
            </div>
          ) : (
            <>
              <button
                onClick={handleSave}
                className="p-1 text-green-600 hover:text-green-800 hover:bg-green-50 rounded transition-colors"
                title="Save changes (Enter)"
              >
                
              </button>
              <button
                onClick={handleCancel}
                className="p-1 text-red-600 hover:text-red-800 hover:bg-red-50 rounded transition-colors"
                title="Cancel changes (Escape)"
              >
                
              </button>
            </>
          )}
        </div>
      </div>
    );
  }

   return (
    <div
      onDoubleClick={handleDoubleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      className={`
        relative group cursor-pointer p-2 rounded-md transition-all duration-200 
        ${isHovered 
          ? 'bg-blue-50 border border-blue-200 shadow-sm' 
          : 'hover:bg-gray-50 border border-transparent'
        }
      `}
      title="Double-click to edit"
    >
      {/* Edit icon indicator */}
      <div className="flex items-center justify-between">
        <span className="flex-1 text-gray-800">
          {record.nameOfWork.split(" ").slice(0, 10).join(" ")}
          {record.nameOfWork.split(" ").length > 10 ? "..." : ""}
        </span>
        
        {/* Edit icon that appears on hover */}
        <span 
          className={`
            ml-2 text-blue-500 transition-opacity duration-200 flex-shrink-0
            ${isHovered ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'}
          `}
        >
          <svg 
            width="14" 
            height="14" 
            viewBox="0 0 24 24" 
            fill="none" 
            stroke="currentColor" 
            strokeWidth="2"
          >
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
            <path d="m18.5 2.5 3 3L12 15l-4 1 1-4Z"/>
          </svg>
        </span>
      </div>

      {/* Tooltip-like indicator */}
      {isHovered && (
        <div className="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap z-10">
          Double-click to edit
          <div className="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-800"></div>
        </div>
      )}
    </div>
  );
};

  {
    /* Update function to be added to your component */
  }
  const updateNameOfWork = async (recordId, newNameOfWork) => {
    // Check authentication first - following your reference pattern
    if (!token) {
      toast.error("Authentication required. Please login again.");
      return false;
    }

    try {
      // Get the current record to preserve all other fields
      const currentRecord = records.find((r) => r.id === recordId);
      if (!currentRecord) {
        throw new Error("Record not found");
      }

      // Debug token and current record
      console.log(
        "Using token for API calls:",
        token ? "Token exists" : "No token found"
      );
      console.log("Current record for update:", currentRecord);

      // First, let's get the fresh data from the API to ensure we have all required fields
      const getResponse = await fetch(
        `${API_BASE_URL}/api/workorders/${recordId}`,
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token}`,
            accept: "*/*",
            "Content-Type": "application/json",
          },
        }
      );

      if (!getResponse.ok) {
        if (getResponse.status === 401) {
          toast.error("Session expired. Please login again.");
          const authKeysToRemove = [
            "userId",
            "userToken",
            "jwt",
            "Id",
            "authToken",
            "token",
          ];
          authKeysToRemove.forEach((key) => localStorage.removeItem(key));
          navigate("/signin");
          return false;
        }
        throw new Error(
          `Failed to fetch current record: ${getResponse.status}`
        );
      }

      const freshRecord = await getResponse.json();
      console.log("Fresh record from API:", freshRecord);

      // Prepare the update payload with fresh data and only update nameOfWork
      const updatePayload = {
        id: freshRecord.id,
        workOrderID: freshRecord.workOrderID,
        createdDate: freshRecord.createdDate,
        createdBy: freshRecord.createdBy,
        state: freshRecord.state,
        nameOfWork: newNameOfWork, // Only this field changes
        ssr: freshRecord.ssr,
        area: freshRecord.area,
        chapterId: freshRecord.chapterId,
        preparedBySignature: freshRecord.preparedBySignature,
        checkedBySignature: freshRecord.checkedBySignature,
        status: freshRecord.status,
        department: freshRecord.department,
        deletedFlag: freshRecord.deletedFlag,
        multifloor: freshRecord.multifloor,
        fkSsrId: freshRecord.fkSsrId,
      };

      console.log("Update payload:", updatePayload);

      const response = await fetch(
        `${API_BASE_URL}/api/workorders/${recordId}`,
        {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${token}`,
            accept: "*/*",
            "Content-Type": "application/json",
          },
          body: JSON.stringify(updatePayload),
        }
      );

      if (!response.ok) {
        if (response.status === 401) {
          toast.error("Session expired. Please login again.");
          const authKeysToRemove = [
            "userId",
            "userToken",
            "jwt",
            "Id",
            "authToken",
            "token",
          ];
          authKeysToRemove.forEach((key) => localStorage.removeItem(key));
          navigate("/signin");
          return false;
        }

        // Try to get error details from response
        let errorDetails = "";
        try {
          const errorResponse = await response.text();
          errorDetails = errorResponse;
          console.error("Server error response:", errorDetails);
        } catch (e) {
          console.error("Could not parse error response");
        }

        throw new Error(
          `HTTP error! status: ${response.status}. Details: ${errorDetails}`
        );
      }

      // Update the local state
      setRecords((prevRecords) =>
        prevRecords.map((record) =>
          record.id === recordId
            ? { ...record, nameOfWork: newNameOfWork }
            : record
        )
      );

      // Show success message
      toast.success("Name of work updated successfully");
      return true;
    } catch (error) {
      console.error("Error updating name of work:", error);

      // Handle specific error cases
      if (
        error.message.includes("401") ||
        error.message.includes("Unauthorized")
      ) {
        toast.error("Session expired. Please login again.");
        const authKeysToRemove = [
          "userId",
          "userToken",
          "jwt",
          "Id",
          "authToken",
          "token",
        ];
        authKeysToRemove.forEach((key) => localStorage.removeItem(key));
        navigate("/signin");
      } else if (error.message.includes("500")) {
        toast.error("Server error. Please check the data and try again.");
      } else {
        toast.error("Failed to update name of work. Please try again.");
      }
      return false;
    }
  };

const getFilteredRecords = () => {
  const start = new Date(startDate);
  const end = new Date(endDate);
  end.setHours(23, 59, 59, 999);

  return records.filter((rec) => {
    const recDate = new Date(rec.createdDate);

    // Date filter
    const dateMatch = recDate >= start && recDate <= end;

    // If no search term, only apply date filter
    if (!searchTerm) {
      return dateMatch;
    }

    // Convert search term to lowercase for case-insensitive search
    const searchLower = searchTerm.toLowerCase();

    // Calculate Sr No. (assuming it's based on index like in your table)
    const srNo = records.length - records.indexOf(rec);

    // Search across all fields including workorder ID
    const searchMatch =
      // Sr No.
      srNo.toString().includes(searchLower) ||
      // Work Order ID (Primary search for notification clicks)
      (rec.id && rec.id.toString().includes(searchLower)) ||
      // Estimate ID / Work Order ID
      (rec.workOrderID &&
        rec.workOrderID.toLowerCase().includes(searchLower)) ||
      // Name of Work
      (rec.nameOfWork &&
        rec.nameOfWork.toLowerCase().includes(searchLower)) ||
      // SSR
      (rec.ssr && rec.ssr.toLowerCase().includes(searchLower)) ||
      // Specified Area
      (rec.area && rec.area.toLowerCase().includes(searchLower)) ||
      // Department
      (rec.department &&
        rec.department.toLowerCase().includes(searchLower)) ||
      // Status
      (rec.status && rec.status.toLowerCase().includes(searchLower)) ||
      // Created Date (search in formatted date)
      new Date(rec.createdDate)
        .toLocaleDateString()
        .toLowerCase()
        .includes(searchLower);

    return dateMatch && searchMatch;
  });
};


  const paginatedRecords = () => {
    const filtered = getFilteredRecords();
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;

    return filtered.slice(startIndex, endIndex);
  };

  const totalPages = Math.ceil(getFilteredRecords().length / rowsPerPage);

  // Show loading or authentication error
  if (!token || !uid) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <p className="text-red-500 mb-4">Authentication required</p>
          <button
            onClick={() => navigate("/signin")}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            Go to Login
          </button>
        </div>
      </div>
    );
  }

  return (
    <motion.div
      className="p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.4 }}
    >
      {/* Toast Container */}
      <Toaster
        position="top-right"
        toastOptions={{
          style: {
            background: "white",
            color: "black",
            border: "1px solid #e5e7eb",
            boxShadow:
              "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
          },
          success: {
            style: {
              background: "white",
              color: "#059669",
              border: "1px solid #10b981",
            },
          },
          error: {
            style: {
              background: "white",
              color: "#dc2626",
              border: "1px solid #ef4444",
            },
          },
        }}
      />
      {/* Filter and Search Section */}
      <div className="flex flex-wrap items-center gap-4 mb-4">
        <select
          className="border p-2 rounded"
          value={dateRange}
          onChange={(e) => setDateRange(e.target.value)}
        >
          <option value="1M">Last 30 Days</option>
          <option value="3M">Last 3 Months</option>
          <option value="1Y">Last Year</option>
          <option value="custom">Custom</option>
        </select>
        <input
          type="date"
          className="border p-2 rounded"
          value={startDate}
          onChange={(e) => setStartDate(e.target.value)}
        />
        <input
          type="date"
          className="border p-2 rounded"
          value={endDate}
          onChange={(e) => setEndDate(e.target.value)}
        />
        <div className="flex items-center ml-auto">
          <div className="relative">
            <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400">
              <Search size={18} />
            </span>
            <input
              type="text"
              placeholder="Search work orders..."
              className="border pl-10 pr-3 py-2 rounded"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
        </div>
      </div>
      {/* Loading State */}
     {isLoading && (
  <div className="flex items-center justify-center py-8">
    <LuLoaderCircle className="w-8 h-8 text-orange-500 animate-spin mr-2" />
    <span className="text-orange-500">Loading...</span>
  </div>
)}
      {/* Empty State */}
      {!isLoading && records.length === 0 && (
        <div className="text-center py-12 bg-gray-50 rounded-lg border border-gray-200">
          <FileText size={48} className="mx-auto text-gray-400 mb-3" />
          <h3 className="text-xl font-semibold text-gray-700">
            No  Estimate found
          </h3>
          <p className="text-gray-500 mt-2">
            Create your first estimate by clicking the + button
          </p>
        </div>
      )}
      {/* Main Table */}
      {!isLoading && records.length > 0 && (
        <div className="overflow-x-auto">
          <table className="min-w-full border border-gray-300">
            <thead>
              <tr className="bg-gray-100">
                <th className="px-3 py-2 text-center border-b border-gray-300 font-medium"></th>
                <th className="px-3 py-2 text-center border-b border-gray-300 font-medium">
                  Sr No.
                </th>
                <th className="px-3 py-2 text-left border-b border-gray-300 font-medium">
                  Estimate ID
                </th>
             
  <th className="px-3 py-2 text-left border-b border-gray-300 font-medium relative group">
    Name of Work
    <span className="ml-1 text-blue-500 text-xs opacity-60 group-hover:opacity-100 transition-opacity">
      (editable)
    </span>
  </th>
                <th className="px-3 py-2 text-left border-b border-gray-300 font-medium">
                  SSR
                </th>
                <th className="px-3 py-2 text-left border-b border-gray-300 font-medium">
                  Specified Area
                </th>
                <th className="px-3 py-2 text-left border-b border-gray-300 font-medium">
                  Department
                </th>
                <th className="px-3 py-2 text-center border-b border-gray-300 font-medium">
                  Status
                </th>
                <th className="px-3 py-2 text-center border-b border-gray-300 font-medium">
                  Created Date
                </th>
                <th className="px-3 py-2 text-center border-b border-gray-300 font-medium"></th>
              </tr>
            </thead>
            <tbody>
              {paginatedRecords().map((record, index) => {
                // Use pre-loaded status if available, otherwise calculate from loaded revisions
                const getWorkOrderStatus = (recordId) => {
                  // If we have pre-loaded status, use it
                  if (record.workOrderStatus) {
                    return record.workOrderStatus;
                  }

                  // Fallback to original logic for expanded rows
                  const revisions = subRecords[recordId];

                  if (!revisions || revisions.length === 0) {
                    return "started";
                  }

                  const allRevisionsCompleted = revisions.every(
                    (revision) => revision.pdfLocation
                  );
                  if (allRevisionsCompleted) {
                    return "completed";
                  }

                  const anyRevisionInProgress = revisions.some(
                    (revision) =>
                      !revision.pdfLocation &&
                      (revision.revisionStage === "in-progress" ||
                        revision.revisionStage === "started")
                  );
                  if (anyRevisionInProgress) {
                    return "in-progress";
                  }

                  return "started";
                };
                // Function to get revision status
                const getRevisionStatus = (revision) => {
                  if (revision.pdfLocation) {
                    return "completed";
                  }
                  return revision.revisionStage || "started";
                };

                const workOrderStatus = getWorkOrderStatus(record.id);

                return (
                  <React.Fragment key={record.id}>
                    {/* Main Row */}
                    <tr className="border-b border-gray-200 hover:bg-gray-50 transition-colors">
                      <td className="px-3 py-2 text-center border-r border-gray-200">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleRow(record.id);
                          }}
                          className="text-blue-500 hover:text-blue-700 transition-colors"
                        >
                          {expandedRows[record.id] ? (
                            <span className="font-bold text-lg"></span>
                          ) : (
                            <span className="font-bold text-lg"></span>
                          )}
                        </button>
                      </td>
                      <td className="px-3 py-2 text-center border-r border-gray-200">
                        {records.length - index}
                      </td>
                      <td className="px-3 py-2 text-left border-r border-gray-200">
                        {record.workOrderID}
                      </td>
                      <td className="px-3 py-2 text-left border-r border-gray-200">
                        <EditableNameOfWork
                          record={record}
                          onUpdate={updateNameOfWork}
                        />
                      </td>
                    <td className="px-3 py-2 text-left border-r border-gray-200">
  {(() => {
    // If record has ssrName directly, use it
    if (record.ssrName) {
      return record.ssrName;
    }
    
    // If ssrOptions are loaded, try to get name by ID
    if (ssrOptions && ssrOptions.length > 0 && record.ssr) {
      const ssrName = getSSRNameById(record.ssr);
      if (ssrName) {
        return ssrName;
      }
    }
    
    // Fallback to showing the ID
    return record.ssr || 'N/A';
  })()}
</td>               <td className="px-3 py-2 text-left border-r border-gray-200">
                        <span title={record.area}>
                          {record.area.length > 50
                            ? record.area.substring(0, 50) + "..."
                            : record.area}
                        </span>
                      </td>
                      <td className="px-3 py-2 text-left border-r border-gray-200">
                        {record.department}
                      </td>
                      <td className="px-3 py-2 text-center border-r border-gray-200">
                        <span
                          className={`px-2 py-1 rounded text-sm whitespace-nowrap ${
                            workOrderStatus === "completed"
                              ? "bg-green-100 text-green-800"
                              : workOrderStatus === "in-progress"
                              ? "bg-yellow-100 text-yellow-800"
                              : "bg-gray-100 text-gray-800"
                          }`}
                        >
                          {workOrderStatus}
                        </span>
                      </td>
                      <td className="px-3 py-2 text-center border-r border-gray-200">
                        {new Date(record.createdDate).toLocaleDateString()}
                      </td>
                     
  <td className="px-3 py-2 text-center">
  <div className="flex gap-2 justify-center action-buttons">
    {/* PDF Download Button - Show if workorder has completed revisions */}
    {workOrdersWithPDF[record.id] && (
      <button
        onClick={(e) => {
          e.stopPropagation();
          setSelectedWorkorderForPDF(record.id);
        }}
        className="text-red-500 hover:text-red-700 transition-colors p-1"
        title="Download PDF"
      >
        <FaFilePdf size={16} />
      </button>
    )}
    
    <button
      onClick={(e) => handleDuplicateClick(record.id, e)}
      className="text-blue-500 hover:text-blue-700 transition-colors p-1"
      title="Duplicate"
    >
      <Copy size={16} />
    </button>
    <button
      onClick={(e) => handleDelete(record.id, e)}
      className="text-red-500 hover:text-red-700 transition-colors p-1"
      title="Delete"
    >
      <Trash2 size={16} />
    </button>
  </div>
</td>
                    </tr>

                    {/* Expanded Sub-rows for Revisions */}
                    {expandedRows[record.id] && (
                      <tr>
                        <td colSpan="10" className="p-0">
                          <div className="bg-gray-50 border-t border-gray-200">
                            {subRecords[record.id] === undefined ? (
                              <div className="p-4 text-center text-gray-500">
                                Loading revisions...
                              </div>
                            ) : subRecords[record.id]?.length === 0 ? (
                              <div className="p-4 text-center text-gray-500">
                                No revisions found for this work order.
                              </div>
                            ) : (
                              <table className="w-full">
                                <thead>
                                  <tr className="bg-gray-200">
                                    <th className="px-3 py-2 text-left border-b border-gray-300 font-medium">
                                      Revision No.
                                    </th>
                                    <th className="px-3 py-2 text-left border-b border-gray-300 font-medium">
                                      Name of Work
                                    </th>
                                    <th className="px-3 py-2 text-center border-b border-gray-300 font-medium">
                                      Created Date
                                    </th>
                                    <th className="px-3 py-2 text-center border-b border-gray-300 font-medium">
                                      Stage
                                    </th>
                                    <th className="px-3 py-2 text-center border-b border-gray-300 font-medium"></th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {subRecords[record.id]?.map((revision) => {
                                    const revisionStatus =
                                      getRevisionStatus(revision);

                                    return (
                                      <tr
                                        key={revision.id}
                                        className="border-b border-gray-200 hover:bg-gray-100"
                                      >
                                        <td className="px-3 py-2 text-left border-r border-gray-200">
                                          {revision.reviseNumber}
                                        </td>
                                        <td className="px-3 py-2 text-left border-r border-gray-200">
                                          Revision Of {record.nameOfWork}
                                        </td>
                                        <td className="px-3 py-2 text-center border-r border-gray-200">
                                          {new Date(
                                            revision.createdDate
                                          ).toLocaleDateString()}
                                        </td>
                                        <td className="px-3 py-2 text-center border-r border-gray-200">
                                          <span
                                            className={`px-2 py-1 rounded text-sm whitespace-nowrap ${
                                              revisionStatus === "completed"
                                                ? "bg-green-100 text-green-800"
                                                : revisionStatus ===
                                                  "in-progress"
                                                ? "bg-yellow-100 text-yellow-800"
                                                : "bg-blue-100 text-blue-800"
                                            }`}
                                          >
                                            {revisionStatus}
                                          </span>
                                        </td>
                                        <td className="px-3 py-2 text-center">
                                          <div className="flex gap-2 justify-center action-buttons">
                                            {revision.pdfLocation ? (
                                              <button
                                                onClick={(e) => {
                                                  e.stopPropagation();
                                                  downloadPDF(
                                                    revision.pdfLocation
                                                  );
                                                }}
                                                className="text-red-500 hover:text-red-700 transition-colors p-1"
                                                title="Download PDF"
                                              >
                                                <FaFilePdf size={14} />
                                              </button>
                                            ) : (
                                              <button
                                                onClick={(e) =>
                                                  handleEditRevision(
                                                    record.id,
                                                    revision.id,
                                                    record,
                                                    revision,
                                                    e
                                                  )
                                                }
                                                className="text-blue-500 hover:text-blue-700 transition-colors p-1"
                                                title="Edit Revision"
                                              >
                                                <Edit size={14} />
                                              </button>
                                            )}

                                            <button
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                handleDuplicateRevision(
                                                  record.id,
                                                  revision,
                                                  record
                                                );
                                              }}
                                              className="text-blue-500 hover:text-blue-700 transition-colors p-1"
                                              title="Duplicate Revision"
                                            >
                                              <Copy size={14} />
                                            </button>

                                            <button
                                              onClick={(e) =>
                                                handleDeleteRevision(
                                                  record.id,
                                                  revision.id,
                                                  e
                                                )
                                              }
                                              className="text-red-500 hover:text-red-700 transition-colors p-1"
                                              title="Delete Revision"
                                            >
                                              <Trash2 size={14} />
                                            </button>
                                          </div>
                                        </td>
                                      </tr>
                                    );
                                  })}
                                </tbody>
                              </table>
                            )}
                          </div>
                        </td>
                      </tr>
                    )}
                  </React.Fragment>
                );
              })}
            </tbody>
          </table>
        </div>
      )}
      {/* Pagination */}{!isLoading && records.length > 0 && (
  <div className="flex items-center justify-between mt-4 mb-20">
    <div className="flex items-center gap-2">
      <span className="text-sm text-gray-600">
        Showing {(currentPage - 1) * rowsPerPage + 1} to{" "}
        {Math.min(currentPage * rowsPerPage, getFilteredRecords().length)}{" "}
        of {getFilteredRecords().length} entries
      </span>
    </div>
    <div className="flex items-center gap-2">
      <select
        className="border border-gray-300 p-2 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent bg-white shadow-sm"
        value={rowsPerPage}
        onChange={(e) => {
          setRowsPerPage(Number(e.target.value));
          setCurrentPage(1);
        }}
      >
        <option value={5}>5 per page</option>
        <option value={10}>10 per page</option>
        <option value={20}>20 per page</option>
        <option value={50}>50 per page</option>
      </select>
      <button
        onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
        disabled={currentPage === 1}
        className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 border border-gray-300 shadow-sm"
      >
        Previous
      </button>
      <span className="px-4 py-2 bg-orange-500 text-white rounded-lg font-medium shadow-sm">
        {currentPage}
      </span>
      <button
        onClick={() =>
          setCurrentPage((prev) => Math.min(prev + 1, totalPages))
        }
        disabled={currentPage === totalPages}
        className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 border border-gray-300 shadow-sm"
      >
        Next
      </button>
    </div>
  </div>
)}

{/* Action Buttons with Enhanced Tooltips */}
<div className="fixed bottom-6 right-6 z-50">
  <div className="fixed bottom-6 right-6 z-50">
   <div className="relative group">
    {/* <motion.button
      onClick={handleAddNew}
      className="bg-gradient-to-r from-orange-500 to-orange-600 text-white p-4 rounded-full shadow-xl hover:shadow-2xl transition-all duration-300 hover:scale-105 ring-2 ring-orange-200 hover:ring-orange-300"
      whileHover={{ scale: 1.1 }}
      whileTap={{ scale: 0.9 }}
    >
      <FaPlus size={20} />
    </motion.button> */}
    
    {/* Enhanced Tooltip */}
    <div className="absolute right-full mr-3 top-1/2 transform -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-all duration-300 pointer-events-none">
      <div className="bg-gray-900 text-white px-3 py-2 rounded-lg text-sm font-medium whitespace-nowrap shadow-lg">
        Add New Estimate
        {/* Tooltip Arrow */}
        <div className="absolute left-full top-1/2 transform -translate-y-1/2">
          <div className="w-0 h-0 border-l-4 border-l-gray-900 border-t-4 border-t-transparent border-b-4 border-b-transparent"></div>
        </div>
      </div>
    </div>
  </div>
</div> 

  <div className="relative group">
   
    {/* Enhanced Tooltip */}
    <div className="absolute right-full mr-3 top-1/2 transform -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-all duration-300 pointer-events-none">
      
    </div>
  </div>

  {/* Contact Modal */}
  {isContactModalOpen && (
    <ContactModal
      isOpen={isContactModalOpen}
      onClose={handleCloseModal}
    />
  )}
</div>
      {/* Duplicate Modal */}
      {selectedWorkorderId && (
        <DuplicateModal
          workorderId={selectedWorkorderId}
          onClose={() => setSelectedWorkorderId(null)}
          onDuplicate={handleDuplicate}
          fetchRevisions={fetchRevisions}
          token={token}
          workorderRecord={records.find((r) => r.id === selectedWorkorderId)} // Add this prop
        />
      )}
      {/* PDF Download Modal */}
{selectedWorkorderForPDF && (
  <PDFDownloadModal
    workorderId={selectedWorkorderForPDF}
    onClose={() => setSelectedWorkorderForPDF(null)}
    downloadPDF={downloadPDF}
    workorderRecord={records.find((r) => r.id === selectedWorkorderForPDF)}
  />
)}
    </motion.div>
  );
};

export default MyWork;
