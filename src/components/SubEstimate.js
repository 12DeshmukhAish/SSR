
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { FileText } from 'lucide-react';
import { LuLoaderCircle } from "react-icons/lu";
import { API_BASE_URL} from '../config'; 
import { 
  faChevronRight, 
  faChevronDown, 
  faTrash, 
  faSpinner, 
  faArrowRight,
  faPlus, 
  faSave, 
  faPencilAlt,
  faFileAlt,
  faInfoCircle,
  faSearch,
  faTimes ,
  faEdit,
  faRuler,
  faChevronUp,
  faCheck, faTruck,
  faFile
} from '@fortawesome/free-solid-svg-icons';
import { motion, AnimatePresence } from 'framer-motion';
import toast, { Toaster } from 'react-hot-toast';
import MeasurementTable from './MeasurementTable';
import Stepper from '../components/Stepper';

const SubEstimateForm = () => {
  // State for work order information
  const [itemSearchQuery, setItemSearchQuery] = useState("");
 const [workOrderInfo, setWorkOrderInfo] = useState({
  nameOfWork: '',
  ssr: '',
    ssrName: '',
  area: '',
  status: '',
  autogenerated: '',
  state: '',
  department: '',
  chapterId: '',
  preparedBySignature: '',
  checkedBySignature: '',
  createdDate: '',
  createdBy: '',
  deletedFlag: 0,
  multifloor: 0,
  fkSsrId: 0, // Add this line
  reviseId: '',
  reviseno: '',
  revisionStage: ''
});
 


  // State for subwork management
  const [subworkName, setSubworkName] = useState('');
  const [subworkNameError, setSubworkNameError] = useState(false);
  const [subworks, setSubworks] = useState([]);
const [fkSsrId, setFkSsrId] = useState(0);
const [showNewItemForm, setShowNewItemForm] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const [expandedSubworks, setExpandedSubworks] = useState([]);
  const [searchQueries, setSearchQueries] = useState({}); 
  const [completedRate, setCompletedRate] = useState(0);
  const [currentSubworkForForm, setCurrentSubworkForForm] = useState(null);
 const [workOrderId, setWorkOrderId] = useState(null); // Fix for workOrderId not defined
  const [itemId, setItemId] = useState(null); // Fix for itemId not defined
  const [itemsFromParent, setItemsFromParent] = useState([]); // Fix for itemsFromParent not defined
  const [updatedItems, setUpdatedItems] = useState([]); 
  const [selectedReportType, setSelectedReportType] = useState('');
  const [itemOptionsLoaded, setItemOptionsLoaded] = useState(false);
const [itemOptionsLoading, setItemOptionsLoading] = useState(false);
const [ssrOptions, setSSROptions] = useState([]);
  // State for item management
  const [items, setItems] = useState({});
  const [itemTotalQuantities, setItemTotalQuantities] = useState({});
  const [itemOptions, setItemOptions] = useState([]);
  const [showAddItemModal, setShowAddItemModal] = useState(false);
  const [currentSubworkId, setCurrentSubworkId] = useState(null);
  const [isItemLoading, setIsItemLoading] = useState(false);
 const [currentWorkOrderId, setCurrentWorkOrderId] = useState(null); 
  const [measurementCollapsed, setMeasurementCollapsed] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);
  const [itemFormErrors, setItemFormErrors] = useState({});
  const [visibleMeasurements, setVisibleMeasurements] = useState({});
  // New state to track which row is in editing mode
  const [editingRowId, setEditingRowId] = useState(null);
  const [newItemRow, setNewItemRow] = useState(null);
  const [showItemDetailsModal, setShowItemDetailsModal] = useState(false);
  const [itemDetails, setItemDetails] = useState(null);
const [autoSaveTimeout, setAutoSaveTimeout] = useState(null);
const [regularSandPercentages, setRegularSandPercentages] = useState({});
const [showSandSplitInput, setShowSandSplitInput] = useState({});

const [crushedSandPercentages, setCrushedSandPercentages] = useState({});

  const [isItemDropdownOpen, setIsItemDropdownOpen] = useState(false);
  const [isEditMode, setIsEditMode] = useState(false);
const [editingRevision, setEditingRevision] = useState(false);
const [isDuplicating, setIsDuplicating] = useState(false);
const [subworkData, setSubworkData] = useState([]);
const [itemsData, setItemsData] = useState([]);
const [measurementsData, setMeasurementsData] = useState([]);
const [dataBySubwork, setDataBySubwork] = useState({});
// const [itemSearchQuery, setItemSearchQuery] = useState('');
  const [itemForm, setItemForm] = useState({
    id: 0,
    srNo: 0,
    itemNo: "",
    category: "",
    descriptionOfItem: "",
    floorLiftRise: "Ground floor",
    fkSubworkId: 0,
    fkWorkorderId: 0,
    completedRate: 0,
    labourRate: 0,
    scadaFlag: false,
    smallUnit: "",
    fullUnit: "",
    additionalSpecification: ""
  });
  const [editingItemId, setEditingItemId] = useState(null);

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { 
      opacity: 1,
      transition: { 
        duration: 0.5,
        when: "beforeChildren",
        staggerChildren: 0.1
      }
    }
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 }
  };

  // API base URL
  // const API_BASE_URL = "https://24.101.103.87:8082/api";
  
  // JWT Token from localStorage
   const jwtToken = localStorage.getItem('authToken');

  const navigate = useNavigate();
  const subworkInputRef = useRef(null);
useEffect(() => {
  const fetchSSROptions = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/ssr`, {
        method: 'GET',
        headers: {
          'Accept': '*/*',
          'Authorization': `Bearer ${jwtToken}`
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setSSROptions(data); // Store the complete SSR data
    } catch (err) {
      console.error('Error fetching SSR options:', err);
    }
  };

  if (jwtToken) {
    fetchSSROptions();
  }
}, [jwtToken]);
  // Load work order information from localStorage on component mount
   useEffect(() => {
  const workOrderId = localStorage.getItem('workorderId');
  const reviseId = localStorage.getItem('reviseId');
       
  // First load the basic information from localStorage
 // Update the initial state to include fkSsrId
const initialWorkOrderInfo = {
  workOrderId: workOrderId || '',
  nameOfWork: localStorage.getItem('nameOfWork') || '',
  ssr: localStorage.getItem('ssr') || '',
   ssrName: localStorage.getItem('ssrName') || '',
  area: localStorage.getItem('area') || '',
  status: localStorage.getItem('status') || '',
  revisionStage: localStorage.getItem('revisionStage') || '',
  reviseId: reviseId || '',
  reviseno: localStorage.getItem('reviseno') || '',
  autogenerated: localStorage.getItem('autogenerated') || '',
  
  // Additional complete information
  state: localStorage.getItem('state') || '',
  department: localStorage.getItem('department') || '',
  chapterId: localStorage.getItem('chapterId') || '',
  preparedBySignature: localStorage.getItem('preparedBySignature') || '',
  checkedBySignature: localStorage.getItem('checkedBySignature') || '',
  createdDate: localStorage.getItem('createdDate') || '',
  createdBy: localStorage.getItem('createdBy') || '',
  multifloor: localStorage.getItem('multifloor') || '0',
  fkSsrId: localStorage.getItem('fkSsrId') || '0' // Add this line
};
                   
  // Update state with localStorage values first
  setWorkOrderInfo(initialWorkOrderInfo);
      
      
    
    
    // // Load the data
    // const info = loadWorkOrderInfo();
 const fetchWorkOrderDetails = async () => {
  if (!workOrderId) {
    toast.error('No work order ID found');
    return;
  }
  setIsLoading(true);
  try {
    const response = await fetch(`${API_BASE_URL}/api/workorders/${workOrderId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });
           
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
           
    const data = await response.json();
        const ssrName = getSSRNameById(data.ssr);    
    // Set fkSsrId based on multifloor value
    const fkSsrIdValue = data.multifloor === 1 ? (data.fkSsrId || 1) : 0;
           
    // Update state with complete fresh data from API
    setWorkOrderInfo(prevInfo => ({
      ...prevInfo,
      // Basic work order information
      nameOfWork: data.nameOfWork || prevInfo.nameOfWork,
      ssr: data.ssr || prevInfo.ssr,
        ssrName: ssrName,
      area: data.area || prevInfo.area,
      status: data.status || prevInfo.status,
      autogenerated: data.workOrderID || prevInfo.autogenerated,
      
      // Additional complete information from API
      state: data.state || prevInfo.state,
      department: data.department || prevInfo.department,
      chapterId: data.chapterId || prevInfo.chapterId,
      preparedBySignature: data.preparedBySignature || prevInfo.preparedBySignature,
      checkedBySignature: data.checkedBySignature || prevInfo.checkedBySignature,
      createdDate: data.createdDate || prevInfo.createdDate,
      createdBy: data.createdBy || prevInfo.createdBy,
      deletedFlag: data.deletedFlag || prevInfo.deletedFlag,
      multifloor: data.multifloor || prevInfo.multifloor,
      fkSsrId: fkSsrIdValue, // Add this line
      
      // Keep existing revision info from localStorage
      reviseId: prevInfo.reviseId,
      reviseno: prevInfo.reviseno,
      revisionStage: prevInfo.revisionStage
    }));
           
    // Update localStorage with complete fresh data
    localStorage.setItem('nameOfWork', data.nameOfWork || '');
    localStorage.setItem('ssr', data.ssr || '');
     localStorage.setItem('ssrName', ssrName);
    localStorage.setItem('area', data.area || '');
    localStorage.setItem('status', data.status || '');
    localStorage.setItem('autogenerated', data.workOrderID || '');
    
    // Store additional complete information in localStorage
    localStorage.setItem('state', data.state || '');
    localStorage.setItem('department', data.department || '');
    localStorage.setItem('chapterId', data.chapterId?.toString() || '');
    localStorage.setItem('preparedBySignature', data.preparedBySignature || '');
    localStorage.setItem('checkedBySignature', data.checkedBySignature || '');
    localStorage.setItem('createdDate', data.createdDate || '');
    localStorage.setItem('createdBy', data.createdBy?.toString() || '');
    localStorage.setItem('multifloor', data.multifloor?.toString() || '0');
    localStorage.setItem('fkSsrId', fkSsrIdValue.toString()); // Add this line
    
    // toast.success('Work order details loaded successfully');
  } catch (error) {
    console.error("Error fetching work order details:", error);
    toast.error(`Failed to fetch work order details: ${error.message}`);
  } finally {
    setIsLoading(false);
  }
};
    
    const toggleSubwork = async (subworkId) => {
  const isCurrentlyExpanded = expandedSubworks.includes(subworkId);
    if (!isCurrentlyExpanded) {
    setVisibleMeasurements({});
    // Also hide any open new item forms
    setShowNewItemForm({});
    // Clear any editing state
    setEditingItemId(null);
    resetItemForm();
  }
  setExpandedSubworks(prev => 
    isCurrentlyExpanded
      ? prev.filter(id => id !== subworkId)
      : [...prev, subworkId]
  );
  
  // If expanding and data not loaded, fetch the data
  if (!isCurrentlyExpanded) {
    await handleSubworkExpand(subworkId);
  }
};
const closeAllMeasurements = () => {
  setVisibleMeasurements({});
};

// Function to close all new item forms
const closeAllNewItemForms = () => {
  setShowNewItemForm({});
};
 const onMeasurementDrop = (measurementData) => {
    // Handle measurement drop logic here
  
    // Update your state or perform necessary actions
  };
 const onQuantityUpdate = (itemId, newQuantity) => {
    // Handle quantity update logic here

    
    // Update the items state or perform necessary actions
    setItems(prevItems => ({
      ...prevItems,
      [itemId]: {
        ...prevItems[itemId],
        quantity: newQuantity
      }
    }));
  };
// Update revision status
const updateRevisionStatus = async () => {
  try {
    const reviseId = localStorage.getItem("reviseId");
    const response = await fetch(`${API_BASE_URL}/api/workorder-revisions/${reviseId}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify({ revisionStage: "Inprogress" })
    });

    if (response.ok) {
      localStorage.setItem("revisionStage", "Inprogress");
      setWorkOrderInfo(prev => ({ ...prev, revisionStage: "Inprogress" }));
      
    }
  } catch (error) {
    console.error("Error updating revision status:", error);
  }
};

// Update work order status
const updateWorkOrderStatus = async () => {
  try {
    const workOrderId = localStorage.getItem('workorderId');
    const response = await fetch(`${API_BASE_URL}/api/workorders/${workOrderId}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify({ status: "Progress" })
    });

    if (response.ok) {
      localStorage.setItem("status", "Progress");
      setWorkOrderInfo(prev => ({ ...prev, status: "Progress" }));
     
    }
  } catch (error) {
    console.error("Error updating work order status:", error);
  }
};
  
  // Also fetch current revision details
  const fetchCurrentRevision = async () => {

      if (!reviseId) {

        
        // If no reviseId, try to get the latest revision for this work order
        if (workOrderId) {
          try {
            const response = await fetch(`${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${workOrderId}`, {
              headers: {
                "Authorization": `Bearer ${jwtToken}`,
                "Accept": "*/*"
              }
            });

   if (response.ok) {
              const revisions = await response.json();
              if (Array.isArray(revisions) && revisions.length > 0) {
                // Find the current revision (currentFlag = true) or the latest one
                const currentRevision = revisions.find(rev => rev.currentFlag) || revisions[revisions.length - 1];
            
                if (currentRevision) {
                      
                  setWorkOrderInfo(prevInfo => ({
                    ...prevInfo,
                      reviseId: currentRevision.id.toString(),
                    reviseno: currentRevision.reviseNumber || 'N/A',
                    revisionStage: currentRevision.revisionStage || ''
                  }));

                     localStorage.setItem('reviseId', currentRevision.id.toString());
                  localStorage.setItem('reviseno', currentRevision.reviseNumber || '');
                  localStorage.setItem('revisionStage', currentRevision.revisionStage || '');
                  
            
                    fetchSubworks(currentRevision.id.toString(), workOrderId);
                }
              }
            }
          } catch (error) {
            console.error("Error fetching revisions by work order ID:", error);
          }
        }
        return;
      }
      
       try {
 
        const response = await fetch(`${API_BASE_URL}/api/workorder-revisions/${reviseId}`, {
          headers: {
            "Authorization": `Bearer ${jwtToken}`,
            "Accept": "*/*"
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();  

        // Check if data is an array (some APIs return single object in array) or single object
        const revisionData = Array.isArray(data) ? data[0] : data;
         if (revisionData) {
          const revisionNumber = revisionData.reviseNumber || 'N/A';
          const revisionStage = revisionData.revisionStage || '';
          
        setWorkOrderInfo(prevInfo => {
            const updatedInfo = {
              ...prevInfo,
              reviseno: revisionNumber,
              revisionStage: revisionStage
            };
              
            return updatedInfo;
          });

        // Update localStorage with fresh revision data
  localStorage.setItem('reviseno', revisionNumber);
          localStorage.setItem('revisionStage', revisionStage);
          

        }
        // Fetch subworks after getting revision details
        fetchSubworks(reviseId, workOrderId);
        
      } catch (error) {
        console.error("Error fetching revision details:", error);
        toast.error(`Failed to fetch revision details: ${error.message}`);
      }
  
    };
  

  

    // Run both API calls if we have a work order ID
       if (workOrderId) {
      fetchWorkOrderDetails();
      // Add a small delay to prevent race conditions
      setTimeout(() => {
        fetchCurrentRevision();
      }, 100);
    }

    // Also fetch item options for later use
    fetchItemOptions();
  }, [ssrOptions, workOrderInfo.ssr, workOrderInfo.ssrName]);
  const getSSRNameById = (ssrId) => {
  if (!ssrId || !ssrOptions.length) return ssrId || 'N/A';
  const ssrItem = ssrOptions.find(item => item.ssrId.toString() === ssrId.toString());
  return ssrItem ? ssrItem.ssrName : ssrId; // Return name if found, otherwise return ID
};
// Separate useEffect for SSR options - runs only when ssrOptions changes
useEffect(() => {
  const fetchSSROptions = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/ssr`, {
        method: 'GET',
        headers: {
          'Accept': '*/*',
          'Authorization': `Bearer ${jwtToken}`
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setSSROptions(data);
    } catch (err) {
      console.error('Error fetching SSR options:', err);
    }
  };

  if (jwtToken) {
    fetchSSROptions();
  }
}, [jwtToken]); 
 
  
useEffect(() => {
  const duplicateFromRevisionId = localStorage.getItem("duplicateFromRevisionId");
  const duplicateFromWorkorderId = localStorage.getItem("duplicateFromWorkorderId");
  
  if (duplicateFromRevisionId && duplicateFromWorkorderId) {
    // We're in duplicate mode, fetch and copy data from original revision
    duplicateRevisionData(duplicateFromRevisionId, duplicateFromWorkorderId);
    
    // Clean up flags
    localStorage.removeItem("duplicateFromRevisionId"); 
    localStorage.removeItem("duplicateFromWorkorderId");
  }
}, []);
const duplicateSubwork = async (originalSubwork, newRevisionId, newWorkorderId) => {
  try {
    const subworkPayload = {
      workOrderId: Number(newWorkorderId),
      revisionId: Number(newRevisionId),
      subworkName: originalSubwork.subworkName,
      subworkDescription: originalSubwork.subworkDescription || '',
      createdBy: Number(localStorage.getItem("Id")),
      createdDate: getFormattedDate(),
      updatedBy: Number(localStorage.getItem("Id")),
      updatedDate: getFormattedDate(),
      deletedFlag: "no"
    };

    const subworkResponse = await fetch(`${API_BASE_URL}/api/subwork`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(subworkPayload)
    });

    if (!subworkResponse.ok) {
      throw new Error(`Failed to create subwork: ${originalSubwork.subworkName}`);
    }

    const newSubwork = await subworkResponse.json();
    
    // Fetch and duplicate items for this subwork
    const itemsResponse = await fetch(`${API_BASE_URL}/api/txn-items`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (itemsResponse.ok) {
      const allItems = await itemsResponse.json();
      const originalItems = allItems.filter(item => item.fkSubworkId === originalSubwork.id);
      
      for (const originalItem of originalItems) {
        await duplicateItem(originalItem, newSubwork.id);
      }
    }

  } catch (error) {
    console.error(`Error duplicating subwork ${originalSubwork.subworkName}:`, error);
    throw error;
  }
};

const duplicateRevisionData = async (originalRevisionId, originalWorkorderId) => {
  try {
    toast.loading('Duplicating revision data...', { id: 'duplicate-data' });
    
    // Fetch original subworks
    const subworksResponse = await fetch(`${API_BASE_URL}/api/subwork/${originalRevisionId}/${originalWorkorderId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });
    
    if (!subworksResponse.ok) {
      throw new Error(`Failed to fetch original subworks: ${subworksResponse.status}`);
    }
    
    const originalSubworks = await subworksResponse.json();
    
    if (Array.isArray(originalSubworks) && originalSubworks.length > 0) {
      // Get current revision details
      const currentRevisionId = localStorage.getItem("reviseId");
      const currentWorkorderId = localStorage.getItem("workorderId");
      
      // Duplicate each subwork
      for (const originalSubwork of originalSubworks) {
        await duplicateSubwork(originalSubwork, currentRevisionId, currentWorkorderId);
      }
      
      // Refresh the subworks display
      if (currentRevisionId && currentWorkorderId) {
        await fetchSubworks(currentRevisionId, currentWorkorderId);
      }
      
      // toast.success('Revision data duplicated successfully!', { id: 'duplicate-data' });
    } else {
      toast.info('No subworks found in original revision', { id: 'duplicate-data' });
    }
    
  } catch (error) {
    console.error("Error duplicating revision data:", error);
    toast.error(`Failed to duplicate revision data: ${error.message}`, { id: 'duplicate-data' });
  }
};

const isSandMaterial = (materialName) => {
  if (!materialName) return false;
  const lowerName = materialName.toLowerCase().trim();
  const sandKeywords = ['sand', 'artificial sand'];
  return sandKeywords.some(keyword => lowerName.includes(keyword.toLowerCase()));
};

const isCrushedSandMaterial = (materialName) => {
  if (!materialName) return false;
  const lowerName = materialName.toLowerCase().trim();
  return lowerName.includes('crushed sand');
};

// Check if sand has already been split (one-time check)
const isSandAlreadySplit = (materialName) => {
  if (!materialName) return false;
  const lowerName = materialName.toLowerCase().trim();
  return lowerName.includes('(crushed -') || lowerName.includes('(regular -');
};

// Get the split type for sand materials
const getSandSplitType = (materialName) => {
  if (!materialName) return null;
  
  if (isCrushedSandMaterial(materialName)) {
    return 'crushed_to_regular';
  } else if (isSandMaterial(materialName) && !isCrushedSandMaterial(materialName)) {
    return 'regular_to_crushed';
  }
  
  return null;
};

// Get existing split percentage from material name
const getExistingSplitPercentage = (materialName) => {
  if (!materialName) return null;
  
  const regex = /\((?:crushed|regular)\s*-\s*(\d+(?:\.\d+)?)%\)/i;
  const match = materialName.match(regex);
  
  return match ? parseFloat(match[1]) : null;
};
const handleSandPercentageChange = (propertyId, percentage, splitType) => {
  // Handle empty string input explicitly - allow it
  if (percentage === '' || percentage === null || percentage === undefined) {
    if (splitType === 'regular_to_crushed') {
      setCrushedSandPercentages(prev => ({
        ...prev,
        [propertyId]: '' // Explicitly set to empty string
      }));
    } else if (splitType === 'crushed_to_regular') {
      setRegularSandPercentages(prev => ({
        ...prev,
        [propertyId]: '' // Explicitly set to empty string
      }));
    }
    return; // Don't show toast for empty values
  }
  
  const numPercentage = parseFloat(percentage);
  
  // Check for invalid input only for non-empty values
  if (isNaN(numPercentage) || numPercentage < 0 || numPercentage > 100) {
    toast.warning('Sand percentage should be between 0-100%');
    return;
  }
  
  if (splitType === 'regular_to_crushed') {
    setCrushedSandPercentages(prev => ({
      ...prev,
      [propertyId]: percentage // Store as string to preserve decimal input
    }));
  } else if (splitType === 'crushed_to_regular') {
    setRegularSandPercentages(prev => ({
      ...prev,
      [propertyId]: percentage // Store as string to preserve decimal input
    }));
  }
};

const calculateRemainingSandPercentage = (propertyId, splitType) => {
  if (splitType === 'regular_to_crushed') {
    const crushedPercentage = crushedSandPercentages[propertyId] || 0;
    return 100 - crushedPercentage;
  } else if (splitType === 'crushed_to_regular') {
    const regularPercentage = regularSandPercentages[propertyId] || 0;
    return 100 - regularPercentage;
  }
  return 0;
};
// Function to save crushed sand entries
const saveSandEntries = async (property, percentage, splitType) => {
  if (!property || !percentage || percentage <= 0) return;

  try {
    const originalConstant = parseFloat(property.materialConstant) || 0;
    let primaryConstant, secondaryConstant, primaryMaterial, secondaryMaterial;

    if (splitType === 'regular_to_crushed') {
      primaryConstant = (originalConstant * percentage) / 100;
      secondaryConstant = (originalConstant * (100 - percentage)) / 100;
      primaryMaterial = `CRUSHED SAND (crushed - ${percentage}%)`;
      secondaryMaterial = `SAND (regular - ${100 - percentage}%)`;
    } else if (splitType === 'crushed_to_regular') {
      primaryConstant = (originalConstant * percentage) / 100;
      secondaryConstant = (originalConstant * (100 - percentage)) / 100;
      primaryMaterial = `SAND (regular - ${percentage}%)`;
      secondaryMaterial = `CRUSHED SAND (crushed - ${100 - percentage}%)`;
    }

    const primarySandData = {
      txnItemId: property.txnItemId,
      material: primaryMaterial,
      materialConstant: primaryConstant,
      materialUnit: property.materialUnit || "Unit"
    };

    const secondarySandData = {
      ...property,
      material: secondaryMaterial,
      materialConstant: secondaryConstant
    };

    // Execute API calls in parallel
    const [primaryResponse, updatedResponse] = await Promise.all([
      fetch(`${API_BASE_URL}/api/txn-item-properties`, {
        method: 'POST',
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(primarySandData)
      }),
      fetch(`${API_BASE_URL}/api/txn-item-properties/${property.id}`, {
        method: 'PUT',
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(secondarySandData)
      })
    ]);

    if (primaryResponse.ok && updatedResponse.ok) {
      const newProperty = await primaryResponse.json();
      
      // CRITICAL: Update state immediately with optimistic updates
      setItemDetails(prev => {
        const updatedProperties = prev.itemProperties.map(prop => 
          prop.id === property.id 
            ? { ...prop, material: secondaryMaterial, materialConstant: secondaryConstant }
            : prop
        );
        
        // Add new property
        updatedProperties.push(newProperty);
        
        return {
          ...prev,
          itemProperties: updatedProperties
        };
      });

      // Clear input states
      setShowSandSplitInput(prev => ({
        ...prev,
        [property.id]: false
      }));

      setCrushedSandPercentages(prev => ({
        ...prev,
        [property.id]: ''
      }));
      
      setRegularSandPercentages(prev => ({
        ...prev,
        [property.id]: ''
      }));

      toast.success('Sand entries split successfully!');

      // Optional: Refresh properties from server after a short delay for data consistency
      setTimeout(() => {
        refreshItemPropertiesOnly(property.txnItemId);
      }, 1000);

    } else {
      throw new Error(`Failed to save: Primary ${primaryResponse.status}, Secondary ${updatedResponse.status}`);
    }

  } catch (error) {
    console.error('Error saving sand entries:', error);
    toast.error(`Failed to save sand entries: ${error.message}`);
  }
};


const updateExistingSandSplit = async (property, newPercentage, splitType) => {
  try {
    const allProperties = itemDetails.itemProperties || [];
    const currentMaterial = property.material.toLowerCase();
    
    let complementaryProperty = null;
    let totalOriginalConstant = 0;
    
    // Find complementary property
    if (currentMaterial.includes('crushed')) {
      complementaryProperty = allProperties.find(p => 
        p.id !== property.id && 
        p.material.toLowerCase().includes('sand') && 
        p.material.toLowerCase().includes('regular')
      );
    } else if (currentMaterial.includes('regular')) {
      complementaryProperty = allProperties.find(p => 
        p.id !== property.id && 
        p.material.toLowerCase().includes('crushed sand')
      );
    }
    
    if (complementaryProperty) {
      totalOriginalConstant = parseFloat(property.materialConstant) + parseFloat(complementaryProperty.materialConstant);
    } else {
      const currentPercentage = getExistingSplitPercentage(property.material) || 100;
      totalOriginalConstant = parseFloat(property.materialConstant) / (currentPercentage / 100);
    }

    const newConstant = (totalOriginalConstant * newPercentage) / 100;
    const complementaryPercentage = 100 - newPercentage;
    const complementaryConstant = (totalOriginalConstant * complementaryPercentage) / 100;

    let newMaterialName, complementaryMaterialName;
    
    if (splitType === 'regular_to_crushed') {
      newMaterialName = `CRUSHED SAND (crushed - ${newPercentage}%)`;
      complementaryMaterialName = `SAND (regular - ${complementaryPercentage}%)`;
    } else if (splitType === 'crushed_to_regular') {
      newMaterialName = `SAND (regular - ${newPercentage}%)`;
      complementaryMaterialName = `CRUSHED SAND (crushed - ${complementaryPercentage}%)`;
    }

    const updatedData = {
      ...property,
      material: newMaterialName,
      materialConstant: newConstant
    };

    const promises = [
      fetch(`${API_BASE_URL}/api/txn-item-properties/${property.id}`, {
        method: 'PUT',
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updatedData)
      })
    ];

    if (complementaryProperty) {
      const complementaryData = {
        ...complementaryProperty,
        material: complementaryMaterialName,
        materialConstant: complementaryConstant
      };

      promises.push(
        fetch(`${API_BASE_URL}/api/txn-item-properties/${complementaryProperty.id}`, {
          method: 'PUT',
          headers: {
            "Authorization": `Bearer ${jwtToken}`,
            "Accept": "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(complementaryData)
        })
      );
    }

    const responses = await Promise.all(promises);
    
    if (responses.every(response => response.ok)) {
      // CRITICAL: Optimistic update - immediately update state
      setItemDetails(prev => {
        const updatedProperties = prev.itemProperties.map(prop => {
          if (prop.id === property.id) {
            return { ...prop, material: newMaterialName, materialConstant: newConstant };
          } else if (complementaryProperty && prop.id === complementaryProperty.id) {
            return { ...prop, material: complementaryMaterialName, materialConstant: complementaryConstant };
          }
          return prop;
        });
        
        return {
          ...prev,
          itemProperties: updatedProperties
        };
      });

      // Clear input states
      setShowSandSplitInput(prev => ({
        ...prev,
        [property.id]: false
      }));

      setCrushedSandPercentages(prev => ({
        ...prev,
        [property.id]: ''
      }));
      
      setRegularSandPercentages(prev => ({
        ...prev,
        [property.id]: ''
      }));

      toast.success('Sand split percentage updated successfully!');

      // Optional: Sync with server after short delay
      setTimeout(() => {
        refreshItemPropertiesOnly(property.txnItemId);
      }, 1000);

    } else {
      throw new Error(`Update failed: ${responses.map(r => r.status).join(', ')}`);
    }

  } catch (error) {
    console.error('Error updating sand split:', error);
    toast.error(`Failed to update sand percentage: ${error.message}`);
  }
};
const handleSandSplitSave = (e,property, percentage, splitType) => {
  // Prevent any form submission or page navigation
  e.preventDefault?.();
  
  const isAlreadySplit = isSandAlreadySplit(property.material);
  const hasBeenSplit = itemDetails.itemProperties.some(prop => 
    prop.id !== property.id && 
    ((property.material.toLowerCase().includes('sand') && !property.material.toLowerCase().includes('crushed') && 
      prop.material.toLowerCase().includes('crushed') && prop.material.toLowerCase().includes('(crushed -')) ||
     (property.material.toLowerCase().includes('crushed sand') && 
      prop.material.toLowerCase().includes('sand') && prop.material.toLowerCase().includes('(regular -')))
  );

  if (isAlreadySplit || hasBeenSplit) {
    updateExistingSandSplit(property, percentage, splitType);
  } else {
    saveSandEntries(property, percentage, splitType);
  }
};

// Add this function to duplicate a single item with its measurements
const duplicateItem = async (originalItem, newSubworkId) => {
  try {
    // Create new item
    const itemPayload = {
      itemNo: originalItem.itemNo,
      category: originalItem.category,
      descriptionOfItem: originalItem.descriptionOfItem,
      unitId: originalItem.unitId,
      rate: originalItem.rate,
      fkSubworkId: newSubworkId,
      createdBy: parseInt(localStorage.getItem("Id") || "92"),
      createdDate: new Date().toISOString(),
      updatedBy: parseInt(localStorage.getItem("Id") || "92"),
      updatedDate: new Date().toISOString(),
      deletedFlag: "no"
    };
    
    const itemResponse = await fetch(`${API_BASE_URL}/api/txn-items`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(itemPayload)
    });
    
    if (!itemResponse.ok) {
      throw new Error(`Failed to create item: ${itemResponse.status}`);
    }
    
    const newItem = await itemResponse.json();
    const newItemId = newItem.id;
    
    // Fetch original measurements for this item
    const measurementsResponse = await fetch(`${API_BASE_URL}/api/measurements/item/${originalItem.id}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });
    
    if (measurementsResponse.ok) {
      const originalMeasurements = await measurementsResponse.json();
      
      // Duplicate each measurement
      for (const originalMeasurement of originalMeasurements) {
        await duplicateMeasurement(originalMeasurement, newItemId);
      }
    }
    
  } catch (error) {
    console.error(`Error duplicating item ${originalItem.itemNo}:`, error);
    throw error;
  }
};

// Add this function to duplicate a single measurement
const duplicateMeasurement = async (originalMeasurement, newItemId) => {
  try {
    const measurementPayload = {
      sNo: originalMeasurement.sNo,
      description: originalMeasurement.description,
      length: originalMeasurement.length,
      breadth: originalMeasurement.breadth,
      height: originalMeasurement.height,
      nos: originalMeasurement.nos,
      fkItemId: newItemId,
      createdBy: parseInt(localStorage.getItem("Id")),
      createdDate: new Date().toISOString(),
      updatedBy: parseInt(localStorage.getItem("Id")),
      updatedDate: new Date().toISOString(),
      deletedFlag: "no"
    };
    
    const measurementResponse = await fetch(`${API_BASE_URL}/api/measurements`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(measurementPayload)
    });
    
    if (!measurementResponse.ok) {
      throw new Error(`Failed to create measurement: ${measurementResponse.status}`);
    }
    
  } catch (error) {
    console.error(`Error duplicating measurement:`, error);
    throw error;
  }
};

 
const fetchAndCopySubworksFromOriginal = async (originalWorkOrderId, originalRevisionId) => {
  try {
    toast.loading('Loading original subworks and items...', { id: 'duplicate-load' });
    
    // Fetch original subworks
    const subworksResponse = await fetch(`${API_BASE_URL}/api/subwork/${originalRevisionId}/${originalWorkOrderId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (!subworksResponse.ok) {
      throw new Error('Failed to fetch original subworks');
    }

    const originalSubworks = await subworksResponse.json();
    
    if (!Array.isArray(originalSubworks) || originalSubworks.length === 0) {
      toast.dismiss('duplicate-load');
      toast.info('No subworks found in original work order');
      return;
    }

    // Get current work order and revision IDs
    const currentWorkOrderId = localStorage.getItem("workorderId");
    const currentRevisionId = localStorage.getItem("reviseId");
    
    if (!currentWorkOrderId || !currentRevisionId) {
      throw new Error('Current work order or revision ID not found');
    }

    // Copy each subwork and its items
    for (const originalSubwork of originalSubworks) {
      await copySubworkWithItems(originalSubwork, currentWorkOrderId, currentRevisionId);
    }

    // Refresh the subworks list
    await fetchSubworks(currentRevisionId, currentWorkOrderId);
    
    toast.dismiss('duplicate-load');
    toast.success('Successfully copied all subworks and items from original work order!');
    
  } catch (error) {
    console.error('Error copying from original work order:', error);
    toast.dismiss('duplicate-load');
    toast.error(`Failed to copy original data: ${error.message}`);
  }
};
const copySubworkWithItems = async (originalSubwork, newWorkOrderId, newRevisionId) => {
  try {
    // Create new subwork
    const subworkPayload = {
      workOrderId: Number(newWorkOrderId),
      revisionId: Number(newRevisionId),
      subworkName: originalSubwork.subworkName,
      subworkDescription: originalSubwork.subworkDescription || '',
      createdBy: Number(localStorage.getItem("Id")),
      createdDate: getFormattedDate(),
      updatedBy: Number(localStorage.getItem("Id")),
      updatedDate: getFormattedDate(),
      deletedFlag: "no"
    };

    const subworkResponse = await fetch(`${API_BASE_URL}/api/subwork`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(subworkPayload)
    });

    if (!subworkResponse.ok) {
      throw new Error(`Failed to create subwork: ${originalSubwork.subworkName}`);
    }

    const newSubwork = await subworkResponse.json();
    
    // Fetch items for the original subwork
    const itemsResponse = await fetch(`${API_BASE_URL}/api/txn-items`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (itemsResponse.ok) {
      const allItems = await itemsResponse.json();
      const originalItems = allItems.filter(item => item.fkSubworkId === originalSubwork.id);
      
      // Copy each item to the new subwork
      for (const originalItem of originalItems) {
        await copyItemWithMeasurements(originalItem, newSubwork.id);
      }
    }

  } catch (error) {
    console.error(`Error copying subwork ${originalSubwork.subworkName}:`, error);
    throw error;
  }
};const copyItemWithMeasurements = async (originalItem, newSubworkId) => {
  try {
   
    
    const itemPayload = {
      itemNo: originalItem.itemNo,
      category: originalItem.category,
      descriptionOfItem: originalItem.descriptionOfItem,
      unitId: originalItem.unitId,
      rate: originalItem.rate,
      fkSubworkId: newSubworkId,
      fkWorkorderId: originalItem.fkWorkorderId,
      completedRate: originalItem.completedRate || 0,
      labourRate: originalItem.labourRate || 0,
      scadaFlag: originalItem.scadaFlag || false,
      smallUnit: originalItem.smallUnit || "",
      fullUnit: originalItem.fullUnit || "",
      additionalSpecification: originalItem.additionalSpecification || "",
      floorLiftRise: originalItem.floorLiftRise || "Ground floor",
      detailedItemId: originalItem.detailedItemId,
      createdBy: parseInt(localStorage.getItem("Id") || "92"),
      createdDate: new Date().toISOString(),
      updatedBy: parseInt(localStorage.getItem("Id") || "92"),
      updatedDate: new Date().toISOString(),
      deletedFlag: "no"
    };

    const itemResponse = await fetch(`${API_BASE_URL}/api/txn-items`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(itemPayload)
    });

    if (!itemResponse.ok) {
      throw new Error(`Failed to create item: ${itemResponse.status}`);
    }

    const newItem = await itemResponse.json();
   
    
    // *** COPY BOTH MEASUREMENTS AND MATERIALS ***
    await Promise.all([
      copyMeasurementsForItem(originalItem.id, newItem.id),
      copyMaterialsForItem(originalItem, newItem)
    ]);

  } catch (error) {
    console.error(`Error copying item ${originalItem.itemNo}:`, error);
    throw error;
  }
};
const copyMaterialsForItem = async (originalItem, newItem) => {
  try {
  
    
    // First, try to fetch existing materials from the original item
    const existingMaterialsResponse = await fetch(`${API_BASE_URL}/api/txn-item-properties/serchByTxnItemId/${originalItem.id}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "application/json"
      }
    });

    let materialsCopied = false;

    if (existingMaterialsResponse.ok) {
      const existingMaterials = await existingMaterialsResponse.json();
      
      if (Array.isArray(existingMaterials) && existingMaterials.length > 0) {
    
        
        // Copy existing materials
        for (const material of existingMaterials) {
          const materialPayload = {
            txnItemId: newItem.id,
            material: material.material,
            materialConstant: material.materialConstant,
            materialUnit: material.materialUnit || "Unit"
          };

          await fetch(`${API_BASE_URL}/api/txn-item-properties`, {
            method: 'POST',
            headers: {
              "Authorization": `Bearer ${jwtToken}`,
              "Accept": "application/json",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(materialPayload)
          });
        }
        
        materialsCopied = true;
    
      }
    }

    // If no existing materials were found or copied, create new ones from consumption materials
    if (!materialsCopied) {
      
      
      const materialCreationResult = await createMaterialsForItem(newItem.id, originalItem);
      
      if (materialCreationResult.success) {
        console.log(`✓ Created ${materialCreationResult.successfulCreations} new materials from consumption data`);
      } else {
        console.log(`⚠️ No materials created: ${materialCreationResult.reason || 'Unknown reason'}`);
      }
    }

  } catch (error) {
    console.error(`Error copying materials for item ${originalItem.itemNo}:`, error);
    // Don't throw error for materials - continue with other items
  }
};

const copyMeasurementsForItem = async (originalItemId, newItemId) => {
  try {
    // Fetch original measurements
    const measurementsResponse = await fetch(`${API_BASE_URL}/api/txn-measurements/ByItemId/${originalItemId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (!measurementsResponse.ok) {
      // No measurements found - this is okay
      return;
    }

    const originalMeasurements = await measurementsResponse.json();
    
    if (!Array.isArray(originalMeasurements) || originalMeasurements.length === 0) {
      return;
    }

    // Copy each measurement
    for (const originalMeasurement of originalMeasurements) {
      const measurementPayload = {
        fkItemId: Number(newItemId),
        subParticulars: originalMeasurement.subParticulars,
        nos: originalMeasurement.nos,
        length: originalMeasurement.length,
        breadth: originalMeasurement.breadth,
        height: originalMeasurement.height,
        quantity: originalMeasurement.quantity,
        createdBy: Number(localStorage.getItem("Id")),
        createdDate: getFormattedDate(),
        updatedBy: Number(localStorage.getItem("Id")),
        updatedDate: getFormattedDate(),
        deletedFlag: "no"
      };

      await fetch(`${API_BASE_URL}/api/txn-measurements`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${jwtToken}`
        },
        body: JSON.stringify(measurementPayload)
      });
    }

  } catch (error) {
    console.error(`Error copying measurements for item ${originalItemId}:`, error);
    // Don't throw error for measurements - continue with other items
  }
};
  // Function to fetch revisions
  const fetchRevisions = async (workOrderId) => {
    if (!workOrderId) return;

    try {
      const response = await fetch(
        `${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${workOrderId}`,
        {
          headers: {
            Authorization: `Bearer ${jwtToken}`,
            Accept: '*/*',
          },
        }
      );

      if (!response.ok) throw new Error(`Error: ${response.status}`);

      const allRevisions = await response.json();

      const uniqueSorted = [...new Set(
        allRevisions
          .filter((rev) => rev.deletedFlag.toLowerCase() !== 'yes')
          .map((rev) => rev.reviseNumber)
      )].sort((a, b) => parseFloat(a) - parseFloat(b));

      console.log("Valid revisions:", uniqueSorted);
      // toast.success(`Revision List: ${uniqueSorted.join(', ')}`);

    } catch (err) {
      console.error('Failed to fetch revisions:', err);
      toast.error('Error loading revision history.');
    }
  };
  

  // Format date for API calls
  const getFormattedDate = () => {
    const now = new Date();
    
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    
    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
  };
  

  // Fetch existing subworks
const fetchSubworks = async (reviseId, workOrderId) => {
  if (!reviseId || !workOrderId) {
    console.error("Missing reviseId or workOrderId for fetchSubworks", { reviseId, workOrderId });
    return;
  }

  setIsLoading(true);
  try {

    const response = await fetch(`${API_BASE_URL}/api/subwork/${reviseId}/${workOrderId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const data = await response.json();
    if (Array.isArray(data)) {
     
      setSubworks(data);
      
      // After getting subworks, fetch items and measurements for each subwork
      const itemPromises = data.map(subwork => fetchItemsWithMeasurements(subwork.id));
      await Promise.all(itemPromises);
      
     
    } else {
      console.error("Unexpected response format. Expected an array but got:", data);
      toast.error('Failed to load subworks data');
    }
  } catch (error) {
    console.error("Error fetching subworks:", error);
    toast.error(`Error loading subworks: ${error.message}`);
  } finally {
    setIsLoading(false);
  }
};
const handleSubworkNameChange = (e) => {
  const value = e.target.value;
  setSubworkName(value);
  
  // Clear any previous errors
  if (subworkNameError) {
    setSubworkNameError(false);
  }
};

const validateSubworkForm = () => {
  if (!subworkName?.trim()) {
    setSubworkNameError(true);
    toast.error("Please enter subwork name");
    return false;
  }
  
  return true;
};
  const fetchItemsForSubwork = async (subworkId) => {
  try {

    
    const response = await fetch(`${API_BASE_URL}/api/txn-items`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const allItems = await response.json();
    const subworkItems = allItems.filter(item => item.fkSubworkId === subworkId);
    
    if (Array.isArray(subworkItems)) {
     
      
      // Update the items state
      setItems(prevItems => ({
        ...prevItems,
        [subworkId]: subworkItems
      }));
      
      // Cache items and fetch measurements for each item
      updateSubRecordCache(subworkId, subworkItems);
      
      // Load measurements for each item
      for (const item of subworkItems) {
        await fetchMeasurementsForItem(item.id);
      }
    }
  } catch (error) {
    console.error(`Error fetching items for subwork ${subworkId}:`, error);
    toast.error(`Failed to load items for subwork`);
  }
};
// Enhanced function to fetch subworks with all their data
const fetchSubworksWithData = async (reviseId, workOrderId) => {
  if (!reviseId || !workOrderId) {
    console.error("Missing reviseId or workOrderId for fetchSubworks", { reviseId, workOrderId });
    return;
  }

  try {
   
    
    const response = await fetch(`${API_BASE_URL}/api/subwork/${reviseId}/${workOrderId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const subworksData = await response.json();
    
    if (Array.isArray(subworksData)) {
    
      setSubworks(subworksData);

      // For each subwork, fetch its items and measurements
      const dataFetchPromises = subworksData.map(async (subwork) => {
        await fetchItemsWithMeasurements(subwork.id);
        return subwork.id;
      });

      await Promise.all(dataFetchPromises);
      

    } else {
      console.error("Unexpected response format. Expected an array but got:", subworksData);
      toast.error('Failed to load subworks data');
    }
  } catch (error) {
    console.error("Error fetching subworks:", error);
    throw error;
  }
};
// Fetch latest revision if reviseId is not available
const fetchLatestRevision = async (workOrderId) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/workorder-revisions/ByWorkorderId/${workOrderId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (response.ok) {
      const revisions = await response.json();
      if (Array.isArray(revisions) && revisions.length > 0) {
        // Find the current revision or the latest one
        const currentRevision = revisions.find(rev => rev.currentFlag) || revisions[revisions.length - 1];

        if (currentRevision) {
          const reviseId = currentRevision.id.toString();
          
          // Update localStorage
          localStorage.setItem('reviseId', reviseId);
          localStorage.setItem('reviseno', currentRevision.reviseNumber || '');
          localStorage.setItem('revisionStage', currentRevision.revisionStage || '');

          // Update state
          setWorkOrderInfo(prevInfo => ({
            ...prevInfo,
            reviseId: reviseId,
            reviseno: currentRevision.reviseNumber || 'N/A',
            revisionStage: currentRevision.revisionStage || ''
          }));

          // Now initialize with the found revision
          await initializePageData(workOrderId, reviseId);
        }
      }
    }
  } catch (error) {
    console.error("Error fetching latest revision:", error);
    toast.error("Failed to fetch revision information");
  }
};

// Fetch revision details
const fetchRevisionDetails = async (reviseId) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/workorder-revisions/${reviseId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const data = await response.json();
    const revisionData = Array.isArray(data) ? data[0] : data;

    if (revisionData) {
      setWorkOrderInfo(prevInfo => ({
        ...prevInfo,
        reviseno: revisionData.reviseNumber || 'N/A',
        revisionStage: revisionData.revisionStage || ''
      }));

      // Update localStorage
      localStorage.setItem('reviseno', revisionData.reviseNumber || '');
      localStorage.setItem('revisionStage', revisionData.revisionStage || '');
    }


  } catch (error) {
    console.error("Error fetching revision details:", error);
    throw error;
  }
};
// Main function to initialize all page data
const initializePageData = async (workOrderId, reviseId) => {
  setIsLoading(true);
  
  try {
    // Fetch work order details
    await fetchWorkOrderDetails(workOrderId);
    
    // Fetch revision details
    await fetchRevisionDetails(reviseId);
    
    // Fetch subworks and their items/measurements
    await fetchSubworksWithData(reviseId, workOrderId);
    
    // toast.success('Data loaded successfully');
  } catch (error) {
    console.error('Error initializing page data:', error);
    toast.error('Failed to load page data');
  } finally {
    setIsLoading(false);
  }
};

// Fetch work order details
const fetchWorkOrderDetails = async () => {
  if (!workOrderId) {
    toast.error('No work order ID found');
    return;
  }
  setIsLoading(true);
  try {
    const response = await fetch(`${API_BASE_URL}/api/workorders/${workOrderId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });
           
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
           
    const data = await response.json();
     const ssrName = getSSRNameById(data.ssr);
    // Determine fkSsrId based on multifloor value
    const fkSsrIdValue = data.multifloor === 1 ? (data.fkSsrId || 1) : 0;
           
    // Update state with complete fresh data from API
    setWorkOrderInfo(prevInfo => ({
      ...prevInfo,
      // Basic work order information
      nameOfWork: data.nameOfWork || prevInfo.nameOfWork,
      ssr: data.ssr || prevInfo.ssr,
       ssrName: ssrName,
      area: data.area || prevInfo.area,
      status: data.status || prevInfo.status,
      autogenerated: data.workOrderID || prevInfo.autogenerated,
      
      // Additional complete information from API
      state: data.state || prevInfo.state,
      department: data.department || prevInfo.department,
      chapterId: data.chapterId || prevInfo.chapterId,
      preparedBySignature: data.preparedBySignature || prevInfo.preparedBySignature,
      checkedBySignature: data.checkedBySignature || prevInfo.checkedBySignature,
      createdDate: data.createdDate || prevInfo.createdDate,
      createdBy: data.createdBy || prevInfo.createdBy,
      deletedFlag: data.deletedFlag || prevInfo.deletedFlag,
      multifloor: data.multifloor || prevInfo.multifloor,
      fkSsrId: fkSsrIdValue, // Add this line
      
      // Keep existing revision info from localStorage
      reviseId: prevInfo.reviseId,
      reviseno: prevInfo.reviseno,
      revisionStage: prevInfo.revisionStage
    }));
           
    // Update localStorage with complete fresh data
    localStorage.setItem('nameOfWork', data.nameOfWork || '');
    localStorage.setItem('ssr', data.ssr || '');
      localStorage.setItem('ssrName', ssrName); 
    localStorage.setItem('area', data.area || '');
    localStorage.setItem('status', data.status || '');
    localStorage.setItem('autogenerated', data.workOrderID || '');
    
    // Store additional complete information in localStorage
    localStorage.setItem('state', data.state || '');
    localStorage.setItem('department', data.department || '');
    localStorage.setItem('chapterId', data.chapterId?.toString() || '');
    localStorage.setItem('preparedBySignature', data.preparedBySignature || '');
    localStorage.setItem('checkedBySignature', data.checkedBySignature || '');
    localStorage.setItem('createdDate', data.createdDate || '');
    localStorage.setItem('createdBy', data.createdBy?.toString() || '');
    localStorage.setItem('multifloor', data.multifloor?.toString() || '0');
    localStorage.setItem('fkSsrId', fkSsrIdValue.toString()); // Add this line
    
    toast.success('Work order details loaded successfully');
  } catch (error) {
    console.error("Error fetching work order details:", error);
    toast.error(`Failed to fetch work order details: ${error.message}`);
  } finally {
    setIsLoading(false);
  }
};
  const updateSubRecordCache = (subworkId, itemsData) => {
    try {
      const cacheKey = `subwork_items_${subworkId}`;
      localStorage.setItem(cacheKey, JSON.stringify(itemsData));
   
    } catch (error) {
      console.error('Error caching subwork items:', error);
    }
  };
 const getSubRecordCache = (subworkId) => {
    try {
      const cacheKey = `subwork_items_${subworkId}`;
      const cachedData = localStorage.getItem(cacheKey);
      if (cachedData) {
        return JSON.parse(cachedData);
      }
    } catch (error) {
      console.error('Error reading subwork items cache:', error);
    }
    return [];
  };
   const clearSubRecordCache = (subworkId) => {
    try {
      const cacheKey = `subwork_items_${subworkId}`;
      localStorage.removeItem(cacheKey);
    } catch (error) {
      console.error('Error clearing subwork items cache:', error);
    }
  };

  const handleSearchChange = (subworkId, query) => {
    setSearchQueries((prev) => ({
      ...prev,
      [subworkId]: query.toLowerCase(),
    }));
  };
  const storePageNumberForItem = (itemNo, pageNo) => {
  try {
    const pageNumbers = JSON.parse(localStorage.getItem('itemPageNumbers')) || {};
    pageNumbers[itemNo] = pageNo;
    localStorage.setItem('itemPageNumbers', JSON.stringify(pageNumbers));
   
  } catch (error) {
    console.warn("Error storing page number:", error);
  }
};

// Helper function to get page number from localStorage
const getPageNumberForItem = (itemNo) => {
  try {
    const pageNumbers = JSON.parse(localStorage.getItem('itemPageNumbers')) || {};
    return pageNumbers[itemNo] || null;
  } catch (error) {
    console.warn("Error retrieving page number:", error);
    return null;
  }
};
  // Fetch item options for dropdown
 const fetchItemOptions = async () => {
  // Prevent multiple simultaneous calls
  if (itemOptionsLoading || itemOptionsLoaded) {
    // console.log("Item options already loaded or loading");
    return;
  }

  try {
    setItemOptionsLoading(true);
    setIsItemLoading(true);
    // console.log("Fetching item options from API...");
    
    const response = await fetch(`${API_BASE_URL}/api/master/detailedItems`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*",
        "Cache-Control": "no-cache"
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const data = await response.json();
    
    if (Array.isArray(data) && data.length > 0) {
      setItemOptions(data);
      setItemOptionsLoaded(true); // Mark as loaded
      // console.log("Item options loaded successfully:", data.length);
      
      // Store page numbers for all items in localStorage
      try {
        const pageNumbers = {};
        data.forEach(item => {
          if (item.ssrItemId && item.pageNo) {
            pageNumbers[item.ssrItemId] = item.pageNo;
          }
        });
        localStorage.setItem('itemPageNumbers', JSON.stringify(pageNumbers));
        // console.log(`Stored page numbers for ${Object.keys(pageNumbers).length} items`);
      } catch (e) {
        // console.warn("Could not store page numbers:", e);
      }
    } else {
      // console.warn("No item options received from API");
      toast.warning('No item options available');
      setItemOptionsLoaded(true); // Still mark as loaded to prevent retries
    }
    
  } catch (error) {
    // console.error("Error fetching item options:", error);
    toast.error(`Error loading item options: ${error.message}`);
    // Don't mark as loaded on error, allow retry
    
  } finally {
    setItemOptionsLoading(false);
    setIsItemLoading(false);
  }
};
useEffect(() => {
  // Initialize fkSsrId from localStorage if available
  const storedFkSsrId = localStorage.getItem('fkSsrId');
  if (storedFkSsrId) {
    setFkSsrId(parseInt(storedFkSsrId) || 0);
  }

  // Load item options only once when component mounts
  if (jwtToken && !itemOptionsLoaded && !itemOptionsLoading) {
    fetchItemOptions();
  }
}, [jwtToken]);
const refreshItemOptions = async () => {
  setItemOptionsLoaded(false);
  setItemOptions([]);
  await fetchItemOptions();
};
const saveItemProperties = async (itemId, consumptionMaterials) => {
  try {
    // Prevent saving if we don't have valid data
    if (!itemId || !Array.isArray(consumptionMaterials) || consumptionMaterials.length === 0) {
      console.warn("Cannot save item properties: invalid data provided");
      return [];
    }

    // console.log(`Saving ${consumptionMaterials.length} properties for item ${itemId}`);

    // First try using the fromConsumption API with ID instead of itemNo
    try {
      const detailedItemId = consumptionMaterials[0].id || consumptionMaterials[0].detailedItemId || consumptionMaterials[0].ssrItemId;
      
      const fromConsumptionResponse = await fetch(
        `${API_BASE_URL}/api/txn-item-properties/fromConsumption?detailsItemId=${detailedItemId}&txtItemId=${itemId}`,
        {
          method: 'POST',
          headers: {
            "Authorization": `Bearer ${jwtToken}`,
            "Accept": "*/*",
            "Content-Type": "application/json"
          }
        }
      );

      if (fromConsumptionResponse.ok) {
        const response = await fromConsumptionResponse.json();
        // console.log("Properties saved via fromConsumption API:", response);
        toast.success(`Saved ${consumptionMaterials.length} material properties`);
        return response;
      } else {
        // console.warn(`fromConsumption API failed with status: ${fromConsumptionResponse.status}`);
        throw new Error(`API responded with status: ${fromConsumptionResponse.status}`);
      }
    } catch (apiError) {
      console.warn("fromConsumption API failed, falling back to manual save:", apiError);
    }
     
    // Prepare properties to save manually if the API failed
    const propertiesToSave = consumptionMaterials.map(material => ({
      id: 0,  // New record
      txnItemId: itemId,
      material: material.materialName,
      materialConstant: material.constant,
      materialUnit: material.materialUnit
    }));

    console.log("Saving item properties manually:", propertiesToSave);
    
    // Save each property
    const savePromises = propertiesToSave.map(async (property) => {
      const response = await fetch(`${API_BASE_URL}/api/txn-item-properties`, {
        method: 'POST',
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Content-Type": "application/json", 
          "Accept": "*/*"
        },
        body: JSON.stringify(property)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error("API error response:", errorText);
        throw new Error(`Failed to save property: ${response.status}`);
      }
      
      return await response.json();
    });
    
    const results = await Promise.all(savePromises);
    // console.log("Property save results:", results);
    toast.success(`Saved ${results.length} material properties`);
    return results;
    
  } catch (error) {
    console.error("Error saving item properties:", error);
    toast.error(`Failed to save material properties: ${error.message}`);
    throw error;
  }
};
const renderLoadingState = () => {
  if (itemOptionsLoading && !itemOptionsLoaded) {
    return (
      <div className="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-orange-600 mx-auto mb-4"></div>
          <p className="text-lg font-medium text-gray-700">Loading Item Options...</p>
          <p className="text-sm text-gray-500 mt-2">Please wait while we fetch the latest data</p>
        </div>
      </div>
    );
  }
  return null;
};
const fetchItemsWithMeasurements = async (subworkId) => {
  try {
    

    // Fetch all items for this subwork
    const itemsResponse = await fetch(`${API_BASE_URL}/api/txn-items`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (!itemsResponse.ok) {
      throw new Error(`HTTP error! Status: ${itemsResponse.status}`);
    }

    const allItems = await itemsResponse.json();
    const subworkItems = allItems.filter(item => item.fkSubworkId === subworkId);

    if (Array.isArray(subworkItems)) {


      // Update the items state
      setItems(prevItems => ({
        ...prevItems,
        [subworkId]: subworkItems
      }));

      // For each item, fetch its measurements
      const measurementPromises = subworkItems.map(async (item) => {
        try {
          // Fetch measurements for this item using the correct API endpoint
          const measurementResponse = await fetch(`${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`, {
            headers: {
              "Authorization": `Bearer ${jwtToken}`,
              "Accept": "*/*"
            }
          });

          if (!measurementResponse.ok) {
            console.warn(`Failed to fetch measurements for item ${item.id}`);
            return [];
          }

          const measurements = await measurementResponse.json();
          
          if (Array.isArray(measurements)) {
            // Calculate total quantity for this item
            const totalQuantity = measurements.reduce((sum, measurement) => {
              const quantity = parseFloat(measurement.quantity) || 0;
              return sum + quantity;
            }, 0);

            // Update itemTotalQuantities state
            setItemTotalQuantities(prev => ({
              ...prev,
              [item.id]: totalQuantity
            }));

    
            return measurements;
          }

          return [];
        } catch (error) {
          console.error(`Error fetching measurements for item ${item.id}:`, error);
          return [];
        }
      });

      await Promise.all(measurementPromises);
  
    }
  } catch (error) {
    console.error(`Error fetching items for subwork ${subworkId}:`, error);
    throw error;
  }
};
const viewItemDetails = async (item) => {
  try {
    // Show loading state immediately
    setIsLoading(true);
    setItemDetails({ ...item });
    setShowItemDetailsModal(true);
    
    // Initialize combined details with base item data
    let combinedDetails = { ...item };
    let detailedItemId = null;
    
    // Check cache for consumption materials but always fetch fresh data too
    let cachedConsumptionMaterials = getConsumptionMaterialsFromCache(item.itemNo);
    
    // Parallel API calls for better performance
    const apiCalls = [];
    
    // 1. Fetch base transaction item data
    apiCalls.push(
      fetch(`${API_BASE_URL}/api/txn-items/${item.id}`, {
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Accept": "application/json"
        }
      }).then(response => ({ type: 'item', response }))
    );
    
    // 2. Find detailed item from master data (synchronous operation)
    try {
      const detailedItem = itemOptions.find(opt => opt.ssrItemId === item.itemNo);
      
      if (detailedItem) {
        
        detailedItemId = detailedItem.detailedItemId;
        
        // Store page number in localStorage when found (item cache - keeping this)
        if (detailedItem.pageNo) {
          storePageNumberForItem(item.itemNo, detailedItem.pageNo);
        }
        
        // Merge detailed item information
        combinedDetails = {
          ...combinedDetails,
          description: detailedItem.description || combinedDetails.descriptionOfItem || "N/A",
          pageNo: detailedItem.pageNo || "N/A",
          additionalSpecification: detailedItem.additionalSpecification || "N/A",
          smallUnit: detailedItem.smallUnit || "N/A",
          fullUnit: detailedItem.fullUnit || "N/A",
          completedRate: detailedItem.completedRate || 0,
          labourRate: detailedItem.labourRate || 0,
          scadaFlag: detailedItem.scadaFlag || false,
          category: detailedItem.category || "N/A",
          chapterName: detailedItem.chapterName || "N/A",
          referenceNo: detailedItem.referenceNo || "N/A",
          detailedItemId: detailedItemId
        };
        
        // ALWAYS fetch consumption materials from API when detailedItemId exists
        // This ensures we get the latest data even if cache exists
        if (detailedItemId) {
          apiCalls.push(
            fetch(`${API_BASE_URL}/api/master/consumptionMaterialAndRoad/getDetailedItemId?detailedItemId=${detailedItemId}`, {
              headers: {
                "Authorization": `Bearer ${jwtToken}`,
                "Accept": "*/*"
              }
            }).then(response => ({ type: 'materials', response, detailedItemId }))
          );
        }
      } else {
        console.warn(`No detailed item found for itemNo: ${item.itemNo}`);
      }
    } catch (detailError) {
      console.warn("Error finding detailed item:", detailError);
    }
    
    // 3. Add existing transaction item properties API call
    apiCalls.push(
      fetch(`${API_BASE_URL}/api/txn-item-properties/serchByTxnItemId/${item.id}`, {
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Accept": "application/json"
        }
      }).then(response => ({ type: 'properties', response }))
    );
    
    // Execute all API calls in parallel
    const results = await Promise.allSettled(apiCalls);
    
    // Process API results
    let existingProperties = [];
    let consumptionMaterials = cachedConsumptionMaterials || []; // Start with cached data as fallback
    
    for (const result of results) {
      if (result.status === 'fulfilled') {
        const { type, response, detailedItemId: apiDetailedItemId } = result.value;
        
        try {
          if (response.ok) {
            const data = await response.json();
            
            switch (type) {
              case 'item':
                combinedDetails = { ...combinedDetails, ...data };
                break;
                
              case 'materials':
                // FIXED: Always prioritize fresh API data over cache
                const freshMaterials = Array.isArray(data) ? data : [];
                const validMaterials = freshMaterials.filter(mat => 
                  mat.materialName && mat.fkMaterialId && mat.fkMaterialId > 0
                );
                
                // Always update with fresh data (even if empty)
                consumptionMaterials = validMaterials;
                
                // Update cache with fresh data for future use
                if (validMaterials.length > 0) {
                  storeConsumptionMaterialsInCache(item.itemNo, apiDetailedItemId, validMaterials);
                  console.log("✓ Updated cache with fresh consumption materials:", validMaterials.length);
                } else {
                  // If API returns empty, clear the cache to reflect current state
                  clearConsumptionMaterialsFromCache(item.itemNo);
                  console.log("✓ Cleared cache as API returned no materials");
                }
                break;
                
              case 'properties':
                console.log("Existing transaction item properties:", data);
                existingProperties = Array.isArray(data) ? data : [];
                break;
            }
          } else {
            console.warn(`API call failed for ${type}:`, response.status, response.statusText);
            if (type === 'materials') {
              // On API failure, use cached data if available
              if (cachedConsumptionMaterials && cachedConsumptionMaterials.length > 0) {
                consumptionMaterials = cachedConsumptionMaterials;
                console.log("Using cached materials due to API failure");
              } else {
                consumptionMaterials = [];
              }
            } else if (type === 'properties') {
              existingProperties = [];
            }
          }
        } catch (parseError) {
          console.warn(`Error parsing ${type} response:`, parseError);
          if (type === 'materials') {
            // On parsing error, fallback to cached data if available
            if (cachedConsumptionMaterials && cachedConsumptionMaterials.length > 0) {
              consumptionMaterials = cachedConsumptionMaterials;
              console.log("Using cached materials due to parsing error");
            } else {
              consumptionMaterials = [];
            }
          } else if (type === 'properties') {
            existingProperties = [];
          }
        }
      } else {
        console.warn("API call rejected:", result.reason);
        // For materials API failure, use cache as fallback
        if (result.reason && result.reason.toString().includes('materials')) {
          if (cachedConsumptionMaterials && cachedConsumptionMaterials.length > 0) {
            consumptionMaterials = cachedConsumptionMaterials;
            console.log("Using cached materials due to API rejection");
          }
        }
      }
    }
    
    // Add consumption materials to combined details
    combinedDetails.consumptionMaterials = consumptionMaterials;
    
    // 4. Handle transaction item properties - Enhanced logic with better error handling
    if (existingProperties.length > 0) {
      // If properties already exist, use them
      combinedDetails.itemProperties = existingProperties;
      combinedDetails.propertiesStatus = 'existing';
      console.log("Using existing item properties:", existingProperties.length);
      toast.success(`Found ${existingProperties.length} existing properties`);
    } else if (consumptionMaterials.length > 0) {
      // Create properties from consumption materials if none exist
      try {
        console.log("Creating transaction item properties from consumption materials...");
        console.log("Consumption materials to process:", consumptionMaterials);
        
        // Show intermediate status
        combinedDetails.propertiesStatus = 'creating';
        combinedDetails.itemProperties = []; // Initialize as empty during creation
        setItemDetails({...combinedDetails}); // Update UI to show creation in progress
        
        const propertyCreationPromises = consumptionMaterials.map(async (material, index) => {
          // Validate material data before creating property
          if (!material.materialName || material.constant === null || material.constant === undefined) {
            console.warn(`Invalid material data at index ${index}:`, material);
            return null;
          }
          
          // FIXED: Remove the id field entirely since it's auto-generated
          const propertyData = {
            txnItemId: item.id,
            material: material.materialName.trim(),
            materialConstant: parseFloat(material.constant) || 0,
            materialUnit: material.materialUnit ? material.materialUnit.trim() : "Unit"
          };
          
          console.log(`Creating property ${index + 1}:`, propertyData);
          
          try {
            const createResponse = await fetch(`${API_BASE_URL}/api/txn-item-properties`, {
              method: 'POST',
              headers: {
                "Authorization": `Bearer ${jwtToken}`,
                "Accept": "application/json",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(propertyData)
            });
            
            if (createResponse.ok) {
              const createdProperty = await createResponse.json();
              console.log(`Successfully created property ${index + 1}:`, createdProperty);
              return createdProperty;
            } else {
              // Get detailed error information
              let errorDetails = '';
              try {
                const errorResponse = await createResponse.json();
                errorDetails = errorResponse.message || errorResponse.error || createResponse.statusText;
              } catch {
                errorDetails = await createResponse.text() || createResponse.statusText;
              }
              
              console.error(`Failed to create property for material ${material.materialName}:`, {
                status: createResponse.status,
                statusText: createResponse.statusText,
                errorDetails: errorDetails,
                requestData: propertyData
              });
              
              return {
                error: true,
                material: material.materialName,
                errorDetails: errorDetails,
                status: createResponse.status
              };
            }
          } catch (createError) {
            console.error(`Network error creating property for material ${material.materialName}:`, createError);
            return {
              error: true,
              material: material.materialName,
              errorDetails: createError.message,
              networkError: true
            };
          }
        });
        
        const createdPropertiesResults = await Promise.allSettled(propertyCreationPromises);
        const successfulProperties = [];
        const failedProperties = [];
        
        createdPropertiesResults.forEach((result, index) => {
          if (result.status === 'fulfilled' && result.value !== null) {
            if (result.value.error) {
              failedProperties.push({
                material: result.value.material,
                error: result.value.errorDetails,
                index: index + 1
              });
            } else {
              successfulProperties.push(result.value);
            }
          } else {
            failedProperties.push({
              material: consumptionMaterials[index]?.materialName || `Material ${index + 1}`,
              error: result.reason?.message || 'Unknown error',
              index: index + 1
            });
          }
        });
        
        // Update status and handle results
        if (successfulProperties.length > 0) {
          // FIXED: Wait a moment before refreshing to ensure database consistency
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Fetch the latest properties to ensure data consistency
          try {
            const refreshedProperties = await refreshItemPropertiesOnly(item.id);
            combinedDetails.itemProperties = refreshedProperties;
            combinedDetails.propertiesStatus = 'created';
            
            if (failedProperties.length > 0) {
              console.warn("Failed properties:", failedProperties);
              toast.warning(`Created ${successfulProperties.length} properties successfully. ${failedProperties.length} failed.`);
              
              // Log detailed failure information
              failedProperties.forEach(failure => {
                console.error(`Property creation failed for ${failure.material}:`, failure.error);
              });
            } else {
              toast.success(`Successfully created ${successfulProperties.length} item properties`);
            }
          } catch (refreshError) {
            console.warn("Error refreshing properties after creation:", refreshError);
            combinedDetails.itemProperties = successfulProperties;
            combinedDetails.propertiesStatus = 'created_partial';
            toast.warning("Properties created but refresh failed. Please refresh manually.");
          }
        } else {
          combinedDetails.itemProperties = [];
          combinedDetails.propertiesStatus = 'failed';
          console.error("Failed to create any item properties");
          
          // Show detailed error information
          if (failedProperties.length > 0) {
            const errorSummary = failedProperties.map(f => `${f.material}: ${f.error}`).join('; ');
            console.error("Creation failures summary:", errorSummary);
            toast.error(`Failed to create properties. Errors: ${errorSummary.substring(0, 100)}...`);
          } else {
            toast.error("Failed to create item properties from consumption materials");
          }
        }
        
      } catch (createPropertiesError) {
        console.error("Error creating properties from consumption materials:", createPropertiesError);
        combinedDetails.itemProperties = [];
        combinedDetails.propertiesStatus = 'error';
        toast.error(`Error occurred while creating item properties: ${createPropertiesError.message}`);
      }
    } else {
      // No existing properties and no consumption materials
      combinedDetails.itemProperties = [];
      combinedDetails.propertiesStatus = 'none';
    }
    
    // Update the item details with all collected information
    setItemDetails(combinedDetails);
    
  } catch (error) {
    console.error("Error in viewItemDetails:", error);
    toast.error(`Failed to load item details: ${error.message}`);
  } finally {
    setIsLoading(false);
  }
};

// Helper function to clear cache (add this if not already present)
const clearConsumptionMaterialsFromCache = (itemNo) => {
  try {
    const cacheKey = `consumptionMaterials_${itemNo}`;
    localStorage.removeItem(cacheKey);
    console.log(`Cache cleared for item: ${itemNo}`);
  } catch (error) {
    console.warn("Error clearing cache:", error);
  }
};
const preloadConsumptionMaterials = async () => {
  try {

    
    
    if (typeof itemOptions !== 'undefined' && Array.isArray(itemOptions)) {
      const itemsToPreload = itemOptions.filter(item => item.detailedItemId && !getConsumptionMaterialsFromCache(item.ssrItemId));
   
      
      // Process in batches to avoid overwhelming the server
      const batchSize = 10;
      for (let i = 0; i < itemsToPreload.length; i += batchSize) {
        const batch = itemsToPreload.slice(i, i + batchSize);
        
        const promises = batch.map(async (item) => {
          try {
            const response = await fetch(`${API_BASE_URL}/api/master/consumptionMaterialAndRoad/getDetailedItemId?detailedItemId=${item.detailedItemId}`, {
              headers: {
                "Authorization": `Bearer ${jwtToken}`,
                "Accept": "*/*"
              }
            });
            
            if (response.ok) {
              const materials = await response.json();
              if (Array.isArray(materials) && materials.length > 0) {
                storeConsumptionMaterialsInCache(item.ssrItemId, item.detailedItemId, materials);
              }
            }
          } catch (error) {
            console.warn(`Failed to preload materials for ${item.ssrItemId}:`, error);
          }
        });
        
        await Promise.allSettled(promises);
        
        // Small delay between batches
        if (i + batchSize < itemsToPreload.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
 
      getConsumptionMaterialsCacheStats();
    }
  } catch (error) {
    console.error("Error preloading consumption materials:", error);
  }
};
// Add these functions inside your SubEstimateForm component, after your existing state declarations

// Function to handle measurement drop
const onMeasurementDrop = useCallback((measurementData) => {
  // Handle the measurement drop logic here

  
  // You can add your specific logic here based on what you need to do when measurements are dropped
  // For example, updating state, making API calls, etc.
  
  // Basic implementation - you can modify this based on your requirements
  try {
    // Update measurements data if needed
    setMeasurementsData(prevData => {
      // Add or update measurement data
      return [...prevData, measurementData];
    });
    
    // Show success message
    toast.success('Measurement updated successfully');
  } catch (error) {
    console.error('Error handling measurement drop:', error);
    toast.error('Failed to update measurement');
  }
}, []);

// Function to handle quantity updates
const onQuantityUpdate = useCallback((itemId, newQuantity) => {
  // Handle quantity update logic here

  
  // Basic implementation - you can modify this based on your requirements
  try {
    // Update item total quantities
    setItemTotalQuantities(prevQuantities => ({
      ...prevQuantities,
      [itemId]: newQuantity
    }));
    
    // Update items data if needed
    setItemsData(prevItems => 
      prevItems.map(item => 
        item.id === itemId 
          ? { ...item, totalQuantity: newQuantity }
          : item
      )
    );
    
    // Auto-save functionality (if you have auto-save timeout set up)
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }
    
    const newTimeout = setTimeout(() => {
      // Add your auto-save logic here
      
    }, 1000); // Save after 1 second of inactivity
    
    setAutoSaveTimeout(newTimeout);
    
  } catch (error) {
    console.error('Error updating quantity:', error);
    toast.error('Failed to update quantity');
  }
}, [autoSaveTimeout]);

// Don't forget to clear the timeout when component unmounts
useEffect(() => {
  return () => {
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }
  };
}, [autoSaveTimeout]);
// Enhanced refresh function with better error handling and retry mechanism
const refreshItemPropertiesOnly = async (txnItemId, retryCount = 0) => {
  const maxRetries = 2;
  
  try {
    const response = await fetch(`${API_BASE_URL}/api/txn-item-properties/serchByTxnItemId/${txnItemId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "application/json"
      }
    });

    if (response.ok) {
      const properties = await response.json();
      const propertiesArray = Array.isArray(properties) ? properties : [];
      
      // ONLY update the itemProperties in state - NO full refresh
      setItemDetails(prev => ({
        ...prev,
        itemProperties: propertiesArray,
        propertiesStatus: propertiesArray.length > 0 ? 'existing' : 'none'
      }));
      
      return propertiesArray;
    } else if (retryCount < maxRetries - 1) {
      await new Promise(resolve => setTimeout(resolve, 800));
      return refreshItemPropertiesOnly(txnItemId, retryCount + 1);
    } else {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
  } catch (error) {
    console.error("Error refreshing properties:", error);
    if (retryCount < maxRetries - 1) {
      await new Promise(resolve => setTimeout(resolve, 800));
      return refreshItemPropertiesOnly(txnItemId, retryCount + 1);
    }
    toast.error(`Failed to refresh properties: ${error.message}`);
    return [];
  }
};

// const refreshItemProperties = async (itemId) => {
//   try {
//     const response = await fetch(`${API_BASE_URL}/txn-item-properties/byTxnItem/${itemId}`, {
//       headers: {
//         "Authorization": `Bearer ${jwtToken}`,
//         "Accept": "application/json"
//       }
//     });
    
//     if (response.ok) {
//       const properties = await response.json();
//       console.log("Refreshed item properties:", properties);
      
//       // Update the current item details with fresh properties
//       setItemDetails(prevDetails => ({
//         ...prevDetails,
//         itemProperties: Array.isArray(properties) ? properties : []
//       }));
      
//       return properties;
//     } else {
//       console.warn("Failed to refresh properties:", response.status, response.statusText);
//       return [];
//     }
//   } catch (error) {
//     console.warn("Error refreshing item properties:", error);
//     return [];
//   }
// };
const syncConsumptionMaterialsToProperties = async (itemId, consumptionMaterials) => {
  if (!consumptionMaterials || consumptionMaterials.length === 0) {
    toast.info("No consumption materials to sync");
    return [];
  }
  
  try {
   
    
    const syncPromises = consumptionMaterials.map(async (material, index) => {
      const propertyData = {
        id: 0,
        txnItemId: itemId,
        material: material.materialName || `Material ${index + 1}`,
        materialConstant: parseFloat(material.constant) || 0,
        materialUnit: material.materialUnit || "Unit"
      };
      
      const response = await fetch(`${API_BASE_URL}/api/txn-item-properties`, {
        method: 'POST',
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(propertyData)
      });
      
      if (response.ok) {
        return await response.json();
      } else {
        console.warn(`Failed to sync material: ${material.materialName}`, response.status);
        return null;
      }
    });
    
    const results = await Promise.allSettled(syncPromises);
    const successful = results
      .filter(result => result.status === 'fulfilled' && result.value !== null)
      .map(result => result.value);
 
    
    if (successful.length > 0) {
      toast.success(`Successfully synced ${successful.length} materials to properties`);
      // Refresh the properties to get the latest data
      await refreshItemPropertiesOnly(itemId);
    } else {
      toast.error("Failed to sync any materials to properties");
    }
    
    return successful;
  } catch (error) {
    console.error("Error syncing materials to properties:", error);
    toast.error("Error occurred while syncing materials");
    return [];
  }
};
/**
 * Enhanced function to show measurement table for item
 * @param {string|number} itemId - The ID of the item to show measurements for
 */
const showMeasurementTable = (itemId) => {
  if (!itemId) {
    console.warn("Invalid itemId provided to showMeasurementTable");
    return;
  }
  
  setVisibleMeasurements((prev) => ({
    ...prev,
    [itemId]: true
  }));
  
 
};

/**
 * Helper function to hide measurement table for item
 * @param {string|number} itemId - The ID of the item to hide measurements for
 */
const hideMeasurementTable = (itemId) => {
  if (!itemId) {
    console.warn("Invalid itemId provided to hideMeasurementTable");
    return;
  }
  
  setVisibleMeasurements((prev) => ({
    ...prev,
    [itemId]: false
  }));
  
  
};

/**
 * Helper function to toggle measurement table visibility
 * @param {string|number} itemId - The ID of the item to toggle measurements for
 */
const toggleMeasurementTable = (itemId) => {
  if (!itemId) {
    console.warn("Invalid itemId provided to toggleMeasurementTable");
    return;
  }
  
  setVisibleMeasurements((prev) => ({
    ...prev,
    [itemId]: !prev[itemId]
  }));
  
 
};


    const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-IN', {
        style: 'currency',
        currency: 'INR',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(amount);
};
// Add new subwork
 const addSubwork = async () => {
  if (!validateSubworkForm()) {
    return;
  }

  // Validation
  if (!subworkName.trim()) {
    setSubworkNameError(true);
    toast.error('Please enter a subestimate name', {
      icon: '⚠️',
    });
    subworkInputRef.current?.focus();
    return;
  }

  setIsLoading(true);
  const loadingToast = toast.loading('Creating subestimate...');
  
  try {
    const userId = localStorage.getItem("id"); // Default ID if not found
    const currentDate = getFormattedDate();
    
    // Fixed payload - removed the 'id' field since it's auto-increment
    const subworkPayload = {
      reviseId: parseInt(workOrderInfo.reviseId, 10),
      workorderId: parseInt(workOrderInfo.workOrderId, 10),
      subworkName: subworkName.trim(), // Added trim() for cleaner data
      createdDate: currentDate,
      createdBy: parseInt(userId, 10), // Ensure it's an integer
      updatedDate: currentDate,
      updatedBy: parseInt(userId, 10) // Ensure it's an integer
    };
    
    
    const response = await fetch(`${API_BASE_URL}/api/subwork`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(subworkPayload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error("SubEstimate API Error Response:", errorText);
      throw new Error(`Failed to create subwork: ${response.status}`);
    }
    
    const responseData = await response.json();

    
    // Update work order status if needed
    if (workOrderInfo.status === "started") {
      await updateWorkOrderStatus();
    }
    
    // Update revision status if needed
    if (workOrderInfo.revisionStage === "started") {
      await updateRevisionStatus();
    }
    
    // Reset form field and error state
    setSubworkName('');
    setSubworkNameError(false);
    
    // Refresh the subworks list
    await fetchSubworks(workOrderInfo.reviseId, workOrderInfo.workOrderId);
    
    // *** UPDATED SECTION: Close all open subestimates and expand only the new one ***
    if (responseData.id) {
      // First, close all currently expanded subworks
      setExpandedSubworks([]);
      
      // Then expand only the newly created subwork after a short delay
      setTimeout(() => {
        setExpandedSubworks([responseData.id]);
        // Also trigger the expansion logic for loading items
        handleSubworkExpand(responseData.id);
      }, 500);
    }
    
    toast.dismiss(loadingToast);
    toast.success('Subestimate created successfully!', {
      icon: '✅',
      duration: 3000,
    });
    
  } catch (error) {
    console.error("Error creating subestimate:", error);
    toast.dismiss(loadingToast);
    toast.error(`Failed to add subestimate: ${error.message}`, {
      duration: 4000,
    });
  } finally {
    setIsLoading(false);
  }
};
  // Delete subwork
  const deleteSubwork = async (subworkId) => {
    // Show confirmation toast
    toast((t) => (
      <div className="flex flex-col p-2">
        <p className="mb-2 font-medium">Are you sure you want to delete this subwork?</p>
        <div className="flex justify-end gap-2">
          <button
            onClick={() => toast.dismiss(t.id)}
            className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 transition-colors"
          >
            Cancel
          </button>
          <button
            onClick={() => {
              toast.dismiss(t.id);
              confirmDeleteSubwork(subworkId);
            }}
            className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition-colors"
          >
            Delete
          </button>
        </div>
      </div>
    ), { duration: 10000 });
  };
  const handleItemSelect = (itemNo) => {
    // Find the selected item from options based on ssrItemId instead of itemNo
    const selectedItem = itemOptions.find(item => item.ssrItemId === itemNo);
    
    // Update the form with the selected item's data using the correct field names
    if (selectedItem) {
      setItemForm(prev => ({
        ...prev,
        itemNo: selectedItem.ssrItemId,
        category: selectedItem.category || '',
        descriptionOfItem: selectedItem.description || '',
        smallUnit: selectedItem.smallUnit || '',
        fullUnit: selectedItem.fullUnit || '',
        completedRate: selectedItem.completedRate || 0,
        labourRate: selectedItem.labourRate || 0,
        additionalSpecification: selectedItem.additionalSpecification || '',
        scadaFlag: selectedItem.scadaFlag || false
      }));
    }
  };
  const confirmDeleteSubwork = async (subworkId) => {
    setIsLoading(true);
    try {
      const resp = await fetch(`${API_BASE_URL}/api/subwork/${subworkId}`, {
        method: "DELETE",
        headers: { "Authorization": `Bearer ${jwtToken}` }
      });
      if (!resp.ok) throw new Error('Delete failed');
      fetchSubworks(workOrderInfo.reviseId, workOrderInfo.workOrderId);
      toast.success('Deleted!');
    } catch (err) {
      toast.error(err.message);
    } finally {
      setIsLoading(false);
    }
  };


const toggleSubwork = async (subworkId) => {
    const isCurrentlyExpanded = expandedSubworks.includes(subworkId);
    
    setExpandedSubworks(prev => 
      isCurrentlyExpanded
        ? prev.filter(id => id !== subworkId)
        : [...prev, subworkId]
    );
    
    // If expanding, handle the expansion logic
    if (!isCurrentlyExpanded) {
      await handleSubworkExpand(subworkId);
    }
  };
  // Load items for a subwork
  const loadSubworkItems = async (subworkId) => {
    setIsItemLoading(true);
    
    try {
      const response = await fetch(`${API_BASE_URL}/api/txn-items`, {
        headers: {
          "Authorization": `Bearer ${jwtToken}`,
          "Accept": "*/*"
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const allItems = await response.json();
      
      // Filter items that belong to this subwork
      const subworkItems = allItems.filter(item => item.fkSubworkId === subworkId);
      
      // Update items state
      setItems(prevItems => ({
        ...prevItems,
        [subworkId]: subworkItems
      }));
      
    } catch (error) {
      console.error(`Error loading items for subwork ${subworkId}:`, error);
      toast.error(`Failed to load items for this subwork`);
    } finally {
      setIsItemLoading(false);
    }
  };

  // Add item to a subwork
  const addItemToSubwork = (subworkId) => {
    setCurrentSubworkId(subworkId);
    setItemForm({
      ...itemForm,
      fkSubworkId: subworkId,
      fkWorkorderId: parseInt(workOrderInfo.workOrderId, 10)
    });
    setEditingItemId(null);
    setItemFormErrors({});
    setShowAddItemModal(true);
  };

  // Handle item selection change
  const handleItemChange = (e) => {
    const selectedItemNo = e.target.value;
    // Find by ssrItemId instead of itemNo
    const selectedItemObj = itemOptions.find(item => item.ssrItemId === selectedItemNo);
    
    setItemFormErrors({
      ...itemFormErrors,
      itemNo: false
    });
    
    if (selectedItemObj) {
      setSelectedItem(selectedItemObj);
      setItemForm({
        ...itemForm,
        itemNo: selectedItemObj.ssrItemId,
        category: selectedItemObj.category || '',
        descriptionOfItem: selectedItemObj.description || '',
        smallUnit: selectedItemObj.smallUnit || '',
        fullUnit: selectedItemObj.fullUnit || '',
        completedRate: selectedItemObj.completedRate || 0,
        labourRate: selectedItemObj.labourRate || 0,
        additionalSpecification: selectedItemObj.additionalSpecification || '',
        scadaFlag: selectedItemObj.scadaFlag || false
      });
    } else {
      setSelectedItem(null);
    }
  };
const handleNext = () => {
  if (selectedReportType === 'bank') {
    navigateToPdfPreview();
  } else if (selectedReportType === 'mts') {
    navigateToLead();
  }
};
  // Handle form input changes
  const handleItemFormChange = (e) => {
    const { name, value } = e.target;
    setItemForm({
      ...itemForm,
      [name]: value
    });
    
    if (itemFormErrors[name]) {
      setItemFormErrors({
        ...itemFormErrors,
        [name]: false
      });
    }
  };
// And add a function to update item details if the user makes changes in the modal:
const updateItemDetails = async (updatedDetails) => {
  try {
    setIsLoading(true);
    
    // First, check if we have current data to compare
    const currentItem = items[updatedDetails.fkSubworkId]?.find(item => item.id === updatedDetails.id);
    
    if (!currentItem) {
      throw new Error("Could not find current item data");
    }
    
    // Only update the fields we want to allow changing (scadaFlag only)
    const itemToUpdate = {
      ...currentItem,
      scadaFlag: updatedDetails.scadaFlag
    };
    
    // Update the item
    const response = await fetch(`${API_BASE_URL}/api/txn-items/${updatedDetails.id}`, {
      method: 'PUT',
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Content-Type": "application/json",
        "Accept": "*/*"
      },
      body: JSON.stringify(itemToUpdate)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const savedItem = await response.json();
    
    // Update the items state
    setItems(prev => {
      const updatedItems = {...prev};
      const subworkId = savedItem.fkSubworkId;
      
      if (updatedItems[subworkId]) {
        updatedItems[subworkId] = updatedItems[subworkId].map(item => 
          item.id === savedItem.id ? savedItem : item
        );
      }
      
      return updatedItems;
    });

    // If we have consumption materials and they haven't been saved yet, save them
    if (updatedDetails.consumptionMaterials && 
        (!updatedDetails.txnItemProperties || updatedDetails.txnItemProperties.length === 0)) {
      await saveItemProperties(updatedDetails.id, updatedDetails.consumptionMaterials);
    }

    toast.success('Item details updated successfully');
  } catch (error) {
    console.error("Error updating item details:", error);
    toast.error(`Error updating item details: ${error.message}`);
  } finally {
    setIsLoading(false);
  }
};
  // Validate item form
const validateItemForm = () => {
  const errors = {};
  
  if (!itemForm.itemNo?.trim()) {
    errors.itemNo = 'Item number is required';
  }
  
  if (!itemForm.category?.trim()) {
    errors.category = 'Category is required';
  }
  
  if (!itemForm.descriptionOfItem?.trim()) {
    errors.descriptionOfItem = 'Description is required';
  }

  // Validate numeric fields
  if (itemForm.completedRate && (isNaN(itemForm.completedRate) || itemForm.completedRate < 0)) {
    errors.completedRate = 'Completed rate must be a positive number';
  }

  if (itemForm.labourRate && (isNaN(itemForm.labourRate) || itemForm.labourRate < 0)) {
    errors.labourRate = 'Labour rate must be a positive number';
  }

  setItemFormErrors(errors);
  return Object.keys(errors).length === 0;
};
const handleSubworkExpand = async (subworkId) => {
  try {
    // If items are not loaded for this subwork, load them
    if (!items[subworkId] || items[subworkId].length === 0) {
      await fetchItemsWithMeasurements(subworkId);
    }
    
    // Set current subwork for form context
    setCurrentSubworkId(subworkId);
    
    
  } catch (error) {
    console.error(`Error expanding subwork ${subworkId}:`, error);
    toast.error('Failed to load subwork data');
  }
};
// Calculate totals for subwork
const calculateSubworkTotals = (subworkId, items) => {
  try {
    const totals = items.reduce((acc, item) => {
      // Add your calculation logic here based on measurements
      // This is a placeholder - adjust according to your business logic
      acc.totalQuantity = (acc.totalQuantity || 0) + (item.quantity || 0);
      acc.totalAmount = (acc.totalAmount || 0) + ((item.quantity || 0) * (item.rate || 0));
      return acc;
    }, {});

    setItemTotalQuantities(prev => ({
      ...prev,
      [subworkId]: totals
    }));

 
  } catch (error) {
    console.error(`Error calculating totals for subwork ${subworkId}:`, error);
  }
};
// Fetch item properties
const fetchItemProperties = async (itemId) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/txn-item-properties/item/${itemId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (response.ok) {
      const properties = await response.json();
      
      return properties;
    } else {
      console.warn(`No properties found for item ${itemId}`);
      return [];
    }
  } catch (error) {
    console.error(`Error fetching properties for item ${itemId}:`, error);
    return [];
  }
};
// Enhanced measurements fetching function
const fetchMeasurementsForItem = async (itemId) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/measurements/item/${itemId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "*/*"
      }
    });

    if (response.ok) {
      const measurements = await response.json();
  
      
      // Store measurements in state if you have a measurements state
      // setMeasurements(prev => ({ ...prev, [itemId]: measurements }));
      
      return measurements;
    } else {
      console.warn(`No measurements found for item ${itemId}`);
      return [];
    }
  } catch (error) {
    console.error(`Error fetching measurements for item ${itemId}:`, error);
    return [];
  }
};
  // Save item// *** UPDATED SAVE ITEM FUNCTION WITH ENHANCED AUTOMATIC MATERIAL CREATION ***
const saveItem = async (isManualSave = false) => {
  // Prevent multiple saves from running simultaneously
  if (isItemLoading) {
    
    return false;
  }

  // Validate required fields
  const requiredFields = {
    itemNo: itemForm.itemNo?.trim(),
    category: itemForm.category?.trim(),
    descriptionOfItem: itemForm.descriptionOfItem?.trim()
  };

  const missingFields = Object.entries(requiredFields)
    .filter(([key, value]) => !value)
    .map(([key]) => key);

  if (missingFields.length > 0) {
    if (isManualSave) {
      const errorMsg = `Please fill required fields: ${missingFields.join(', ')}`;
      toast.error(errorMsg);
      setItemFormErrors(prev => ({
        ...prev,
        ...missingFields.reduce((acc, field) => ({ ...acc, [field]: true }), {})
      }));
    }
    return false;
  }

  // Ensure we have a valid subwork ID
  const subworkId = currentSubworkId || currentSubworkForForm?.id;
  if (!subworkId) {
    if (isManualSave) {
      toast.error('No subwork selected. Please select a subwork first.');
    }
    return false;
  }

  // Check if this is a new item
  const isNewItem = !editingItemId;

  // Check for duplicates (only for new items)
  if (isNewItem) {
    const existingItems = items[subworkId] || [];
    const isDuplicate = existingItems.some(item =>
      item.itemNo === itemForm.itemNo.trim()
    );

    if (isDuplicate) {
      if (isManualSave) {
        toast.error(`Item "${itemForm.itemNo}" already exists in this subwork`);
      }
      return false;
    }
  }

  // Clear any pending auto-save timeout to prevent conflicts
  if (autoSaveTimeout) {
    clearTimeout(autoSaveTimeout);
    setAutoSaveTimeout(null);
  }

  setIsItemLoading(true);
  const loadingToast = isManualSave ? toast.loading(editingItemId ? 'Updating item...' : 'Adding item...') : null;

  try {
    const method = editingItemId ? "PUT" : "POST";
    const url = editingItemId
      ? `${API_BASE_URL}/api/txn-items/${editingItemId}`
      : `${API_BASE_URL}/api/txn-items`;

    // Prepare the item data with proper validation and type conversion
    const itemData = {
      // Only include id for PUT requests
      ...(editingItemId && { id: parseInt(editingItemId) }),
      srNo: parseInt(itemForm.srNo) || 0,
      itemNo: itemForm.itemNo.trim(),
      category: itemForm.category.trim(),
      descriptionOfItem: itemForm.descriptionOfItem.trim(),
      floorLiftRise: itemForm.floorLiftRise || "Ground floor",
      fkSubworkId: parseInt(subworkId),
      fkWorkorderId: parseInt(workOrderInfo?.workOrderId || itemForm.fkWorkorderId || 0),
      completedRate: parseFloat(itemForm.completedRate) || 0,
      labourRate: parseFloat(itemForm.labourRate) || 0,
      scadaFlag: Boolean(itemForm.scadaFlag),
      smallUnit: itemForm.smallUnit || "",
      fullUnit: itemForm.fullUnit || "",
      additionalSpecification: itemForm.additionalSpecification || ""
    };

    // Add detailedItemId only if it exists and is valid
    if (itemForm.detailedItemId && parseInt(itemForm.detailedItemId) > 0) {
      itemData.detailedItemId = parseInt(itemForm.detailedItemId);
    }

    

    const response = await fetch(url, {
      method,
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(itemData)
    });

    const responseText = await response.text();
    

    if (!response.ok) {
      let errorMessage = `HTTP error! Status: ${response.status}`;
      try {
        const errorData = JSON.parse(responseText);
        errorMessage = errorData.message || errorData.error || errorData.details || errorMessage;
        console.error('Detailed error:', errorData);
      } catch (e) {
        errorMessage = responseText || errorMessage;
      }
      throw new Error(errorMessage);
    }

    // Parse the response if it's JSON
    let responseData;
    try {
      responseData = JSON.parse(responseText);

    } catch (e) {
      responseData = responseText;
    }

    let savedItemId = null;
    let savedItem = null;

    // Update local state only once with the server response
    if (responseData && typeof responseData === 'object') {
      savedItem = responseData.data || responseData;
      savedItemId = savedItem.id;
      
      if (editingItemId) {
        // Update existing item in the state
        setItems(prevItems => ({
          ...prevItems,
          [subworkId]: (prevItems[subworkId] || []).map(item =>
            item.id === parseInt(editingItemId) ? { ...item, ...savedItem } : item
          )
        }));
      } else {
        // Add new item to the state (only if it doesn't already exist)
        setItems(prevItems => {
          const currentItems = prevItems[subworkId] || [];
          const itemExists = currentItems.some(item => 
            item.id === savedItem.id || item.itemNo === savedItem.itemNo
          );
          
          if (itemExists) {
       
            return prevItems;
          }
          
          const newItem = {
            ...savedItem,
            id: savedItem.id || Date.now(), // Fallback ID if not provided
          };
          
          return {
            ...prevItems,
            [subworkId]: [...currentItems, newItem]
          };
        });
      }
    }

    // *** AUTOMATIC MATERIAL CREATION FOR NEW ITEMS ***
    if (savedItemId && isNewItem) {
     
      
      // Update loading toast to show material creation progress
      if (loadingToast) {
        toast.dismiss(loadingToast);
      }
      const materialLoadingToast = isManualSave ? toast.loading('Creating materials automatically...') : null;
      
      try {
        // Call the material creation function
        const materialCreationResult = await createMaterialsForItem(savedItemId, savedItem);
        
        if (materialLoadingToast) {
          toast.dismiss(materialLoadingToast);
        }
        
        // Show detailed result based on material creation outcome
        if (materialCreationResult.success) {
          const cacheStatus = materialCreationResult.usedCache ? 'from cache' : 'from API';
          const message = `Item added successfully! Created ${materialCreationResult.successfulCreations} materials ${cacheStatus}.`;
          
          if (isManualSave) {
            toast.success(message, {
              icon: '✅',
              duration: 4000
            });
          }
          
          console.log(`✓ Automatic material creation completed: ${materialCreationResult.successfulCreations}/${materialCreationResult.totalMaterials} successful`);
          
          // Log cache usage for debugging
          if (materialCreationResult.usedCache) {
            console.log('✓ Materials were loaded from cache - faster processing');
          } else {
            console.log('✓ Materials were fetched from API and cached for future use');
          }
          
          if (materialCreationResult.failedCreations > 0) {
            console.warn(`⚠️ Some materials failed to create: ${materialCreationResult.failedCreations} failures`);
            if (isManualSave) {
              toast.warning(`${materialCreationResult.failedCreations} materials failed to create`, {
                duration: 3000
              });
            }
          }
        } else {
          const errorMsg = materialCreationResult.reason || materialCreationResult.error || 'Unknown error';
          console.warn(`⚠️ Automatic material creation failed: ${errorMsg}`);
          
          if (isManualSave) {
            if (errorMsg === 'No consumption materials available') {
              toast.info('Item added successfully. No materials found for this item.', {
                duration: 3000
              });
            } else {
              toast.warning(`Item added but automatic material creation failed: ${errorMsg}`, {
                duration: 4000
              });
            }
          }
        }
        
      } catch (materialError) {
        console.error('Error during automatic material creation:', materialError);
        
        if (materialLoadingToast) {
          toast.dismiss(materialLoadingToast);
        }
        
        if (isManualSave) {
          toast.warning(`Item added but automatic material creation failed: ${materialError.message}`, {
            duration: 4000
          });
        }
      }
    }

    // *** AUTO-EXPAND MEASUREMENTS FOR NEW ITEMS ***
    if (isNewItem && savedItemId) {
      console.log('Auto-expanding measurements for new item:', savedItemId);
      setVisibleMeasurements(prev => ({
        ...prev,
        [savedItemId]: true
      }));
    }

    // Clear editing state first
    setEditingItemId(null);
    
    // Hide new item form if it was shown
    if (isNewItem) {
      setShowNewItemForm(prev => ({
        ...prev,
        [subworkId]: false
      }));
    }
    
    // Reset the form after successful save (with a small delay to ensure state updates)
    setTimeout(() => {
      resetItemForm();
      // Keep the current subwork active so the form remains visible for adding more items
      setCurrentSubworkId(subworkId);
    }, 100);

    // Show success message for updates (new items already handled above with materials)
    if (isManualSave && editingItemId) {
      if (loadingToast) {
        toast.dismiss(loadingToast);
      }
      toast.success('Item updated successfully!', {
        icon: '✅'
      });
    }

    // *** TRIGGER DATA UPDATE ***
    triggerDataUpdate();

    return true; // Success
    
  } catch (error) {
    console.error("Error saving item:", error);
    
    if (loadingToast) {
      toast.dismiss(loadingToast);
    }
    
    if (isManualSave) {
      // More specific error messages
      let errorMsg = error.message;
      if (error.message.includes('500')) {
        errorMsg = 'Server error. Please check your data and try again.';
      } else if (error.message.includes('400')) {
        errorMsg = 'Invalid data. Please check all fields and try again.';
      } else if (error.message.includes('401')) {
        errorMsg = 'Authentication error. Please login again.';
      }
      
      toast.error(`Failed to ${editingItemId ? "update" : "add"} item: ${errorMsg}`);
    }
    return false; // Failure
  } finally {
    setIsItemLoading(false);
  }
};
const getConsumptionMaterialsFromCache = (itemNo, detailedItemId = null) => {
  try {
    const cacheKey = 'consumptionMaterialsCache';
    const cache = localStorage.getItem(cacheKey);
    
    if (!cache) {
      return null;
    }
    
    const parsedCache = JSON.parse(cache);
    
    // Try to find by itemNo first
    if (parsedCache[itemNo]) {
      console.log(`✓ Found cached consumption materials for itemNo: ${itemNo}`);
      return parsedCache[itemNo].consumptionMaterials;
    }
    
    // Try to find by detailedItemId
    if (detailedItemId && parsedCache[`detailed_${detailedItemId}`]) {
      console.log(`✓ Found cached consumption materials for detailedItemId: ${detailedItemId}`);
      return parsedCache[`detailed_${detailedItemId}`].consumptionMaterials;
    }
    
    console.log(`No cached consumption materials found for ${itemNo}/${detailedItemId}`);
    return null;
    
  } catch (error) {
    console.error('Error getting consumption materials from cache:', error);
    return null;
  }
};

// Function to get material ID from mapping cache
const getMaterialIdFromCache = (materialName) => {
  try {
    const mappingCacheKey = 'materialIdMappingCache';
    const cache = localStorage.getItem(mappingCacheKey);
    
    if (!cache) {
      return null;
    }
    
    const parsedCache = JSON.parse(cache);
    const materialKey = materialName.trim().toUpperCase();
    
    if (parsedCache[materialKey]) {
      console.log(`✓ Found cached material ID for ${materialName}: ${parsedCache[materialKey].fkMaterialId}`);
      return parsedCache[materialKey];
    }
    
    return null;
    
  } catch (error) {
    console.error('Error getting material ID from cache:', error);
    return null;
  }
};

// Function to clear consumption materials cache (call this when needed)
const clearConsumptionMaterialsCache = () => {
  try {
    localStorage.removeItem('consumptionMaterialsCache');
    localStorage.removeItem('materialIdMappingCache');
    console.log('✓ Cleared consumption materials cache');
  } catch (error) {
    console.error('Error clearing consumption materials cache:', error);
  }
};
const updateMaterialIdMappingCache = (consumptionMaterials) => {
  try {
    const mappingCacheKey = 'materialIdMappingCache';
    let mappingCache = {};
    
    // Get existing mapping cache
    const existingMapping = localStorage.getItem(mappingCacheKey);
    if (existingMapping) {
      mappingCache = JSON.parse(existingMapping);
    }
    
    // Add new mappings
    consumptionMaterials.forEach(material => {
      if (material.materialName && material.fkMaterialId && material.fkMaterialId > 0) {
        const materialKey = material.materialName.trim().toUpperCase();
        mappingCache[materialKey] = {
          fkMaterialId: material.fkMaterialId,
          materialName: material.materialName,
          materialUnit: material.materialUnit,
          constant: material.constant,
          lastUpdated: Date.now()
        };
      }
    });
    
    localStorage.setItem(mappingCacheKey, JSON.stringify(mappingCache));

    
  } catch (error) {
    console.error('Error updating material ID mapping cache:', error);
  }
};
// Function to get cache statistics
const getConsumptionMaterialsCacheStats = () => {
  try {
    const cacheKey = 'consumptionMaterialsCache';
    const mappingCacheKey = 'materialIdMappingCache';
    
    const cache = localStorage.getItem(cacheKey);
    const mappingCache = localStorage.getItem(mappingCacheKey);
    
    const stats = {
      itemsCached: 0,
      materialMappings: 0,
      cacheSize: 0,
      mappingCacheSize: 0
    };
    
    if (cache) {
      const parsedCache = JSON.parse(cache);
      stats.itemsCached = Object.keys(parsedCache).length;
      stats.cacheSize = cache.length;
    }
    
    if (mappingCache) {
      const parsedMappingCache = JSON.parse(mappingCache);
      stats.materialMappings = Object.keys(parsedMappingCache).length;
      stats.mappingCacheSize = mappingCache.length;
    }
    
   
    return stats;
    
  } catch (error) {
    console.error('Error getting cache statistics:', error);
    return null;
  }
};
const storeConsumptionMaterialsInCache = (itemNo, detailedItemId, consumptionMaterials) => {
  try {
    const cacheKey = 'consumptionMaterialsCache';
    let cache = {};
    
    // Try to get existing cache
    const existingCache = localStorage.getItem(cacheKey);
    if (existingCache) {
      cache = JSON.parse(existingCache);
    }
    
    // Store by both itemNo and detailedItemId for flexible lookup
    const materialData = {
      itemNo,
      detailedItemId,
      consumptionMaterials: Array.isArray(consumptionMaterials) ? consumptionMaterials : [],
      timestamp: Date.now(),
      version: '1.0'
    };
    
    cache[itemNo] = materialData;
    if (detailedItemId) {
      cache[`detailed_${detailedItemId}`] = materialData;
    }
    
    localStorage.setItem(cacheKey, JSON.stringify(cache));
    console.log(`✓ Cached consumption materials for ${itemNo}:`, consumptionMaterials.length, 'materials');
    
    // Also create a material name to fkMaterialId mapping cache
    updateMaterialIdMappingCache(consumptionMaterials);
    
  } catch (error) {
    console.error('Error storing consumption materials in cache:', error);
  }
};
// *** NEW HELPER FUNCTION: Create materials for an item ***
const createMaterialsForItem = async (itemId, itemData) => {
  try {
   

    let detailedItemId = null;
    let consumptionMaterials = [];

    // First, try to get from cache
  
    const cachedMaterials = getConsumptionMaterialsFromCache(itemData.itemNo);
    
    if (cachedMaterials && cachedMaterials.length > 0) {

      consumptionMaterials = cachedMaterials;
    } else {
     
      
      try {
        const detailedItem = itemOptions.find(opt => opt.ssrItemId === itemData.itemNo);
        
        if (detailedItem) {
         
          detailedItemId = detailedItem.detailedItemId;
          
          // Store page number in localStorage when found
          if (detailedItem.pageNo) {
            storePageNumberForItem(itemData.itemNo, detailedItem.pageNo);
          }
          
          // Fetch consumption materials if we have detailedItemId
          if (detailedItemId) {
 
            const materialsResponse = await fetch(
              `${API_BASE_URL}/api/master/consumptionMaterialAndRoad/getDetailedItemId?detailedItemId=${detailedItemId}`, 
              {
                headers: {
                  "Authorization": `Bearer ${jwtToken}`,
                  "Accept": "*/*"
                }
              }
            );
            
            if (materialsResponse.ok) {
              const materialsData = await materialsResponse.json();
              const rawMaterials = Array.isArray(materialsData) ? materialsData : [];
              
              // Filter and validate materials
              const validMaterials = rawMaterials.filter(material => {
                const isValid = material.materialName && 
                               material.fkMaterialId && 
                               material.fkMaterialId > 0 &&
                               material.constant !== null && 
                               material.constant !== undefined;
                
                if (!isValid) {
                  console.warn(`Invalid material data filtered out:`, material);
                }
                return isValid;
              });
              
              if (validMaterials.length > 0) {
                consumptionMaterials = validMaterials;
                
                // *** CACHE THE FETCHED MATERIALS ***
                console.log(`✓ Caching ${validMaterials.length} valid consumption materials for ${itemData.itemNo}`);
                storeConsumptionMaterialsInCache(itemData.itemNo, detailedItemId, validMaterials);
                
                console.log("Cached materials details:");
                validMaterials.forEach((mat, idx) => {
                  console.log(`  ${idx + 1}. ${mat.materialName} (fkMaterialId: ${mat.fkMaterialId}, constant: ${mat.constant})`);
                });
              } else {
                console.warn(`No valid consumption materials found for ${itemData.itemNo}`);
                console.log("Raw materials received:", rawMaterials);
              }
            } else {
              console.warn("Failed to fetch consumption materials:", materialsResponse.status, materialsResponse.statusText);
            }
          } else {
            console.warn(`No detailedItemId found for ${itemData.itemNo}`);
          }
        } else {
          console.warn(`No detailed item found for itemNo: ${itemData.itemNo}`);
          return; // Exit early if no detailed item found
        }
      } catch (detailError) {
        console.warn("Error finding detailed item:", detailError);
        return; // Exit early on error
      }
    }

    // Create transaction item properties from consumption materials
    if (consumptionMaterials.length > 0) {
      console.log(`Creating ${consumptionMaterials.length} transaction item properties from consumption materials...`);
      
      const propertyCreationPromises = consumptionMaterials.map(async (material, index) => {
        // Validate material data before creating property
        if (!material.materialName || material.constant === null || material.constant === undefined) {
          console.warn(`Invalid material data at index ${index}:`, material);
          return { error: true, material: material.materialName || `Material ${index + 1}`, errorDetails: 'Invalid material data' };
        }
        
        const propertyData = {
          txnItemId: itemId,
          material: material.materialName.trim(),
          materialConstant: parseFloat(material.constant) || 0,
          materialUnit: material.materialUnit ? material.materialUnit.trim() : "Unit"
        };
        
        console.log(`Creating property ${index + 1}/${consumptionMaterials.length}:`, propertyData);
        
        try {
          const createResponse = await fetch(`${API_BASE_URL}/api/txn-item-properties`, {
            method: 'POST',
            headers: {
              "Authorization": `Bearer ${jwtToken}`,
              "Accept": "application/json",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(propertyData)
          });
          
          if (createResponse.ok) {
            const createdProperty = await createResponse.json();
            console.log(`✓ Successfully created property ${index + 1}:`, createdProperty);
            return createdProperty;
          } else {
            // Get detailed error information
            let errorDetails = '';
            try {
              const errorResponse = await createResponse.json();
              errorDetails = errorResponse.message || errorResponse.error || createResponse.statusText;
            } catch {
              errorDetails = await createResponse.text() || createResponse.statusText;
            }
            
            console.error(`✗ Failed to create property for material ${material.materialName}:`, {
              status: createResponse.status,
              statusText: createResponse.statusText,
              errorDetails: errorDetails,
              requestData: propertyData
            });
            
            return {
              error: true,
              material: material.materialName,
              errorDetails: errorDetails,
              status: createResponse.status
            };
          }
        } catch (createError) {
          console.error(`✗ Network error creating property for material ${material.materialName}:`, createError);
          return {
            error: true,
            material: material.materialName,
            errorDetails: createError.message,
            networkError: true
          };
        }
      });
      
      // Execute all property creation requests
      console.log("Executing property creation requests...");
      const createdPropertiesResults = await Promise.allSettled(propertyCreationPromises);
      const successfulProperties = [];
      const failedProperties = [];
      
      createdPropertiesResults.forEach((result, index) => {
        if (result.status === 'fulfilled' && result.value !== null) {
          if (result.value.error) {
            failedProperties.push({
              material: result.value.material,
              error: result.value.errorDetails,
              index: index + 1
            });
          } else {
            successfulProperties.push(result.value);
          }
        } else {
          failedProperties.push({
            material: consumptionMaterials[index]?.materialName || `Material ${index + 1}`,
            error: result.reason?.message || 'Unknown error',
            index: index + 1
          });
        }
      });
      
      // *** ENHANCED RESULT LOGGING ***
      console.log('\n=== MATERIAL PROPERTY CREATION RESULTS ===');
      console.log(`Total materials processed: ${consumptionMaterials.length}`);
      console.log(`Successful creations: ${successfulProperties.length}`);
      console.log(`Failed creations: ${failedProperties.length}`);
      
      if (successfulProperties.length > 0) {
        console.log(`✓ Successfully created ${successfulProperties.length} material properties for item ${itemId}`);
        console.log('Created properties:', successfulProperties.map(p => p.material || 'Unknown'));
        
        if (failedProperties.length > 0) {
          console.warn(`⚠️ Failed to create ${failedProperties.length} properties:`);
          failedProperties.forEach(failed => {
            console.warn(`  - ${failed.material}: ${failed.error}`);
          });
        }
        
        // *** UPDATE CACHE STATISTICS ***
        console.log('\n=== CACHE STATISTICS AFTER CREATION ===');
        const cacheStats = getConsumptionMaterialsCacheStats();
        if (cacheStats) {
          console.log(`Items in cache: ${cacheStats.itemsCached}`);
          console.log(`Material mappings: ${cacheStats.materialMappings}`);
        }
        
      } else {
        console.error("✗ Failed to create any material properties for item:", itemId);
        if (failedProperties.length > 0) {
          const errorSummary = failedProperties.map(f => `${f.material}: ${f.error}`).join('; ');
          console.error("Creation failures summary:", errorSummary);
        }
      }
      
      // *** RETURN CREATION SUMMARY ***
      return {
        success: successfulProperties.length > 0,
        totalMaterials: consumptionMaterials.length,
        successfulCreations: successfulProperties.length,
        failedCreations: failedProperties.length,
        successfulProperties,
        failedProperties,
        usedCache: cachedMaterials && cachedMaterials.length > 0
      };
      
    } else {
      console.log("⚠️ No consumption materials found for item:", itemId);
      return {
        success: false,
        totalMaterials: 0,
        successfulCreations: 0,
        failedCreations: 0,
        successfulProperties: [],
        failedProperties: [],
        usedCache: false,
        reason: 'No consumption materials available'
      };
    }
    
  } catch (error) {
    console.error("✗ Error in createMaterialsForItem:", error);
    return {
      success: false,
      totalMaterials: 0,
      successfulCreations: 0,
      failedCreations: 0,
      successfulProperties: [],
      failedProperties: [],
      usedCache: false,
      error: error.message
    };
  }
};
const triggerDataUpdate = () => {
  const currentTime = new Date().toISOString();
  localStorage.setItem('lastAbstractUpdate', currentTime);
  
  // Dispatch custom event
  window.dispatchEvent(new CustomEvent('dataUpdated', {
    detail: { timestamp: currentTime, source: 'manual' }
  }));
  
  console.log('Data update triggered');
};

const refreshItemsDisplay = async (subworkId) => {
  try {
    setIsItemLoading(true);
    
    const response = await fetch(`${API_BASE_URL}/api/txn-items/subwork/${subworkId}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`
      }
    });

    if (response.ok) {
      const fetchedItems = await response.json();
      console.log('Refreshed items:', fetchedItems);
      
      setItems(prevItems => ({
        ...prevItems,
        [subworkId]: Array.isArray(fetchedItems) ? fetchedItems : []
      }));
    } else {
      console.error('Failed to refresh items:', response.status);
    }
  } catch (error) {
    console.error('Error refreshing items:', error);
  } finally {
    setIsItemLoading(false);
  }
};
const handleViewItemDetails = async (item) => {
  try {
    setIsLoading(true);
    
    setItemDetails({...item});
    setShowItemDetailsModal(true);
    
    let detailedItem = null;
    
    try {
      detailedItem = itemOptions.find(opt => opt.ssrItemId === item.itemNo);
      
      if (detailedItem) {
        console.log("Found detailed item:", detailedItem);
        setItemDetails(prevDetails => ({
          ...prevDetails,
          description: detailedItem.description,
          pageNo: detailedItem.pageNo,
          additionalSpecification: detailedItem.additionalSpecification,
          smallUnit: detailedItem.smallUnit,
          fullUnit: detailedItem.fullUnit,
          completedRate: detailedItem.completedRate,
          labourRate: detailedItem.labourRate,
          // ... other properties
        }));
      }
    } catch (error) {
      console.error("Error fetching detailed item:", error);
    }
    
  } catch (error) {
    console.error("Error in handleViewItemDetails:", error);
  } finally {
    setIsLoading(false);
  }
};
useEffect(() => {
  if (currentSubworkId && itemForm.itemNo?.trim() && itemForm.category?.trim() && itemForm.descriptionOfItem?.trim()) {
    autoSaveItem(currentSubworkId);
  }
  
  // Cleanup timeout on unmount
  return () => {
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }
  };
}, [itemForm.itemNo, itemForm.category, itemForm.descriptionOfItem, currentSubworkId]);

  // Edit item
const editItem = async (item) => {
 
  
  
  // Close all open measurement sections when starting to edit
  setVisibleMeasurements({});
  
  // Clear any auto-save timeout
  if (autoSaveTimeout) {
    clearTimeout(autoSaveTimeout);
    setAutoSaveTimeout(null);
  }

  setCurrentSubworkId(item.fkSubworkId);
  setItemForm({
    ...item,
    // Ensure all required fields are properly set
    itemNo: item.itemNo || '',
    category: item.category || '',
    descriptionOfItem: item.descriptionOfItem || '',
    completedRate: item.completedRate || 0,
    labourRate: item.labourRate || 0
  });
  setEditingItemId(item.id);
  setItemFormErrors({});

  const selectedItem = itemOptions.find(option =>
    option.ssrItemId === item.itemNo ||
    (option.description === item.descriptionOfItem && option.category === item.category)
  );
  
  if (selectedItem) {
    setSelectedItem(selectedItem);
  }

 
  
  // *** CHECK AND CREATE MATERIALS IF MISSING ***
  try {
 
    
    const existingMaterialsResponse = await fetch(`${API_BASE_URL}/api/txn-item-properties/serchByTxnItemId/${item.id}`, {
      headers: {
        "Authorization": `Bearer ${jwtToken}`,
        "Accept": "application/json"
      }
    });

    let hasExistingMaterials = false;

    if (existingMaterialsResponse.ok) {
      const existingMaterials = await existingMaterialsResponse.json();
      hasExistingMaterials = Array.isArray(existingMaterials) && existingMaterials.length > 0;
      
      if (hasExistingMaterials) {
        
      }
    }

    // If no materials exist, create them automatically
    if (!hasExistingMaterials) {
     
      
      const materialCreationResult = await createMaterialsForItem(item.id, item);
      
      if (materialCreationResult.success) {
        
        toast.success(`Created ${materialCreationResult.successfulCreations} materials for this item`, {
          duration: 3000
        });
      } else {
        const reason = materialCreationResult.reason || 'Unknown error';
        
        
        if (reason !== 'No consumption materials available') {
          toast.info('No materials found for this item', {
            duration: 3000
          });
        }
      }
    }
    
  } catch (error) {
    console.error('Error checking/creating materials during edit:', error);
    // Don't block editing if material creation fails
  }
};


  // Delete item
  const deleteItem = async (itemId) => {
  // Show confirmation toast
  toast((t) => (
    <div className="flex flex-col p-2">
      <p className="mb-2 font-medium">Are you sure you want to delete this item?</p>
      <p className="text-sm text-gray-600 mb-3">This action cannot be undone and will also delete all associated measurements and materials.</p>
      <div className="flex justify-end gap-2">
        <button
          onClick={() => toast.dismiss(t.id)}
          className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 transition-colors"
        >
          Cancel
        </button>
        <button
          onClick={() => {
            toast.dismiss(t.id);
            confirmDeleteItem(itemId);
          }}
          className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition-colors"
        >
          Delete
        </button>
      </div>
    </div>
  ), { duration: 15000 });
};
const autoSaveItem = async (subworkId) => {
  // Only auto-save if we have required fields and we're not in edit mode
  if (!itemForm.itemNo?.trim() || !itemForm.category?.trim() || !itemForm.descriptionOfItem?.trim()) {
    return;
  }

  // Don't auto-save if we're currently editing an item manually or if save is in progress
  if (editingItemId || isItemLoading) {
   
    return;
  }

  // Check if item already exists
  const existingItems = items[subworkId] || [];
  const existingItem = existingItems.find(item => 
    item.itemNo === itemForm.itemNo.trim() && item.id !== itemForm.id
  );
  
  if (existingItem) {
   
    return;
  }


  const success = await saveItem(false); // Pass false to indicate this is not a manual save
  
  if (success) {
    // Reset form after successful auto-save
    setTimeout(() => {
      resetItemForm();
    }, 100);
  }
};

// Add this to your subestimate page useEffect or initialization function

const handleDuplicationOnLoad = async () => {
  const shouldDuplicate = localStorage.getItem('shouldDuplicateContent');
  const isDuplicating = localStorage.getItem('isDuplicating');
  
  if (shouldDuplicate === 'true' && isDuplicating === 'true') {
    
    
    try {
      // Show loading toast
      const loadingToast = toast.loading('Duplicating all content to new revision...');
      
      // Get source data from localStorage
      const sourceSubworkData = JSON.parse(localStorage.getItem('sourceSubworkData') || '[]');
      const sourceItems = JSON.parse(localStorage.getItem('sourceRevisionItems') || '[]');
      const sourceMeasurements = JSON.parse(localStorage.getItem('sourceRevisionMeasurements') || '[]');
      const newRevisionId = localStorage.getItem('newRevisionId');
      const currentToken = localStorage.getItem('token') || localStorage.getItem('authToken');
      
      if (!newRevisionId || !currentToken) {
        throw new Error('Missing revision ID or authentication token');
      }
      
      // const API_BASE_URL = "https://24.101.103.87:8082/api";
      
      // Step 1: Create all subworks first
      const createdSubworks = [];
      const subworkIdMapping = {}; // Map old subwork ID to new subwork ID
      
      for (const subwork of sourceSubworkData) {
        try {
          const subworkPayload = {
            ...subwork,
            id: undefined, // Remove ID to create new
            revisionId: parseInt(newRevisionId)
          };
          
          const response = await fetch(`${API_BASE_URL}/api/subwork`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${currentToken}`
            },
            body: JSON.stringify(subworkPayload)
          });
          
          if (!response.ok) {
            if (response.status === 401) {
              toast.dismiss(loadingToast);
              toast.error('Session expired. Please login again.');
              localStorage.clear();
              navigate('/signin');
              return;
            }
            throw new Error(`Failed to create subwork: ${response.status}`);
          }
          
          const newSubwork = await response.json();
          createdSubworks.push(newSubwork);
          subworkIdMapping[subwork.subworkId || subwork.id] = newSubwork.id;
          
          
          
        } catch (error) {
          console.error('Error creating subwork:', error);
          throw error;
        }
      }
      
      // Step 2: Create all items with updated subwork IDs
      const createdItems = [];
      const itemIdMapping = {}; // Map old item ID to new item ID
      
      for (const item of sourceItems) {
        try {
          const newSubworkId = subworkIdMapping[item.subworkId];
          if (!newSubworkId) {
            console.warn(`No mapping found for subwork ID: ${item.subworkId}`);
            continue;
          }
          
          const itemPayload = {
            ...item,
            id: undefined, // Remove ID to create new
            subworkId: newSubworkId,
            revisionId: parseInt(newRevisionId)
          };
          
          const response = await fetch(`${API_BASE_URL}/api/txn-items`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${currentToken}`
            },
            body: JSON.stringify(itemPayload)
          });
          
          if (!response.ok) {
            if (response.status === 401) {
              toast.dismiss(loadingToast);
              toast.error('Session expired. Please login again.');
              localStorage.clear();
              navigate('/signin');
              return;
            }
            throw new Error(`Failed to create item: ${response.status}`);
          }
          
          const newItem = await response.json();
          createdItems.push(newItem);
          itemIdMapping[item.originalItemId || item.itemId] = newItem.id;
          
          
          
        } catch (error) {
          console.error('Error creating item:', error);
          throw error;
        }
      }
      
      // Step 3: Create all measurements with updated item IDs
      const createdMeasurements = [];
      
      for (const measurement of sourceMeasurements) {
        try {
          const newItemId = itemIdMapping[measurement.originalItemId || measurement.itemId];
          if (!newItemId) {
            console.warn(`No mapping found for item ID: ${measurement.originalItemId || measurement.itemId}`);
            continue;
          }
          
          const measurementPayload = {
            ...measurement,
            id: undefined, // Remove ID to create new
            itemId: newItemId,
            revisionId: parseInt(newRevisionId)
          };
          
          const response = await fetch(`${API_BASE_URL}/api/txn-items-mts`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${currentToken}`
            },
            body: JSON.stringify(measurementPayload)
          });
          
          if (!response.ok) {
            if (response.status === 401) {
              toast.dismiss(loadingToast);
              toast.error('Session expired. Please login again.');
              localStorage.clear();
              navigate('/signin');
              return;
            }
            throw new Error(`Failed to create measurement: ${response.status}`);
          }
          
          const newMeasurement = await response.json();
          createdMeasurements.push(newMeasurement);
    
          
        } catch (error) {
          console.error('Error creating measurement:', error);
          throw error;
        }
      }
      
      // Step 4: Clean up duplication flags and source data
      const keysToRemove = [
        'shouldDuplicateContent', 'duplicateContentOnLoad', 'loadSourceDataForDuplication',
        'isDuplicating', 'duplicateMode', 'sourceRevisionId', 'revisionToCopyId',
        'sourceSubworkData', 'sourceRevisionItems', 'sourceRevisionMeasurements',
        'sourceRevisionDataBySubwork', 'totalSubworksToDuplicate', 
        'totalItemsToDuplicate', 'totalMeasurementsToDuplicate'
      ];
      
      keysToRemove.forEach(key => {
        localStorage.removeItem(key);
      });
      
      // Step 5: Now fetch the newly created data for the current page (like handleEditRevision)
      const workorderId = localStorage.getItem('workorderId');
      const currentRevisionId = localStorage.getItem('reviseId');
      
      // Fetch the newly created subwork data
      const subworkResponse = await fetch(`${API_BASE_URL}/subwork/${currentRevisionId}/${workorderId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${currentToken}`,
          'Content-Type': 'application/json',
        }
      });
      
      if (!subworkResponse.ok) {
        throw new Error(`Failed to fetch new subwork data: ${subworkResponse.status}`);
      }
      
      const newSubworkData = await subworkResponse.json();
      
      // Fetch all items and measurements for the new revision
      const allNewItems = [];
      const allNewMeasurements = [];
      
      for (const subwork of newSubworkData) {
        try {
          const itemsResponse = await fetch(`${API_BASE_URL}/api/txn-items/BySubwork/${subwork.id}`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${currentToken}`,
              'Content-Type': 'application/json',
            }
          });
          
          if (itemsResponse.ok) {
            const itemsData = await itemsResponse.json();
            const itemsWithSubwork = itemsData.map(item => ({
              ...item,
              subworkId: subwork.id,
              subworkName: subwork.subworkName
            }));
            allNewItems.push(...itemsWithSubwork);
            
            for (const item of itemsData) {
              try {
                const measurementsResponse = await fetch(`${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`, {
                  method: 'GET',
                  headers: {
                    'Authorization': `Bearer ${currentToken}`,
                    'Content-Type': 'application/json',
                  }
                });
                
                if (measurementsResponse.ok) {
                  const measurementsData = await measurementsResponse.json();
                  const measurementsWithRef = measurementsData.map(measurement => ({
                    ...measurement,
                    itemId: item.id,
                    itemNo: item.itemNo,
                    subworkId: subwork.id,
                    subworkName: subwork.subworkName
                  }));
                  allNewMeasurements.push(...measurementsWithRef);
                }
              } catch (error) {
                console.error(`Error fetching measurements for new item ${item.id}:`, error);
              }
            }
          }
        } catch (error) {
          console.error(`Error fetching items for new subwork ${subwork.id}:`, error);
        }
      }
      
      // Step 6: Store the newly created data in localStorage for the page to use
      localStorage.setItem('subworkData', JSON.stringify(newSubworkData));
      localStorage.setItem('revisionItems', JSON.stringify(allNewItems));
      localStorage.setItem('revisionMeasurements', JSON.stringify(allNewMeasurements));
      
      // Store organized data by subwork
      const dataBySubwork = {};
      newSubworkData.forEach(subwork => {
        const subworkItems = allNewItems.filter(item => item.subworkId === subwork.id);
        const subworkMeasurements = allNewMeasurements.filter(measurement => measurement.subworkId === subwork.id);
        
        dataBySubwork[subwork.id] = {
          subwork: subwork,
          items: subworkItems,
          measurements: subworkMeasurements
        };
      });
      
      localStorage.setItem('revisionDataBySubwork', JSON.stringify(dataBySubwork));
      localStorage.setItem('totalSubworks', newSubworkData.length.toString());
      localStorage.setItem('totalItems', allNewItems.length.toString());
      localStorage.setItem('totalMeasurements', allNewMeasurements.length.toString());
      
      // Dismiss loading toast and show success
      toast.dismiss(loadingToast);
      toast.success(`Successfully duplicated: ${createdSubworks.length} subestimates, ${createdItems.length} items, ${createdMeasurements.length} measurements`);
      
      // Refresh the page data or trigger re-render
      // You might need to call your data loading function here or set state to trigger re-render
      
    } catch (error) {
      console.error('Error during duplication:', error);
      toast.error('Failed to duplicate content: ' + error.message);
      
      // Clean up flags on error
      localStorage.removeItem('shouldDuplicateContent');
      localStorage.removeItem('isDuplicating');
    }
  }
};

// Call this function in your subestimate page useEffect
// useEffect(() => {
//   handleDuplicationOnLoad();
// }, []);// Updated useEffect to handle both edit and duplicate modes
// Updated useEffect for handling both edit and duplicate modes
useEffect(() => {
  // Check if we're in edit mode
  const editMode = localStorage.getItem('editMode');
  const editingRevision = localStorage.getItem('editingRevision');
  const isDuplicatingRevision = localStorage.getItem('isDuplicatingRevision');
  const needsDuplication = localStorage.getItem('needsDuplication');
  
  if (editMode === 'true' && editingRevision === 'true') {
    // Handle edit mode - load existing revision data
    loadRevisionDataForEdit();
  } else if (editMode === 'true' && isDuplicatingRevision === 'true' && needsDuplication === 'true') {
    // Handle duplicate mode - duplicate source revision data
    loadAndDuplicateRevisionData();
  }
}, []);

// Existing function for edit mode (keep as is)
const loadRevisionDataForEdit = () => {
  try {
    // Get basic revision info
    const workorderId = localStorage.getItem('workorderId');
    const revisionId = localStorage.getItem('reviseId');
    const revisionNumber = localStorage.getItem('revisionNumber');
    
    
    // Get subwork data
    const subworkDataStr = localStorage.getItem('subworkData');
    if (subworkDataStr) {
      const subworkData = JSON.parse(subworkDataStr);
     
      setSubworkData(subworkData);
    }
    
    // Get items data
    const itemsDataStr = localStorage.getItem('revisionItems');
    if (itemsDataStr) {
      const itemsData = JSON.parse(itemsDataStr);
  
      setItemsData(itemsData);
    }
    
    // Get measurements data
    const measurementsDataStr = localStorage.getItem('revisionMeasurements');
    if (measurementsDataStr) {
      const measurementsData = JSON.parse(measurementsDataStr);
     
      setMeasurementsData(measurementsData);
    }
    
    // Get organized data by subwork
    const dataBySubworkStr = localStorage.getItem('revisionDataBySubwork');
    if (dataBySubworkStr) {
      const dataBySubwork = JSON.parse(dataBySubworkStr);
     
      setDataBySubwork(dataBySubwork);
    }
    
    // Get summary counts
    const totalSubworks = localStorage.getItem('totalSubworks');
    const totalItems = localStorage.getItem('totalItems');
    const totalMeasurements = localStorage.getItem('totalMeasurements');
    
   
    
    // Update UI state
    setIsEditMode(true);
    setEditingRevision(true);
    
    // toast.success(`Loaded revision data for editing: ${totalSubworks} subworks, ${totalItems} items, ${totalMeasurements} measurements`);
    
  } catch (error) {
    console.error('Error loading revision data for edit:', error);
    toast.error('Failed to load revision data for editing');
  }
};

// New function for duplicate mode
const loadAndDuplicateRevisionData = async () => {
  try {
    const loadingToast = toast.loading('Duplicating revision data...');
    
    // Get basic info
    const newRevisionId = localStorage.getItem('reviseId');
    const sourceRevisionId = localStorage.getItem('sourceRevisionId');
    const newRevisionNumber = localStorage.getItem('revisionNumber');
    
   
    
    // Get authentication
    const currentToken = localStorage.getItem('token') || localStorage.getItem('jwt');
    const uid = localStorage.getItem('userId') || localStorage.getItem('Id');
    
    if (!currentToken || !uid) {
      toast.dismiss(loadingToast);
      toast.error('Authentication required. Please login again.');
      return;
    }
    
    // const API_BASE_URL = "https://24.101.103.87:8082/api";
    
    // Get source data from localStorage
    const sourceSubworkDataStr = localStorage.getItem('sourceSubworkData');
    const sourceItemsDataStr = localStorage.getItem('sourceRevisionItems');
    const sourceMeasurementsDataStr = localStorage.getItem('sourceRevisionMeasurements');
    
    if (!sourceSubworkDataStr || !sourceItemsDataStr || !sourceMeasurementsDataStr) {
      toast.dismiss(loadingToast);
      toast.error('Source revision data not found. Please try again.');
      return;
    }
    
    const sourceSubworkData = JSON.parse(sourceSubworkDataStr);
    const sourceItemsData = JSON.parse(sourceItemsDataStr);
    const sourceMeasurementsData = JSON.parse(sourceMeasurementsDataStr);
    
    
    
    // STEP 1: Duplicate subworks
    const newSubworks = [];
    const subworkIdMapping = {}; // Map original subwork ID to new subwork ID
    
    for (const sourceSubwork of sourceSubworkData) {
      try {
        const subworkPayload = {
          ...sourceSubwork,
          id: undefined, // Remove ID so new one is generated
          revisionId: parseInt(newRevisionId),
          createdDate: new Date().toISOString(),
          updatedDate: new Date().toISOString(),
          createdBy: parseInt(uid),
          updatedBy: parseInt(uid)
        };
        
        const subworkResponse = await fetch(`${API_BASE_URL}/api/subwork`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${currentToken}`
          },
          body: JSON.stringify(subworkPayload)
        });
        
        if (!subworkResponse.ok) {
          if (subworkResponse.status === 401) {
            toast.dismiss(loadingToast);
            toast.error('Session expired. Please login again.');
            navigate('/signin');
            return;
          }
          throw new Error(`Failed to create subwork: ${subworkResponse.status}`);
        }
        
        const newSubwork = await subworkResponse.json();
        newSubworks.push(newSubwork);
        subworkIdMapping[sourceSubwork.originalId] = newSubwork.id;
        
  
        
      } catch (error) {
        console.error(`Error creating subwork ${sourceSubwork.subworkName}:`, error);
        toast.error(`Failed to create subwork: ${sourceSubwork.subworkName}`);
      }
    }
    
    // STEP 2: Duplicate items
    const newItems = [];
    const itemIdMapping = {}; // Map original item ID to new item ID
    
    for (const sourceItem of sourceItemsData) {
      try {
        const newSubworkId = subworkIdMapping[sourceItem.originalSubworkId];
        if (!newSubworkId) {
          console.warn(`No new subwork ID found for original subwork ${sourceItem.originalSubworkId}`);
          continue;
        }
        
        const itemPayload = {
          ...sourceItem,
          id: undefined, // Remove ID so new one is generated
          subworkId: newSubworkId, // Use new subwork ID
          revisionId: parseInt(newRevisionId),
          createdDate: new Date().toISOString(),
          updatedDate: new Date().toISOString(),
          createdBy: parseInt(uid),
          updatedBy: parseInt(uid)
        };
        
        const itemResponse = await fetch(`${API_BASE_URL}/api/txn-items`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${currentToken}`
          },
          body: JSON.stringify(itemPayload)
        });
        
        if (!itemResponse.ok) {
          if (itemResponse.status === 401) {
            toast.dismiss(loadingToast);
            toast.error('Session expired. Please login again.');
            navigate('/signin');
            return;
          }
          throw new Error(`Failed to create item: ${itemResponse.status}`);
        }
        
        const newItem = await itemResponse.json();
        newItems.push({
          ...newItem,
          subworkId: newSubworkId,
          subworkName: sourceItem.subworkName
        });
        itemIdMapping[sourceItem.originalId] = newItem.id;
        
    
        
      } catch (error) {
        console.error(`Error creating item ${sourceItem.itemNo}:`, error);
        toast.error(`Failed to create item: ${sourceItem.itemNo}`);
      }
    }
    
    // STEP 3: Duplicate measurements
    const newMeasurements = [];
    
    for (const sourceMeasurement of sourceMeasurementsData) {
      try {
        const newItemId = itemIdMapping[sourceMeasurement.originalItemId];
        const newSubworkId = subworkIdMapping[sourceMeasurement.originalSubworkId];
        
        if (!newItemId || !newSubworkId) {
          console.warn(`No new IDs found for measurement - item: ${sourceMeasurement.originalItemId}, subwork: ${sourceMeasurement.originalSubworkId}`);
          continue;
        }
        
        const measurementPayload = {
          ...sourceMeasurement,
          id: undefined, // Remove ID so new one is generated
          itemId: newItemId, // Use new item ID
          createdDate: new Date().toISOString(),
          updatedDate: new Date().toISOString(),
          createdBy: parseInt(uid),
          updatedBy: parseInt(uid)
        };
        
        const measurementResponse = await fetch(`${API_BASE_URL}/api/txn-items-mts`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${currentToken}`
          },
          body: JSON.stringify(measurementPayload)
        });
        
        if (!measurementResponse.ok) {
          if (measurementResponse.status === 401) {
            toast.dismiss(loadingToast);
            toast.error('Session expired. Please login again.');
            navigate('/signin');
            return;
          }
          throw new Error(`Failed to create measurement: ${measurementResponse.status}`);
        }
        
        const newMeasurement = await measurementResponse.json();
        newMeasurements.push({
          ...newMeasurement,
          itemId: newItemId,
          itemNo: sourceMeasurement.itemNo,
          subworkId: newSubworkId,
          subworkName: sourceMeasurement.subworkName
        });
        
       
        
      } catch (error) {
        console.error(`Error creating measurement:`, error);
        toast.error(`Failed to create measurement`);
      }
    }
    
    // STEP 4: Organize new data and update component state
    const dataBySubwork = {};
    newSubworks.forEach(subwork => {
      const subworkItems = newItems.filter(item => item.subworkId === subwork.id);
      const subworkMeasurements = newMeasurements.filter(measurement => measurement.subworkId === subwork.id);
      
      dataBySubwork[subwork.id] = {
        subwork: subwork,
        items: subworkItems,
        measurements: subworkMeasurements
      };
    });
    
    // Update component state
    setSubworkData(newSubworks);
    setItemsData(newItems);
    setMeasurementsData(newMeasurements);
    setDataBySubwork(dataBySubwork);
    
    // Store new data in localStorage for reference
    localStorage.setItem('subworkData', JSON.stringify(newSubworks));
    localStorage.setItem('revisionItems', JSON.stringify(newItems));
    localStorage.setItem('revisionMeasurements', JSON.stringify(newMeasurements));
    localStorage.setItem('revisionDataBySubwork', JSON.stringify(dataBySubwork));
    localStorage.setItem('totalSubworks', newSubworks.length.toString());
    localStorage.setItem('totalItems', newItems.length.toString());
    localStorage.setItem('totalMeasurements', newMeasurements.length.toString());
    
    // Clear duplication flags
    localStorage.removeItem('needsDuplication');
    localStorage.removeItem('sourceSubworkData');
    localStorage.removeItem('sourceRevisionItems');
    localStorage.removeItem('sourceRevisionMeasurements');
    localStorage.removeItem('sourceDataBySubwork');
    localStorage.removeItem('isDuplicatingRevision');
    
    // Set edit mode for the new revision
    localStorage.setItem('editingRevision', 'true');
    setIsEditMode(true);
    setEditingRevision(true);
    
    toast.dismiss(loadingToast);
    toast.success(`Revision ${newRevisionNumber} duplicated successfully! Created ${newSubworks.length} subworks, ${newItems.length} items, ${newMeasurements.length} measurements.`);
    
  } catch (error) {
    console.error('Error duplicating revision data:', error);
    toast.error('Failed to duplicate revision data: ' + error.message);
  }
};

// Helper functions (keep existing ones and add new ones)
const getSubworkData = (subworkId) => {
  const dataBySubworkStr = localStorage.getItem('revisionDataBySubwork');
  if (dataBySubworkStr) {
    const dataBySubwork = JSON.parse(dataBySubworkStr);
    return dataBySubwork[subworkId] || null;
  }
  return null;
};

const getItemsForSubwork = (subworkId) => {
  const itemsDataStr = localStorage.getItem('revisionItems');
  if (itemsDataStr) {
    const itemsData = JSON.parse(itemsDataStr);
    return itemsData.filter(item => item.subworkId === subworkId);
  }
  return [];
};

const getMeasurementsForItem = (itemId) => {
  const measurementsDataStr = localStorage.getItem('revisionMeasurements');
  if (measurementsDataStr) {
    const measurementsData = JSON.parse(measurementsDataStr);
    return measurementsData.filter(measurement => measurement.itemId === itemId);
  }
  return [];
};

// Updated render function for mode indicator
const renderModeIndicator = () => {
  const editMode = localStorage.getItem('editMode');
  const revisionNumber = localStorage.getItem('revisionNumber');
  const isDuplicatingRevision = localStorage.getItem('isDuplicatingRevision');
  const editingRevision = localStorage.getItem('editingRevision');
  
  if (editMode === 'true') {
    if (isDuplicatingRevision === 'true') {
      return (
        <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm">
                <strong>Duplicating Mode:</strong> Creating new revision {revisionNumber} from source revision
              </p>
            </div>
          </div>
        </div>
      );
    } else if (editingRevision === 'true') {
      return (
        <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.379-8.379-2.828-2.828z" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm">
                <strong>Edit Mode:</strong> Editing revision {revisionNumber}
              </p>
            </div>
          </div>
        </div>
      );
    }
  }
  
  return null;
};
// Auto-save when form changes
// useEffect(() => {
//   if (currentSubworkId && itemForm.itemNo && itemForm.category && itemForm.descriptionOfItem) {
//     autoSaveItem(currentSubworkId);
//   }
// }, [itemForm, currentSubworkId]);
useEffect(() => {
  // Clear existing timeout
  if (autoSaveTimeout) {
    clearTimeout(autoSaveTimeout);
    setAutoSaveTimeout(null);
  }

  // Only set timeout if not in edit mode and form has required data
  if (!editingItemId && currentSubworkId && itemForm.itemNo?.trim() && itemForm.category?.trim() && itemForm.descriptionOfItem?.trim()) {
    const timeout = setTimeout(() => {
      autoSaveItem(currentSubworkId);
    }, 2000); // 2 second delay

    setAutoSaveTimeout(timeout);
  }
  
  // Cleanup timeout on unmount
  return () => {
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }
  };
}, [itemForm.itemNo, itemForm.category, itemForm.descriptionOfItem, currentSubworkId, editingItemId]);

  
const confirmDeleteItem = async (itemId) => {
  const loadingToast = toast.loading('Deleting item and associated data...');
  
  try {
    // First, delete associated measurements if any
    try {
      const measurementsResponse = await fetch(`${API_BASE_URL}/api/txn-measurements/item/${itemId}`, {
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${jwtToken}`
        }
      });
      
      if (measurementsResponse.ok) {
       
      }
    } catch (measurementError) {
      console.warn('Error deleting measurements:', measurementError);
      // Continue with item deletion even if measurement deletion fails
    }

    // Then, delete associated materials if any
    try {
      const materialsResponse = await fetch(`${API_BASE_URL}/api/txn-item-properties/item/${itemId}`, {
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${jwtToken}`
        }
      });
      
      if (materialsResponse.ok) {
       
      }
    } catch (materialError) {
      console.warn('Error deleting materials:', materialError);
      // Continue with item deletion even if material deletion fails
    }

    // Finally, delete the item itself
    const response = await fetch(`${API_BASE_URL}/api/txn-items/${itemId}`, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${jwtToken}`
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP error! Status: ${response.status}, Message: ${errorText}`);
    }
    
    // Find the subwork that contains this item and reload its items
    const subworkId = Object.keys(items).find(key => 
      items[key].some(item => item.id === itemId)
    );
    
    if (subworkId) {
      await loadSubworkItems(parseInt(subworkId, 10));
    
    }
    
    // Clear any editing states if this item was being edited
    if (editingItemId === itemId) {
      setEditingItemId(null);
      resetItemForm();
    }
    
    // Hide measurement sections for this item
    setVisibleMeasurements(prev => {
      const newState = { ...prev };
      delete newState[itemId];
      return newState;
    });
    
    // Clear item total quantities
    setItemTotalQuantities(prev => {
      const newState = { ...prev };
      delete newState[itemId];
      return newState;
    });
    
    toast.dismiss(loadingToast);
    toast.success('Item and all associated data deleted successfully!');
    
  } catch (error) {
    console.error("Error deleting item:", error);
    toast.dismiss(loadingToast);
    toast.error(`Failed to delete item: ${error.message}`);
  }
};
  // Update work order status
  const updateWorkOrderStatus = () => {
 
  };
  const highlightSearchTerm = (text, searchTerm) => {
  if (!searchTerm || !text) return text;
  
  const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
  const parts = String(text).split(regex);
  
  return parts.map((part, index) => 
    regex.test(part) ? (
      <span key={index} className="bg-yellow-200 text-gray-900 font-medium">
        {part}
      </span>
    ) : part
  );
};

// Update the ItemDropdown component to use the correct field for display
const SearchableDropdown = ({ 
  options, 
  value, 
  onChange, 
  searchKey, 
  displayKey, 
  placeholder = "Select an option...",
  error,
  className = "",
  disabled = false,
  showAllOnFocus = true,
  minSearchLength = 0,
  filterUnique = false,
  loading = false,
  onFocus,
  onBlur,
  maxHeight = 300,
  zIndex = 1000
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [isFocused, setIsFocused] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0, width: 0 });
  const dropdownRef = useRef(null);
  const inputRef = useRef(null);
  const optionsRef = useRef(null);

  // Ensure options is an array and handle loading state
  const safeOptions = Array.isArray(options) ? options : [];

  // Memoized filtering logic for better performance
  const filteredOptions = React.useMemo(() => {
    if (isLoading || !safeOptions.length) return [];

    // Remove duplicates if filterUnique is true
    const uniqueOptions = filterUnique ? 
      safeOptions.reduce((acc, current) => {
        if (!current || typeof current !== 'object') return acc;
        const key = current[displayKey];
        if (key && !acc.find(item => item[displayKey] === key)) {
          acc.push(current);
        }
        return acc;
      }, []) : safeOptions;

    // Filter based on search query
    const filtered = uniqueOptions.filter(option => {
      if (!option || typeof option !== 'object') return false;
      
      // Show all options on focus if no search query
      if (showAllOnFocus && isFocused && (!searchQuery || searchQuery.length < minSearchLength)) {
        return true;
      }
      
      if (!searchQuery || searchQuery.length < minSearchLength) {
        return showAllOnFocus;
      }

      const searchValue = option[searchKey];
      if (!searchValue) return false;

      const searchString = String(searchValue).toLowerCase();
      const queryString = searchQuery.toLowerCase().trim();
      
      return searchString.includes(queryString);
    });

    // Sort filtered options
    return filtered.sort((a, b) => {
      const aVal = String(a[displayKey] || '');
      const bVal = String(b[displayKey] || '');
      return aVal.localeCompare(bVal, undefined, { numeric: true });
    });
  }, [safeOptions, searchQuery, showAllOnFocus, isFocused, minSearchLength, filterUnique, displayKey, searchKey, isLoading]);

  // Calculate dropdown position
  const updateDropdownPosition = useCallback(() => {
    if (dropdownRef.current) {
      const rect = dropdownRef.current.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const spaceBelow = viewportHeight - rect.bottom;
      
      setDropdownPosition({
        top: spaceBelow < maxHeight ? rect.top - maxHeight - 10 : rect.bottom + 4,
        left: rect.left,
        width: rect.width
      });
    }
  }, [maxHeight]);

  // Handle clicking outside to close dropdown
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        // Check if click is on the floating dropdown
        const floatingDropdown = document.getElementById(`dropdown-${zIndex}`);
        if (floatingDropdown && floatingDropdown.contains(event.target)) {
          return;
        }
        handleClose();
      }
    };

    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }
  }, [isOpen, zIndex]);

  // Handle ESC key to close dropdown
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === 'Escape' && isOpen) {
        handleClose();
      }
    };

    if (isOpen) {
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }
  }, [isOpen]);

  // Update position when dropdown opens
  useEffect(() => {
    if (isOpen) {
      updateDropdownPosition();
      // Update position on scroll or resize
      const handlePositionUpdate = () => updateDropdownPosition();
      window.addEventListener('scroll', handlePositionUpdate, true);
      window.addEventListener('resize', handlePositionUpdate);
      
      return () => {
        window.removeEventListener('scroll', handlePositionUpdate, true);
        window.removeEventListener('resize', handlePositionUpdate);
      };
    }
  }, [isOpen, updateDropdownPosition]);

  const handleClose = useCallback(() => {
    setIsOpen(false);
    setIsFocused(false);
    setSearchQuery('');
    if (onBlur) onBlur();
  }, [onBlur]);

  const handleOpen = useCallback(() => {
    if (disabled) return;
    
    setIsOpen(true);
    setIsFocused(true);
    
    // Focus input after opening
    setTimeout(() => {
      const floatingInput = document.querySelector(`#dropdown-${zIndex} input`);
      if (floatingInput) {
        floatingInput.focus();
      }
    }, 50);
    
    if (onFocus) onFocus();
  }, [disabled, onFocus, zIndex]);

  const handleOptionClick = useCallback((option) => {
   
    onChange(option[displayKey], option);
    handleClose();
  }, [onChange, displayKey, handleClose]);

  const handleInputChange = useCallback((e) => {
    const query = e.target.value;
    setSearchQuery(query);
    
    if (!isOpen) {
      setIsOpen(true);
      setIsFocused(true);
    }
  }, [isOpen]);

  const handleInputFocus = useCallback(() => {
    setIsFocused(true);
    if (!isOpen) {
      setIsOpen(true);
    }
  }, [isOpen]);

  const clearSearch = useCallback(() => {
    setSearchQuery('');
    const floatingInput = document.querySelector(`#dropdown-${zIndex} input`);
    if (floatingInput) {
      floatingInput.focus();
    }
  }, [zIndex]);

  return (
    <>
      <div className={`relative ${className}`} ref={dropdownRef}>
        {/* Main dropdown trigger */}
        <div 
          className={`w-full p-2 border ${error ? 'border-red-500 bg-red-50' : 'border-gray-300'} rounded flex justify-between items-center cursor-pointer bg-white hover:border-gray-400 transition-colors ${disabled ? 'bg-gray-100 cursor-not-allowed opacity-60' : ''} ${isOpen ? 'border-blue-400 ring-1 ring-blue-400' : ''}`}
          onClick={handleOpen}
        >
          <span className={`flex-1 truncate ${value ? 'text-gray-800' : 'text-gray-500'}`}>
            {value || placeholder}
          </span>
          <div className="flex items-center space-x-1 ml-2">
            {(loading || isLoading) && (
              <FontAwesomeIcon icon={faSpinner} spin className="text-gray-400 text-sm" />
            )}
            <FontAwesomeIcon 
              icon={isOpen ? faChevronUp : faChevronDown} 
              className="text-gray-400 text-sm"
            />
          </div>
        </div>
        
        {/* Error message */}
        {error && (
          <p className="text-red-500 text-xs mt-1 font-medium">{error}</p>
        )}
      </div>

      {/* Floating dropdown options - rendered at document body level */}
      {isOpen && !disabled && (
        <div 
          id={`dropdown-${zIndex}`}
          className="fixed bg-white border border-gray-300 rounded-lg shadow-lg overflow-hidden"
          style={{
            top: `${dropdownPosition.top}px`,
            left: `${dropdownPosition.left}px`,
            width: `${dropdownPosition.width}px`,
            maxHeight: `${maxHeight}px`,
            zIndex: zIndex + 1000 // Ensure it's above everything
          }}
          ref={optionsRef}
        >
          {/* Search input */}
          <div className="sticky top-0 bg-white p-3 border-b border-gray-200 z-10">
            <div className="relative">
              <FontAwesomeIcon 
                icon={faSearch} 
                className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-sm"
              />
              <input
                ref={inputRef}
                type="text"
                placeholder={`Search ${displayKey}...`}
                value={searchQuery}
                onChange={handleInputChange}
                onFocus={handleInputFocus}
                className="w-full pl-10 pr-10 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 text-sm"
                onClick={(e) => e.stopPropagation()}
                autoComplete="off"
              />
              {searchQuery && (
                <button
                  onClick={clearSearch}
                  className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
                >
                  <FontAwesomeIcon icon={faTimes} className="text-sm" />
                </button>
              )}
            </div>
          </div>
          
          {/* Options list */}
         <div className="overflow-y-auto" style={{ maxHeight: `${maxHeight - 80}px` }}>
  {isLoading ? (
    <div className="p-4 text-center">
      <FontAwesomeIcon icon={faSpinner} spin className="text-gray-400 text-lg mb-2" />
      <p className="text-gray-500 text-sm">Loading options...</p>
    </div>
  ) : filteredOptions.length > 0 ? (
    filteredOptions.map((option, index) => (
      <div
        key={`${option[displayKey]}-${option.id || index}`}
        className="p-3 hover:bg-blue-50 cursor-pointer border-b border-gray-50 last:border-b-0 transition-colors"
        onClick={() => handleOptionClick(option)}
      >
        <div className="font-medium text-gray-800 text-sm">
          {highlightSearchTerm(option[displayKey], searchQuery)}
        </div>
        {displayKey !== 'description' && option.description && (
          <div className="text-xs text-gray-500 mt-1 truncate">
            {highlightSearchTerm(option.description, searchQuery)}
          </div>
        )}
        {/* Additional info for better UX */}
        {option.category && displayKey !== 'category' && (
          <div className="text-xs text-blue-600 mt-1">
            Category: {highlightSearchTerm(option.category, searchQuery)}
          </div>
        )}
      </div>
    ))
  ) : (
    <div className="p-6 text-center">
      <p className="text-gray-500 text-sm">
        {safeOptions.length === 0 
          ? "No options available"
          : searchQuery 
            ? `No ${displayKey} found matching "${searchQuery}"`
            : "Start typing to search..."
        }
      </p>
      {safeOptions.length === 0 && (
        <button
          onClick={() => window.location.reload()}
          className="mt-2 text-blue-600 hover:text-blue-800 text-sm underline"
        >
          Refresh to reload options
        </button>
      )}
    </div>
  )}
</div>
          
        </div>
      )}
    </>
  );
};
// Improved fetchItemOptions function with caching and error handling
const handleItemFieldChange = (field, value, subworkId, selectedOption = null) => {
 
  
  // Set the current subwork ID when field changes
  if (subworkId) {
    setCurrentSubworkId(subworkId);
  }

  // Clear any pending auto-save timeout to prevent conflicts - MOVED TO TOP
  if (autoSaveTimeout) {
    clearTimeout(autoSaveTimeout);
    setAutoSaveTimeout(null);
   
  }

  // Find the selected item from options if not provided
  let selectedItem = selectedOption;
  
  if (!selectedItem && value) {
    // Try to find the item by the specific field that was changed
    selectedItem = itemOptions.find(option => {
      if (field === 'itemNo') return option.ssrItemId === value;
      if (field === 'category') return option.category === value;
      if (field === 'descriptionOfItem') return option.description === value;
      return false;
    });
    
  
  }

  if (selectedItem) {
    // Check for duplicates BEFORE updating the form (only for new items OR when changing item number in edit mode)
    if (!editingItemId || (editingItemId && field === 'itemNo')) {
      const existingItems = items[subworkId] || [];
      const isDuplicate = existingItems.some(item =>
        item.itemNo === selectedItem.ssrItemId?.trim() && item.id !== editingItemId
      );

      if (isDuplicate) {
        // Show error message immediately
        toast.error(`Item "${selectedItem.ssrItemId}" already exists in this subwork`);
        
        // Set error state for the itemNo field
        setItemFormErrors(prev => ({
          ...prev,
          itemNo: true
        }));
        
        // Don't update the form with the duplicate item
        // Just update the specific field that was changed but don't auto-populate
        setItemForm(prev => ({ 
          ...prev, 
          [field]: value,
          fkSubworkId: subworkId || currentSubworkId || currentSubworkForForm?.id
        }));
        

        return; // Exit early to prevent form population
      }
    }

    // Auto-populate related fields
    const updatedForm = {
      [field]: value,
      fkSubworkId: subworkId || currentSubworkId || currentSubworkForForm?.id
    };

    // Auto-populate based on the field that was changed
    if (field === 'itemNo') {
      updatedForm.category = selectedItem.category || '';
      updatedForm.descriptionOfItem = selectedItem.description || '';
      updatedForm.smallUnit = selectedItem.smallUnit || '';
      updatedForm.fullUnit = selectedItem.fullUnit || '';
      updatedForm.completedRate = selectedItem.completedRate || 0;
      updatedForm.labourRate = selectedItem.labourRate || 0;
      updatedForm.detailedItemId = selectedItem.id || '';
    } else if (field === 'category') {
      updatedForm.itemNo = selectedItem.ssrItemId || '';
      updatedForm.descriptionOfItem = selectedItem.description || '';
      updatedForm.smallUnit = selectedItem.smallUnit || '';
      updatedForm.fullUnit = selectedItem.fullUnit || '';
      updatedForm.completedRate = selectedItem.completedRate || 0;
      updatedForm.labourRate = selectedItem.labourRate || 0;
      updatedForm.detailedItemId = selectedItem.id || '';
    } else if (field === 'descriptionOfItem') {
      updatedForm.itemNo = selectedItem.ssrItemId || '';
      updatedForm.category = selectedItem.category || '';
      updatedForm.smallUnit = selectedItem.smallUnit || '';
      updatedForm.fullUnit = selectedItem.fullUnit || '';
      updatedForm.completedRate = selectedItem.completedRate || 0;
      updatedForm.labourRate = selectedItem.labourRate || 0;
      updatedForm.detailedItemId = selectedItem.id || '';
    }

    setItemForm(prev => ({ ...prev, ...updatedForm }));
    setSelectedItem(selectedItem);
    
    // Clear any errors for the updated fields
    setItemFormErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[field];
      // Clear related field errors when auto-populating
      if (field === 'itemNo' || field === 'category' || field === 'descriptionOfItem') {
        delete newErrors.itemNo;
        delete newErrors.category;
        delete newErrors.descriptionOfItem;
      }
      return newErrors;
    });

    // Set up auto-save only for new items (not when editing)
    if (!editingItemId && 
        updatedForm.itemNo?.trim() && 
        updatedForm.category?.trim() && 
        updatedForm.descriptionOfItem?.trim()) {
      
      
      
      // Create new timeout for auto-save
      const timeoutId = setTimeout(() => {
       
        autoSaveItem(subworkId);
        setAutoSaveTimeout(null); // Clear the timeout reference
      }, 2000); // Increased to 2 seconds to give user more time
      
      setAutoSaveTimeout(timeoutId);
   
    }
  } else {
    // Just update the specific field
    setItemForm(prev => ({ 
      ...prev, 
      [field]: value,
      fkSubworkId: subworkId || currentSubworkId || currentSubworkForForm?.id
    }));
    
    // Clear error for the updated field
    setItemFormErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[field];
      return newErrors;
    });

  }
};

const handleShowNewItemForm = (subworkId) => {
  // Close all measurement sections when starting to add new item
  setVisibleMeasurements({});
  
  // Clear any existing form data and errors
  resetItemForm();
  setItemFormErrors({});
  
  // Set current subwork
  setCurrentSubworkId(subworkId);
  
  // Show the form for this subwork
  setShowNewItemForm(prev => ({
    ...prev,
    [subworkId]: true
  }));
};
const handleHideNewItemForm = (subworkId) => {
  setShowNewItemForm(prev => ({
    ...prev,
    [subworkId]: false
  }));
  resetItemForm();
  setItemFormErrors({});
};
const handleKeyDown = (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    // Only allow manual save if all required fields are filled
    if (itemForm.itemNo?.trim() && 
        itemForm.category?.trim() && 
        itemForm.descriptionOfItem?.trim()) {
      saveItem(true);
    }
  }
};
const resetItemForm = () => {
  const newForm = {
    id: 0,
    srNo: 0,
    itemNo: "",
    category: "",
    descriptionOfItem: "",
    floorLiftRise: "Ground floor",
    fkSubworkId: currentSubworkId || 0,
    fkWorkorderId: parseInt(workOrderInfo?.workOrderId || 0),
    completedRate: 0,
    labourRate: 0,
    scadaFlag: false,
    smallUnit: "",
    fullUnit: "",
    additionalSpecification: "",
    detailedItemId: 0
  };
  
  setItemForm(newForm);
  setSelectedItem(null);
  setItemFormErrors({});
  
  // Clear auto-save timeout
  if (autoSaveTimeout) {
    clearTimeout(autoSaveTimeout);
    setAutoSaveTimeout(null);
  }
  
 
};
  // Update revision status
  const updateRevisionStatus = () => {
   
    // This would be an API call to update the revision status
  };
  const handleEscapeKey = (e) => {
  if (e.key === 'Escape') {
    // Close any open new item forms
    setShowNewItemForm({});
    // Close any open measurements
    setVisibleMeasurements({});
    // Cancel editing
    if (editingItemId) {
      setEditingItemId(null);
      resetItemForm();
    }
  }
};

  useEffect(() => {
  document.addEventListener('keydown', handleEscapeKey);
  return () => {
    document.removeEventListener('keydown', handleEscapeKey);
  };
}, [editingItemId]);
  
  
useEffect(() => {
  if (itemOptions?.length > 0) {
   
  }
}, [itemOptions]);

    const toggleMeasurements = (itemId) => {
       const hasOpenNewItemForm = Object.values(showNewItemForm).some(Boolean);
  
  if ((hasOpenNewItemForm || editingItemId) && !visibleMeasurements[itemId]) {
    toast.warning('Please complete the current item operation before opening measurements');
    return;
  }
    setVisibleMeasurements(prev => ({
      ...prev,
      [itemId]: !prev[itemId]
    }));
  };
  // In your subestimate component, when passing props to measurement component

const calculateItemRA = async (item) => {
    try {
        const response = await fetch(`${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`, {
            headers: {
                Authorization: `Bearer ${jwtToken}`,
                "Content-Type": "application/json",
            },
        });
        
        if (!response.ok) {
            return 0;
        }
        
        const measurements = await response.json();
        const quantity = Array.isArray(measurements) 
            ? measurements.reduce((sum, m) => sum + parseFloat(m.quantity || 0), 0) 
            : 0;
            
        return quantity * item.labourRate;
    } catch (err) {
        console.error("Error calculating RA for item", item.id, err);
        return 0;
    }
};
const checkItemOptionsHealth = () => {
  if (!itemOptions || itemOptions.length === 0) {
    console.warn('itemOptions is empty or undefined');
    return false;
  }
  
  const hasDescriptions = itemOptions.some(item => item.description); // Fixed: use 'description'
  if (!hasDescriptions) {
    console.warn('No items have description field');
    return false;
  }
  
  return true;
};
useEffect(() => {
  checkItemOptionsHealth();
}, [itemOptions]);
const renderMeasurementTable = (item) => {
  if (!visibleMeasurements[item.id]) return null;
  
  const currentSubworkItems = items[item.fkSubworkId] || [];
  const previousItems = [];
  
  for (const subItem of currentSubworkItems) {
    if (subItem.id === item.id) break;
    previousItems.push(subItem);
  }
  
  return (
    <MeasurementTable 
  itemId={itemId}
  token={jwtToken} 
                      unitLabel={item.smallUnit || "Cu.M."} 
                  multifloor={parseInt(workOrderInfo.multifloor) === 1}
  fkSsrId={parseInt(workOrderInfo.fkSsrId) || 0} 
  itemsFromParent={itemsFromParent}
  onMeasurementDrop={onMeasurementDrop}
  completedRate={completedRate}
  onQuantityUpdate={onQuantityUpdate}
/>
  );
};
useEffect(() => {
  if (itemOptions?.length > 0) {
  
  }
}, [itemOptions]);
const handleAutoSave = () => {
  // Clear existing timeout
  if (autoSaveTimeout) {
    clearTimeout(autoSaveTimeout);
    setAutoSaveTimeout(null);
  }

  // Only set timeout if not in edit mode and we have current subwork
  if (!editingItemId && currentSubworkId) {
    const timeout = setTimeout(() => {
      if (itemForm.itemNo?.trim() && itemForm.category?.trim() && itemForm.descriptionOfItem?.trim()) {
        autoSaveItem(currentSubworkId);
      }
    }, 2000);

    setAutoSaveTimeout(timeout);
  }
};

useEffect(() => {
  const handleVisibilityChange = () => {
    if (!document.hidden) {
      // Page became visible - check if data needs refresh
      const lastFetchTime = parseInt(localStorage.getItem('last_fetch_time') || '0', 10);
      const shouldRefresh = Date.now() - lastFetchTime > 600000; // 10 minutes
      
      if (shouldRefresh) {
        const workOrderId = localStorage.getItem('workorderId');
        const reviseId = localStorage.getItem('reviseId');
        
        if (workOrderId && reviseId) {
          fetchSubworks(reviseId, workOrderId, true);
        }
      }
    }
  };

  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  return () => {
    document.removeEventListener('visibilitychange', handleVisibilityChange);
  };
}, []);
const handleMeasurementCollapseChange = (itemId, isCollapsed) => {
  setVisibleMeasurements(prev => ({
    ...prev,
    [itemId]: !isCollapsed
  }));
};

const calculateSubworkTotal = (subworkId) => {
  const subworkItems = items[subworkId] || [];
  return subworkItems.reduce((total, item) => {
    const quantity = itemTotalQuantities[item.id] || 0;
    const rate = item.completedRate || 0;
    return total + (quantity * rate);
  }, 0);
};
const handleNewItemAdded = (newItemId, subworkId) => {
  // Auto-expand measurements section for newly added item
  setVisibleMeasurements(prev => ({
    ...prev,
    [newItemId]: true
  }));
};
  const navigateToPdfPreview = async () => {
    const allSubworkIds = Object.keys(items);
    
    if (allSubworkIds.length === 0) {
      toast.error("No subworks or items found to generate PDF");
      return;
    }
 
    const allItemsWithMeasurements = await Promise.all(
      allSubworkIds.flatMap(subworkId =>
        (items[subworkId] || []).map(async (item) => {
          try {
            const response = await fetch(`${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`, {
              headers: {
                Authorization: `Bearer ${jwtToken}`,
                "Content-Type": "application/json",
              },
            });
            const measurements = await response.json();
            return { ...item, measurements: Array.isArray(measurements) ? measurements : [] };
          } catch (err) {
            console.error("Error fetching measurements for item", item.id, err);
            return { ...item, measurements: [] };
          }
        })
      )
    );
  
    localStorage.setItem("subRecordCache", JSON.stringify(allItemsWithMeasurements));
    localStorage.setItem("pdfWorkName", workOrderInfo.nameOfWork);
    localStorage.setItem("pdfWorkOrderId", workOrderInfo.autogenerated);
    localStorage.setItem("pdfRevisionNumber", workOrderInfo.reviseno);
  localStorage.setItem("defaultActiveComponent", "abstract");
    toast.success("Preparing full PDF...");
    navigate("/pdf-preview");
  };
   const navigateToLead = async () => {
    const allSubworkIds = Object.keys(items);
    
    if (allSubworkIds.length === 0) {
      toast.error("No subworks or items found to generate PDF");
      return;
    }
 
    const allItemsWithMeasurements = await Promise.all(
      allSubworkIds.flatMap(subworkId =>
        (items[subworkId] || []).map(async (item) => {
          try {
            const response = await fetch(`${API_BASE_URL}/api/txn-items-mts/ByItemId/${item.id}`, {
              headers: {
                Authorization: `Bearer ${jwtToken}`,
                "Content-Type": "application/json",
              },
            });
            const measurements = await response.json();
            return { ...item, measurements: Array.isArray(measurements) ? measurements : [] };
          } catch (err) {
            console.error("Error fetching measurements for item", item.id, err);
            return { ...item, measurements: [] };
          }
        })
      )
    );
  
    localStorage.setItem("subRecordCache", JSON.stringify(allItemsWithMeasurements));
    localStorage.setItem("pdfWorkName", workOrderInfo.nameOfWork);
    localStorage.setItem("pdfWorkOrderId", workOrderInfo.autogenerated);
    localStorage.setItem("pdfRevisionNumber", workOrderInfo.reviseno);
  
    toast.success("Preparing full PDF...");
    navigate("/lead");
  };
const calculateAllSubworksTotal = () => {
  const allSubworkIds = Object.keys(items);
  return allSubworkIds.reduce((grandTotal, subworkId) => {
    return grandTotal + calculateSubworkTotal(subworkId);
  }, 0);
};


  
  
  return (
    <motion.div 
      className="container mx-auto p-4"
      initial="hidden"
      animate="visible"
      variants={containerVariants}
    >
      {/* Toast Container */}
      {/* <Toaster 
        position="top-right"
        toastOptions={{
          duration: 3000,
          style: {
            background: '#fff',
            color: '#333',
            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
            borderRadius: '8px',
            padding: '12px 16px',
          },
          success: {
            style: {
              border: '1px solid #10B981',
            },
          },
          error: {
            style: {
              border: '1px solid #EF4444',
            },
          },
        }}
      /> */}
         
      {/* Stepper Component */}
      <motion.div 
        className="mb-6 mt-2 p-4 border border-gray-300 rounded bg-white shadow-md"
        variants={itemVariants}
      >
        <Stepper currentStep={2} />
      </motion.div>
      
      {/* Work Order Information Card */}
<motion.div className="bg-white border border-gray-200 rounded-lg p-6 mb-6 shadow-md" variants={itemVariants}>
  <h2 className="text-xl font-bold mb-4 text-blue-700 border-b pb-2">Estimate Details</h2>
  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
    <div className="flex flex-col">
      <span className="text-gray-600 text-sm">Estimate ID</span>
      <span className="font-semibold text-lg">{workOrderInfo.autogenerated || 'N/A'}</span>
    </div>
    <div className="flex flex-col">
      <span className="text-gray-600 text-sm">Revision No</span>
      <span className="font-semibold text-lg" key={workOrderInfo.reviseno}>
        {workOrderInfo.reviseno || 'Loading...'}
      </span>
    </div>
    <div className="flex flex-col">
      <span className="text-gray-600 text-sm">Specified Area</span>
      <span className="font-semibold text-lg">{workOrderInfo.area || 'N/A'}</span>
    </div>
    <div className="col-span-2 flex flex-col">
      <span className="text-gray-600 text-sm">Name Of Work</span>
      <span className="font-semibold text-lg">{workOrderInfo.nameOfWork || 'N/A'}</span>
    </div>
    <div className="flex flex-col">
  <span className="text-gray-600 text-sm">SSR</span>
  <span className="font-semibold text-lg">
    {workOrderInfo.ssrName || workOrderInfo.ssr || 'N/A'}
  </span>
</div>

  </div>
  
  {/* Total Amount Section - Add this new section */}
 <div className="mt-6 pt-4 border-t border-gray-200">
  <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
    <div className="flex justify-between items-center">
      <span className="text-base font-medium text-gray-700">
        Total Amount Before RA (All SubEstimates):
      </span>
      <span className="text-2xl font-bold text-blue-600">
        {isLoading ? (
          <span className="text-gray-500">Loading...</span>
        ) : (
          `₹${calculateAllSubworksTotal().toLocaleString('en-IN')}`
        )}
      </span>
    </div>
  </div>
</div>
  
  <Toaster />
</motion.div>

     
     

{/* Subworks Section */}
<motion.div className="mb-6 bg-white border border-gray-200 rounded-lg shadow-md overflow-hidden" variants={itemVariants}>
  <div className="bg-blue-700 text-white py-3 px-6 flex justify-between items-center">
    <h2 className="text-lg font-bold">SubEstimate</h2>
    <span className="bg-blue-600 text-white px-3 py-1 rounded-full text-sm font-medium">
      {subworks.length} {subworks.length === 1 ? 'SubEstimate' : 'SubEstimates'}
    </span>
  </div>
{isLoading ? (
  <div className="flex flex-col items-center justify-center p-12 bg-gray-50 rounded-lg border border-gray-200">
    <div className="relative">
      <LuLoaderCircle className="w-10 h-10 text-orange-500 animate-spin" />
      <div className="absolute inset-0 w-10 h-10 border-2 border-orange-200 rounded-full animate-pulse"></div>
    </div>
    <p className="text-orange-600 font-medium mt-4">Loading SubEstimate...</p>
 
  </div>
) : subworks.length === 0 ? (
  <div className="flex flex-col items-center justify-center p-12 bg-gray-50 rounded-lg border border-gray-200">
    <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mb-4">
      <FontAwesomeIcon icon={faInfoCircle} className="text-gray-400 text-2xl" />
    </div>
    <h3 className="text-gray-700 font-semibold text-lg mb-2">No SubEstimate Found</h3>
    <p className="text-gray-500 text-center max-w-md">
      No subestimate added yet. Create one using the form above to get started.
    </p>
  </div>
) : (
  <div className="space-y-4">
    {subworks.map(subwork => (
      <div key={subwork.id} className="bg-white rounded shadow overflow-hidden">
       <div 
  className="p-4 bg-gray-50 flex justify-between items-center cursor-pointer"
  onClick={() => toggleSubwork(subwork.id)}
>
  <div className="flex items-center flex-1">
    <div className="mr-2">
      {expandedSubworks.includes(subwork.id) ? 
        <FontAwesomeIcon icon={faChevronDown} /> : 
        <FontAwesomeIcon icon={faChevronRight} />
      }
    </div>
    {/* ADD THIS PART - Display subwork name */}
    <div className="flex flex-col">
      <h3 className="text-lg font-semibold text-gray-800">
        {subwork.subworkName || `SubWork ${subwork.id}`}
      </h3>
      <span className="text-sm text-gray-600">
        {(items[subwork.id] || []).length} items
      </span>
        <span className="text-sm font-medium text-blue-600">
    {isLoading ? (
      "Loading total..."
    ) : (
      `Total Amount Before RA: ₹${calculateSubworkTotal(subwork.id).toLocaleString('en-IN')}`
    )}
  </span>
    </div>
  </div>
  <button
    onClick={(e) => {
      e.stopPropagation();
      deleteSubwork(subwork.id);
    }}
    className="ml-4 text-red-600 hover:text-red-800 transition-colors"
  >
    <FontAwesomeIcon icon={faTrash} />
  </button>
</div>


        <AnimatePresence>
          {expandedSubworks.includes(subwork.id) && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: 'auto', opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.3 }}
              className="overflow-hidden bg-gray-50"
            >
             <div className="p-6 border-t border-gray-200">
                {isItemLoading ? (
                  <div className="text-center py-6">
                    <FontAwesomeIcon icon={faSpinner} spin className="text-gray-600 text-xl mb-2" />
                    <p className="text-gray-600">Loading items...</p>
                  </div>
                ) : (
                  <>
                    <div className="flex justify-between items-center mb-4">
                      <h4 className="text-lg font-semibold text-gray-700">
                        Items for: {subwork.subworkName}
                      </h4>
                    </div> 

                    
                   {/* Table Section */}
<div className="relative">
  <table className="min-w-full bg-white border border-gray-200 rounded-lg overflow-hidden">
    <thead className="bg-gray-100">
      <tr>
        <th className="py-3 px-4 text-left font-medium text-gray-700">Sr No.</th>
        <th className="py-3 px-4 text-left font-medium text-gray-700">Item No.</th>
        <th className="py-3 px-4 text-left font-medium text-gray-700">Category</th>
        <th className="py-3 px-4 text-left font-medium text-gray-700 w-1/3">Description</th>
        <th className="py-3 px-4 text-center font-medium text-gray-700 w-32">Actions</th>
      </tr>
    </thead>
    <tbody>
      {/* Existing items with inline editing */}
      {(items[subwork.id] || [])
        .filter(item => {
          const query = searchQueries[subwork.id] || '';
          return (
            item.itemNo?.toLowerCase().includes(query.toLowerCase()) ||
            item.category?.toLowerCase().includes(query.toLowerCase()) ||
            item.descriptionOfItem?.toLowerCase().includes(query.toLowerCase())
          );
        })
        .map((item, index) => (
          <React.Fragment key={item.id}>
            {/* Item row - either display mode or edit mode */}
            <tr className={`border-b border-gray-100 hover:bg-gray-50 ${editingItemId === item.id ? 'bg-amber-50 border-amber-200' : ''}`}>
              <td className="py-3 px-4 text-gray-700">
                <div className="flex flex-col items-center">
                  <span className="font-medium">{index + 1}</span>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setVisibleMeasurements(prev => ({
                        ...prev,
                        [item.id]: !prev[item.id]
                      }));
                    }}
                    className="text-gray-600 hover:text-gray-800 transition-colors mt-1"
                    title={visibleMeasurements[item.id] ? "Hide Measurements" : "Show Measurements"}
                  >
                    <FontAwesomeIcon 
                      icon={visibleMeasurements[item.id] ? faChevronDown : faChevronRight} 
                    />
                  </button>
                </div>
              </td>
              
              {/* Item No Column */}
              <td className="py-3 px-4 relative">
                {editingItemId === item.id ? (
                  <SearchableDropdown
                    options={itemOptions}
                    value={itemForm.itemNo}
                    onChange={(value, option) => {
                      handleItemFieldChange('itemNo', value, subwork.id, option);
                    }}
                    onKeyDown={handleKeyDown}
                    searchKey="ssrItemId"
                    displayKey="ssrItemId"
                    placeholder="Select Item No"
                    error={itemFormErrors.itemNo}
                    className="w-full"
                    showAllOnFocus={true}
                    minSearchLength={0}
                    disabled={isItemLoading}
                    loading={isItemLoading}
                    zIndex={2000}
                  />
                ) : (
                  <span className="font-medium text-gray-800">{item.itemNo}</span>
                )}
              </td>
              
              {/* Category Column */}
              <td className="py-3 px-4 relative">
                {editingItemId === item.id ? (
                  <SearchableDropdown
                    options={itemOptions}
                    value={itemForm.category}
                    onChange={(value, option) => {
                      handleItemFieldChange('category', value, subwork.id, option);
                    }}
                    onKeyDown={handleKeyDown}
                    searchKey="category"
                    displayKey="category"
                    placeholder="Select Category"
                    error={itemFormErrors.category}
                    className="w-full"
                    showAllOnFocus={true}
                    minSearchLength={0}
                    filterUnique={true}
                    disabled={isItemLoading}
                    loading={isItemLoading}
                    zIndex={1990}
                  />
                ) : (
                  <span className="text-gray-700">{item.category}</span>
                )}
              </td>
              
              {/* Description Column - Updated with better text management */}
              <td className="py-3 px-4 max-w-xs relative">
                {editingItemId === item.id ? (
                  <SearchableDropdown
                    options={itemOptions}
                    value={itemForm.descriptionOfItem}
                    onChange={(value, option) => {
                      handleItemFieldChange('descriptionOfItem', value, subwork.id, option);
                    }}
                    onKeyDown={handleKeyDown}
                    searchKey="description"
                    displayKey="description"
                    placeholder="Select Description"
                    error={itemFormErrors.descriptionOfItem}
                    className="w-full"
                    showAllOnFocus={true}
                    minSearchLength={0}
                    filterUnique={true}
                    disabled={isItemLoading}
                    loading={isItemLoading}
                    zIndex={1980}
                  />
                ) : (
                  <div className="group relative">
                    <div className="text-gray-700 text-sm leading-relaxed line-clamp-2 break-words">
                      {item.descriptionOfItem}
                    </div>
                    {item.descriptionOfItem && item.descriptionOfItem.length > 60 && (
                      <div className="absolute hidden group-hover:block bg-gray-800 text-white text-sm p-2 rounded-lg shadow-lg z-50 top-0 left-0 min-w-max max-w-sm">
                        {item.descriptionOfItem}
                      </div>
                    )}
                  </div>
                )}
              </td>
              
              {/* Actions Column */}
              <td className="py-3 px-4 text-center">
                {editingItemId === item.id ? (
                  // Edit mode actions
                  <div className="flex justify-center items-center space-x-2">
                    <button
                      onClick={() => saveItem(true)}
                      disabled={isItemLoading || !itemForm.itemNo?.trim() || !itemForm.category?.trim() || !itemForm.descriptionOfItem?.trim()}
                      className="bg-orange-600 text-white px-3 py-1.5 rounded hover:bg-orange-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                      title="Save Changes"
                    >
                      {isItemLoading ? (
                        <FontAwesomeIcon icon={faSpinner} spin />
                      ) : (
                        <FontAwesomeIcon icon={faSave} />
                      )}
                    </button>
                    <button
                      onClick={() => {
                        setEditingItemId(null);
                        resetItemForm();
                      }}
                      disabled={isItemLoading}
                      className="bg-gray-600 text-white px-3 py-1.5 rounded hover:bg-gray-700 transition-colors disabled:bg-gray-400"
                      title="Cancel Edit"
                    >
                      <FontAwesomeIcon icon={faTimes} />
                    </button>
                  </div>
                ) : (
                  // Display mode actions
                  <div className="flex justify-center space-x-3">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        editItem(item);
                      }}
                      className="text-amber-600 hover:text-amber-800 transition-colors"
                      title="Edit"
                    >
                      <FontAwesomeIcon icon={faEdit} />
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        deleteItem(item.id);
                      }}
                      className="text-red-600 hover:text-red-800 transition-colors"
                      title="Delete"
                    >
                      <FontAwesomeIcon icon={faTrash} />
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        viewItemDetails(item);
                      }}
                      className="text-gray-600 hover:text-gray-800 transition-colors"
                      title="View Details"
                    >
                      <FontAwesomeIcon icon={faInfoCircle} />
                    </button>
                  </div>
                )}
              </td>
            </tr>
            
            {/* Measurements row - only show if expanded */}
            {visibleMeasurements[item.id] && (
              <>
                <tr>
                  <td colSpan="5" className="p-0">
                    {/* Measurement section with controlled z-index */}
                    <div className="relative" style={{ zIndex: 1 }}>
                      <div className="p-4 bg-gray-50 border-t">
                        <div className="flex justify-between items-center mb-3">
                          <h5 className="text-md font-medium text-gray-700">
                            Measurements for: {item.itemNo}
                          </h5>
                          <button
                            onClick={() => setVisibleMeasurements(prev => ({
                              ...prev,
                              [item.id]: false
                            }))}
                            className="text-gray-500 hover:text-gray-700"
                            title="Hide Measurements"
                          >
                            <FontAwesomeIcon icon={faTimes} />
                          </button>
                        </div>
                        


<MeasurementTable 
  itemId={item.id} 
  token={jwtToken} 
  unitLabel={item.smallUnit || "Cu.M."} 
  multifloor={parseInt(workOrderInfo.multifloor) === 1}
  fkSsrId={parseInt(workOrderInfo.fkSsrId) || 0} 
  itemsFromParent={(() => {
    const currentSubworkItems = items[subwork.id] || [];
    const previousItems = [];
    for (const subItem of currentSubworkItems) {
      if (subItem.id === item.id) break;
      previousItems.push(subItem);
    }
    return previousItems;
  })()}
  completedRate={item.completedRate || 0}
  onQuantityUpdate={(totalQuantity) => {
    setItemTotalQuantities(prev => ({
      ...prev,
      [item.id]: totalQuantity
    }));
  }}
  onCollapseChange={(isCollapsed) => handleMeasurementCollapseChange(item.id, isCollapsed)}
  onMeasurementAdded={(itemId) => {

    setVisibleMeasurements(prev => ({
      ...prev,
      [itemId]: false
    }));
  }}
  // NEW PROPS FOR SAME AS ABOVE
  currentSubworkItems={(() => {
    const currentItems = items[subwork.id] || [];
    return currentItems
      .filter(subItem => subItem.id !== item.id) // Exclude current item
      .map(subItem => ({
        id: subItem.id,
        itemNo: subItem.itemNo,
        totalQuantity: itemTotalQuantities[subItem.id] || 0,
        smallUnit: subItem.smallUnit || "Cu.M.",
        descriptionOfItem: subItem.descriptionOfItem
      }));
  })()}
  onSameAsAboveSubmit={(selectedItem, percentage, calculatedQuantity) => {
   
    // Optionally refresh data or show additional notifications
  }}
  showNotification={toast ? (message, type) => {
    if (type === 'success') toast.success(message);
    else if (type === 'error') toast.error(message);
    else toast.info(message);
  } : undefined}
/>
                      </div>
                    </div>
                  </td>
                </tr>
              </>
            )}
          </React.Fragment>
        ))}

      
      {/* Add new item section - Show + icon or form based on state */}
    {!editingItemId && (
  <>
    {!showNewItemForm[subwork.id] ? (
      // Show + icon button with proper positioning and tooltip
      <tr className="transition-colors">
        <td colSpan="5" className="py-4 px-6">
          <div className="flex justify-start ml-16">
            <div className="relative inline-block group">
              <button
                onClick={() => handleShowNewItemForm(subwork.id)}
                className="flex items-center justify-center w-10 h-10 bg-orange-500 text-white rounded-full hover:bg-orange-600 hover:scale-110 transform transition-all duration-200 shadow-lg hover:shadow-xl"
                title="Add New Item"
              >
                <FontAwesomeIcon icon={faPlus} className="text-lg" />
              </button>
              
              {/* Attractive Tooltip */}
              <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-orange-600 text-white text-sm rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap z-10">
                <span className="font-medium">Add New Item</span>
                {/* Tooltip Arrow */}
                <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-orange-600"></div>
              </div>
            </div>
          </div>
        </td>
      </tr>
    ) : (
            // Show new item form
            <tr className="bg-slate-50 border-2 border-slate-200 hover:bg-slate-100 transition-colors">
              <td className="py-3 px-4 text-center">
                <FontAwesomeIcon 
                  icon={faPlus} 
                  className="text-slate-600" 
                />
              </td>
              <td className="py-3 px-4 relative">
                <SearchableDropdown
                  options={itemOptions}
                  value={itemForm.itemNo}
                  onChange={(value, option) => {
                    handleItemFieldChange('itemNo', value, subwork.id, option);
                  }}
                  onKeyDown={handleKeyDown}
                  searchKey="ssrItemId"
                  displayKey="ssrItemId"
                  placeholder="Select Item No"
                  error={itemFormErrors.itemNo}
                  className="w-full"
                  showAllOnFocus={true}
                  minSearchLength={0}
                  disabled={isItemLoading}
                  loading={isItemLoading}
                  zIndex={1500}
                />
              </td>
              <td className="py-3 px-4 relative">
                <SearchableDropdown
                  options={itemOptions}
                  value={itemForm.category}
                  onChange={(value, option) => {
                    handleItemFieldChange('category', value, subwork.id, option);
                  }}
                  onKeyDown={handleKeyDown}
                  searchKey="category"
                  displayKey="category"
                  placeholder="Select Category"
                  error={itemFormErrors.category}
                  className="w-full"
                  showAllOnFocus={true}
                  minSearchLength={0}
                  filterUnique={true}
                  disabled={isItemLoading}
                  loading={isItemLoading}
                  zIndex={1490}
                />
              </td>
              <td className="py-3 px-4 max-w-xs relative">
                <SearchableDropdown
                  options={itemOptions}
                  value={itemForm.descriptionOfItem}
                  onChange={(value, option) => {
                    handleItemFieldChange('descriptionOfItem', value, subwork.id, option);
                  }}
                  onKeyDown={handleKeyDown}
                  searchKey="description"
                  displayKey="description"
                  placeholder="Select Description"
                  error={itemFormErrors.descriptionOfItem}
                  className="w-full"
                  showAllOnFocus={true}
                  minSearchLength={0}
                  filterUnique={true}
                  disabled={isItemLoading}
                  loading={isItemLoading}
                  zIndex={1480}
                />
              </td>
              <td className="py-3 px-4 text-center">
                <div className="flex justify-center items-center space-x-2">
                  {/* Save button - only show when ready */}
                  {itemForm.itemNo?.trim() && 
                   itemForm.category?.trim() && 
                   itemForm.descriptionOfItem?.trim() && 
                   !autoSaveTimeout && 
                   !isItemLoading && (
                    <button
                      onClick={() => saveItem(true)}
                      className="bg-green-600 text-white px-3 py-1.5 rounded hover:bg-green-700 transition-colors"
                      title="Save Item"
                    >
                      <FontAwesomeIcon icon={faSave} />
                    </button>
                  )}
                  
                  {/* Cancel button */}
                  <button
                    onClick={() => handleHideNewItemForm(subwork.id)}
                    className="bg-gray-600 text-white px-3 py-1.5 rounded hover:bg-gray-700 transition-colors"
                    title="Cancel"
                  >
                    <FontAwesomeIcon icon={faTimes} />
                  </button>
                  
                  {/* Status indicators */}
                  {autoSaveTimeout && (
                    <div className="flex items-center space-x-1 text-blue-600">
                      <FontAwesomeIcon icon={faSpinner} spin className="text-sm" />
                      <span className="text-xs">Auto-saving...</span>
                    </div>
                  )}
                  
                  {itemForm.itemNo?.trim() && 
                   itemForm.category?.trim() && 
                   itemForm.descriptionOfItem?.trim() && 
                   !autoSaveTimeout && 
                   !isItemLoading && (
                    <div className="flex items-center space-x-1 text-green-600">
                      <FontAwesomeIcon icon={faCheck} className="text-sm" />
                      <span className="text-xs">Ready</span>
                    </div>
                  )}
                  
                  {isItemLoading && (
                    <div className="flex items-center space-x-1 text-orange-600">
                      <FontAwesomeIcon icon={faSpinner} spin className="text-sm" />
                      <span className="text-xs">Processing...</span>
                    </div>
                  )}
                </div>
              </td>
            </tr>
          )}
        </>
      )}
    </tbody>
  </table>
</div>
                   
                  </>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    ))}
  </div>
)}
</motion.div>
       

{/* Item Details Modal with loading state and materials */}
{showItemDetailsModal && (
  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div className="bg-white rounded-lg shadow-xl max-w-5xl w-full max-h-[90vh] overflow-y-auto">
      <div className="bg-blue-600 text-white p-4 rounded-t-lg">
        <div className="flex items-center justify-between">
          <h3 className="text-xl font-semibold">Item Details</h3>
          <button
            onClick={() => setShowItemDetailsModal(false)}
            className="text-white hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-blue-600 rounded-lg p-1 transition-colors ml-auto"
            aria-label="Close modal"
          >
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>
      
      {itemDetails ? (
        <div className="p-6 relative">
          {/* Loading overlay */}
          {isLoading && (
            <div className="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10">
              <div className="text-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
                <p className="mt-2 text-gray-600">Loading item details...</p>
              </div>
            </div>
          )}
          
          <form className="space-y-6">
            {/* Basic Item Information */}
            <div className="bg-gray-50 p-4 rounded-lg">
              <h4 className="text-lg font-semibold text-gray-800 mb-4 border-b pb-2">Basic Information</h4>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Item Number</label>
                  <input
                    type="text"
                    value={itemDetails.itemNo || ""}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Page Number</label>
                  <input
                    type="text"
                    value={itemDetails.pageNo || "N/A"}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Category</label>
                  <input
                    type="text"
                    value={itemDetails.category || "N/A"}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Chapter Name</label>
                  <input
                    type="text"
                    value={itemDetails.chapterName || "N/A"}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Reference Number</label>
                  <input
                    type="text"
                    value={itemDetails.referenceNo || "N/A"}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Small Unit</label>
                  <input
                    type="text"
                    value={itemDetails.smallUnit || "N/A"}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Full Unit</label>
                  <input
                    type="text"
                    value={itemDetails.fullUnit || "N/A"}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Completed Rate</label>
                  <input
                    type="number"
                    value={itemDetails.completedRate || 0}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Labour Rate</label>
                  <input
                    type="number"
                    value={itemDetails.labourRate || 0}
                    className="w-full p-2 border border-gray-300 rounded bg-gray-100"
                    readOnly
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">SCADA Flag</label>
                  <select
                    value={itemDetails.scadaFlag ? "true" : "false"}
                    onChange={(e) => {
                      const newValue = e.target.value === "true";
                      setItemDetails(prev => ({
                        ...prev,
                        scadaFlag: newValue
                      }));
                    }}
                    className="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  >
                    <option value="true">Yes</option>
                    <option value="false">No</option>
                  </select>
                </div>
              </div>

              {/* Description Section - Full Width */}
              <div className="mt-6">
                <label className="block text-sm font-medium text-gray-700 mb-2">Description</label>
                <div className="w-full p-3 border border-gray-300 rounded bg-gray-100 min-h-[80px]">
                  <p className="text-gray-800 leading-relaxed whitespace-pre-wrap break-words">
                    {itemDetails.description || itemDetails.descriptionOfItem || "N/A"}
                  </p>
                </div>
              </div>

              {/* Additional Specification */}
              <div className="mt-4">
                <label className="block text-sm font-medium text-gray-700 mb-1">Additional Specification</label>
                <textarea
                  value={itemDetails.additionalSpecification || "N/A"}
                  className="w-full p-2 border border-gray-300 rounded bg-gray-100 h-20 resize-none"
                  readOnly
                />
              </div>
            </div>
            
            {/* Transaction Item Properties Section - Enhanced */}
<div className="bg-white border border-gray-200 rounded-lg">
  <div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 rounded-t-lg border-b">
    <div className="flex items-center justify-between">
      <div className="flex items-center space-x-3">
        <div className="bg-blue-600 p-2 rounded-lg">
          <svg className="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                  d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        </div>
        <h4 className="text-lg font-semibold text-gray-800">Material</h4>
      </div>
      <div className="flex items-center space-x-2">
        {itemDetails.itemProperties && itemDetails.itemProperties.length > 0 && (
          <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
            </svg>
            {itemDetails.itemProperties.length} Properties
          </span>
        )}
      </div>
    </div>
  </div>
  
  <div className="p-4">
  {itemDetails.itemProperties && itemDetails.itemProperties.length > 0 ? (
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    {itemDetails.itemProperties.map((property, index) => {
      const isSand = isSandMaterial(property.material);
      const isCrushedSand = isCrushedSandMaterial(property.material);
      const isAlreadySplit = isSandAlreadySplit(property.material);
      const splitType = getSandSplitType(property.material);
      const existingSplitPercentage = getExistingSplitPercentage(property.material);
      
      // Check if this material has been split (either this one or its complement exists)
      const hasBeenSplit = itemDetails.itemProperties.some(prop => 
        prop.id !== property.id && 
        ((property.material.toLowerCase().includes('sand') && !property.material.toLowerCase().includes('crushed') && 
          prop.material.toLowerCase().includes('crushed') && prop.material.toLowerCase().includes('(crushed -')) ||
         (property.material.toLowerCase().includes('crushed sand') && 
          prop.material.toLowerCase().includes('sand') && prop.material.toLowerCase().includes('(regular -')))
      );
      
      // Updated currentPercentage logic to handle clearing properly
      const currentPercentage = splitType === 'regular_to_crushed' 
        ? (crushedSandPercentages[property.id] !== undefined ? crushedSandPercentages[property.id] : (existingSplitPercentage || ''))
        : (regularSandPercentages[property.id] !== undefined ? regularSandPercentages[property.id] : (existingSplitPercentage || ''));
        
      const remainingPercentage = currentPercentage ? (100 - parseFloat(currentPercentage)) : '';
      const showInput = showSandSplitInput[property.id];
      
      return (
        <div key={`property-${property.id || index}`} 
             className="border rounded-lg p-4 hover:shadow-md transition-all bg-gray-50 border-gray-200">
          
          {/* Material Header */}
          <div className="flex items-start justify-between mb-2">
            <div className="flex items-start space-x-2 flex-1 min-w-0">
              <h5 className="font-medium text-gray-900 break-words leading-tight min-w-0">
                {property.material || "Unknown Material"}
              </h5>
              <div className="flex-shrink-0 flex flex-col space-y-1">
                {(isSand || isCrushedSand) && !isAlreadySplit && !hasBeenSplit && (
                  <span className="inline-flex items-center px-2 py-1 rounded text-xs bg-blue-100 text-blue-700 whitespace-nowrap">
                    Sand Material
                  </span>
                )}
              </div>
            </div>
          </div>

          {/* Material Details */}
          <div className="space-y-1 text-sm text-gray-600 mb-3">
            <div className="flex justify-between">
              <span>Material Unit:</span>
              <span className="font-medium">{property.materialUnit || "N/A"}</span>
            </div>
            <div className="flex justify-between">
              <span>Constant:</span>
              <span className="font-mono bg-gray-200 px-1 rounded">
                {property.materialConstant !== null && property.materialConstant !== undefined 
                  ? Number(property.materialConstant).toFixed(4) 
                  : "0.0000"}
              </span>
            </div>
          </div>

          {/* Sand-specific Controls */}
          {(isSand || isCrushedSand) && splitType && (
            <div className="border-t border-gray-200 pt-3">
              {!showInput && !isAlreadySplit && !hasBeenSplit ? (
                // Show split button only if not already split and no complement exists
                <button
                  type="button"
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setShowSandSplitInput(prev => ({
                      ...prev,
                      [property.id]: true
                    }));
                  }}
                  className="w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors flex items-center justify-center space-x-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                          d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                  </svg>
                  <span>
                    {splitType === 'regular_to_crushed' ? 'Split to Crushed Sand' : 'Split to Regular Sand'}
                  </span>
                </button>
              ) : (isAlreadySplit || hasBeenSplit) && !showInput ? (
                // Show material info and edit button if already split
                <div className="space-y-2">
                  {isAlreadySplit && (
                    <div className="text-sm">
                      <div className="flex justify-between items-center">
                        <span className="text-gray-600">Split Percentage:</span>
                        <span className="font-medium text-green-600">{existingSplitPercentage}%</span>
                      </div>
                    </div>
                  )}
                  
                  <button
                    type="button"
                    onClick={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      
                      // Set the input visible first
                      setShowSandSplitInput(prev => ({
                        ...prev,
                        [property.id]: true
                      }));
                      
                      // Pre-fill with existing percentage value for editing
                      if (isAlreadySplit && existingSplitPercentage) {
                        const currentSplitType = property.material.toLowerCase().includes('crushed') 
                          ? 'crushed_to_regular' 
                          : 'regular_to_crushed';
                          
                        if (currentSplitType === 'regular_to_crushed') {
                          setCrushedSandPercentages(prev => ({
                            ...prev,
                            [property.id]: existingSplitPercentage.toString()
                          }));
                        } else {
                          setRegularSandPercentages(prev => ({
                            ...prev,
                            [property.id]: existingSplitPercentage.toString()
                          }));
                        }
                      }
                    }}
                    className="w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded transition-colors flex items-center justify-center space-x-2"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                            d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>
                    <span>Edit Split</span>
                  </button>
                </div>
              ) : (
                // Show input form for both new split and edit
                <div className="space-y-3">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      {isAlreadySplit 
                        ? (property.material.toLowerCase().includes('crushed') ? 'Crushed Sand %' : 'Regular Sand %')
                        : (splitType === 'regular_to_crushed' ? 'Crushed Sand %' : 'Regular Sand %')
                      }
                    </label>
                    <input
                      type="number"
                      min="0"
                      max="100"
                      step="0.1"
                      value={currentPercentage}
                      onChange={(e) => {
                        const currentSplitType = isAlreadySplit 
                          ? (property.material.toLowerCase().includes('crushed') ? 'crushed_to_regular' : 'regular_to_crushed')
                          : splitType;
                        handleSandPercentageChange(property.id, e.target.value, currentSplitType);
                      }}
                      onKeyDown={(e) => {
                        // Prevent form submission on Enter key
                        if (e.key === 'Enter') {
                          e.preventDefault();
                        }
                      }}
                      className="w-full p-2 border border-gray-300 rounded focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                      placeholder="Enter percentage (0-100)"
                      autoComplete="off"
                    />
                  </div>
                  
                  {currentPercentage && parseFloat(currentPercentage) > 0 && (
                    <div className="bg-gray-50 p-3 rounded border">
                      <h6 className="text-sm font-medium text-gray-700 mb-2">Preview:</h6>
                      <div className="space-y-1 text-sm">
                        <div className="flex justify-between">
                          <span>
                            {isAlreadySplit 
                              ? (property.material.toLowerCase().includes('crushed') ? 'Crushed Sand:' : 'Regular Sand:')
                              : (splitType === 'regular_to_crushed' ? 'Crushed Sand:' : 'Regular Sand:')
                            }
                          </span>
                          <span className="font-mono">
                            {((parseFloat(property.materialConstant) || 0) * parseFloat(currentPercentage) / 100).toFixed(4)}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span>
                            {isAlreadySplit 
                              ? (property.material.toLowerCase().includes('crushed') ? 'Regular Sand:' : 'Crushed Sand:')
                              : (splitType === 'regular_to_crushed' ? 'Regular Sand:' : 'Crushed Sand:')
                            }
                          </span>
                          <span className="font-mono">
                            {((parseFloat(property.materialConstant) || 0) * remainingPercentage / 100).toFixed(4)}
                          </span>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  <div className="flex space-x-2">
                    <button
                      type="button"
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const currentSplitType = isAlreadySplit 
                          ? (property.material.toLowerCase().includes('crushed') ? 'crushed_to_regular' : 'regular_to_crushed')
                          : splitType;
                        
                        if (isAlreadySplit || hasBeenSplit) {
                          updateExistingSandSplit(property, parseFloat(currentPercentage), currentSplitType);
                        } else {
                          saveSandEntries(property, parseFloat(currentPercentage), currentSplitType);
                        }
                      }}
                      disabled={!currentPercentage || parseFloat(currentPercentage) <= 0 || parseFloat(currentPercentage) > 100}
                      className="flex-1 bg-green-500 hover:bg-green-600 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-medium py-2 px-3 rounded transition-colors"
                    >
                      {isAlreadySplit || hasBeenSplit ? 'Update' : 'Save'}
                    </button>
                    <button
                      type="button"
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Hide input
                        setShowSandSplitInput(prev => ({
                          ...prev,
                          [property.id]: false
                        }));
                        
                        // Clear both percentage states by setting to empty string
                        setCrushedSandPercentages(prev => ({
                          ...prev,
                          [property.id]: ''
                        }));
                        
                        setRegularSandPercentages(prev => ({
                          ...prev,
                          [property.id]: ''
                        }));
                      }}
                      className="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-3 rounded transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              )}
            </div>
          )}
          
        </div>
      );
    })}
  </div>
) : (
      <div className="text-center py-12">
        <div className="mx-auto h-24 w-24 text-gray-300 mb-4">
          <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" className="w-full h-full">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} 
                  d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        </div>
        <h3 className="text-lg font-medium text-gray-900 mb-2">No Transaction Item Properties Found</h3>
        <p className="text-gray-500 text-sm mb-4">
          No properties have been created for this transaction item yet.
        </p>
        {itemDetails.consumptionMaterials && itemDetails.consumptionMaterials.length > 0 && (
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 max-w-md mx-auto">
            <div className="flex items-center">
              <svg className="w-5 h-5 text-blue-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
              </svg>
              <p className="text-blue-800 text-sm font-medium">
                Properties can be created from {itemDetails.consumptionMaterials.length} available consumption materials
              </p>
            </div>
          </div>
        )}
      </div>
    )}
  </div>
</div>
            

           
            
          </form>
        </div>
      ) : (
        <div className="p-6 text-center text-red-500">
          <div className="text-red-400 mb-4">
            <svg className="mx-auto h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                    d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <p className="text-lg font-medium">Failed to load item details</p>
          <p className="text-sm mt-2 text-gray-600">Please try again or contact support</p>
        </div>
      )}
        
      <div className="flex justify-end bg-gray-100 p-4 gap-3">
        <button
          onClick={() => {
            updateItemDetails(itemDetails);
          }}
          className="bg-orange-600 text-white px-4 py-2 rounded hover:bg-orange-700 disabled:bg-orange-300"
          disabled={isLoading || !itemDetails}
        >
          {isLoading ? 'Updating...' : 'Update'}
        </button>
        <button
          onClick={() => setShowItemDetailsModal(false)}
          className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600"
        >
          Close
        </button>
      </div>

      
    </div>
  </div>
)}


 <motion.div 
        className="mb-6 p-6 border border-gray-300 rounded-lg bg-white shadow-md"
        variants={itemVariants}
      >
        <h2 className="text-lg font-bold mb-4 text-blue-700">Add New SubEstimate</h2>
        <div className="flex flex-wrap items-center gap-4">
          <div className="w-full md:w-1/2 lg:w-2/3">
            <div className="relative">
              <input
                type="text"
                value={subworkName}
                onChange={handleSubworkNameChange}
                className={`w-full p-3 border ${subworkNameError ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all`}
                placeholder="Enter Subwork Name"
                ref={subworkInputRef}
              />
              {subworkNameError && (
                <p className="text-red-500 text-sm mt-1 absolute">SubEstimate name is required</p>
              )}
            </div>
          </div>
          <div className="w-full md:w-1/3 lg:w-1/4">
            <button
              className={`w-full ${subworkName.trim() ? 'bg-orange-600 hover:bg-orange-700' : 'bg-orange-400 cursor-not-allowed'} text-white py-3 px-4 rounded-lg transition-colors duration-300 flex items-center justify-center font-medium shadow-md`}
              onClick={addSubwork}
              disabled={isLoading || !subworkName.trim()}
            >
              {isLoading ? (
                <FontAwesomeIcon icon={faSpinner} spin className="mr-2" />
              ) : (
                <FontAwesomeIcon icon={faPlus} className="mr-2" />
              )}
              Create SubEstimate
            </button>
          </div>
        </div>
      </motion.div>
      <div className="mt-8 mb-6">
  <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
    <h3 className="text-lg font-semibold text-gray-800 mb-6 text-center">
      Which type of report do you want to generate?
    </h3>
    
    <div className="flex flex-col md:flex-row gap-4 mb-6">
      {/* Bank Estimate Option */}
      <div
        className={`flex-1 rounded-lg p-4 border cursor-pointer transition-all ${
          selectedReportType === 'bank'
            ? 'bg-orange-100 border-orange-400 ring-2 ring-orange-200'
            : 'bg-orange-50 border-orange-200 hover:bg-orange-100'
        }`}
        onClick={() => setSelectedReportType('bank')}
      >
        <div className="text-center">
          <FontAwesomeIcon icon={faFileAlt} className="text-orange-600 text-2xl mb-2" />
          <h4 className="font-medium text-gray-800">Bank Estimate</h4>
          <p className="text-xs text-gray-600">Complete estimate for bank submission</p>
        </div>
      </div>

      {/* MTS Report Option */}
      <div
        className={`flex-1 rounded-lg p-4 border cursor-pointer transition-all ${
          selectedReportType === 'mts'
            ? 'bg-orange-100 border-orange-400 ring-2 ring-orange-200'
            : 'bg-orange-50 border-orange-200 hover:bg-orange-100'
        }`}
        onClick={() => setSelectedReportType('mts')}
      >
        <div className="text-center">
          <FontAwesomeIcon icon={faFileAlt} className="text-orange-600 text-2xl mb-2" />
          <h4 className="font-medium text-gray-800">MTS Report</h4>
          <p className="text-xs text-gray-600">Continue with lead charges & transportation</p>
        </div>
      </div>
    </div>

    {/* Next Button */}
    <div className="flex justify-center">
      <button
        className={`py-3 px-8 rounded-lg transition-colors flex items-center text-base shadow-md ${
          selectedReportType
            ? 'bg-orange-600 text-white hover:bg-orange-700'
            : 'bg-gray-300 text-gray-500 cursor-not-allowed'
        }`}
        onClick={() => {
          if (selectedReportType === 'bank') {
            navigateToPdfPreview();
          } else if (selectedReportType === 'mts') {
            navigateToLead();
          }
        }}
        disabled={!selectedReportType}
      >
      
        Next
          <FontAwesomeIcon icon={faArrowRight} className="mr-2" />
      </button>
    </div>
  </div>
</div>



      </motion.div>

  );
};

export default SubEstimateForm;